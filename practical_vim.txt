The Pragmatic Programmers
Practical Vim
    Second Edition
Edit Text at the Speed of Thought

What readers are saying about 
    Practical Vim

I've learned more about Vim by reading this book
than I have from any other resource.
>> Robert Evans
    Software Engineer, Code Wranglers

After reading a couple of chapters of Practical 
Vim, I realized how little I knew.
From intermediate to beginner in thirty minutes!
>> Henrik Nyh
    Software Engineer

Practical Vim continues to change what I believe
a text can do.
>> John P.Daigle
    Developer, ThoughtWorks,Inc.

Drew has continued the wonderful work he has done 
with Vimcasts in this book, a must-read for anyone
serious about Vim.
>> Anders Janmyr
    Developer, Jayway

Practical Vim bridges the gap between the official
documentation and how to really use Vim. After 
reading a few chapters, I switched to using Vim
as my default editor. I've never looked back.
>> Janvier Collado
    QA Automation Engineer, Canonical Ltd.

Drew Neil does more than show the right tool for
the job. He paces the narrative, laying out the 
philosophy behind each decision. Instead of 
expecting you to memorize everything, Practical
Vim teaches you to think with Vim under your
fingertips.
>> Mislav Marohnic
    Consultant

I've been using Vim for server maintenance for 
more than fifteen years now. but I've only 
recently started using it for software development.
I thought I knew Vim, but Practical Vim has 
massively improved my code-wrangling productivity.
>> Graeme Mathieson
    Software Engineer, Rubaidh Ltd.

Practical Vim made me realize how much there is
still to learn about Vim. Every single tip cap be
easily and immediately applied to your workflow
and improve your productivity manifold.
>> Mathias Meyer
    Author, Riak Handbook

Practical Vim is the ultimate treasure chest when
it comes to Vim knowledge. I've used Vim daily for
over two years now, and this book has been nothing
short of a revelation for me.
>> Felix Geisendorfer
    Cofounder, Transloadit

Practical Vim, Second Edition
    Edit Text at the speed of Thought
                                    Drew Neil

                            The Pragmatic Bookshelf
             Dallas, Texas Raleigh, North Carolina 

Pragmatic Bookshelf

Many of the designations used by manufacturers and
sellers to distinguish their products are claimed
as trademarks. Where those designations appear in
this book, and The Pragmatic Programmers, LLC was
aware of a trademark claim, the designations have
been printed in initial capital letters or in all
capitals. The Pragmatic Starter Kit, The Pragmatic
Programmer, Pragmatic Programming, Pragmetic 
Bookshelf, PragProg and the linking g device are
trademarks of The Pragmatic Programmers, LLC.

Every precaution was taken in the preparation of
this book. However, the publisher assumes no 
responsibility for errors or omissions, or for
damages that may result from the use of information
(including program listings) contained herein.

Our Pragmatic courses, workshops, and other 
products can help you and your team create better
software and have more fun. For more information,
as well as the latest Pragmatic titles, pleas
visit us at https://pragprog.com.

The team that produced this book includes:

Katharine Dvorak (editor)
Potomac Indexing, LLC (index)
Cathleen Small (copyedit)
Dave Thomas (layout)
Janet Furlow (producer)
Ellie Callahan (support)

For international rights, please contact 
rights@pragprog.com.

Copyright (C) 2015 The Pragmatic Programmers, LLC.
All rights reserved.

No part of this publication may be reproduced,
stored in a retrieval system, or transmitted,
in any form, or by any means, electronic, 
mechanical, photocopying, recording, or otherwise,
without the prior consent of the publisher.

Printed in the United States of America.
ISBN-13:978-1-60850-127-8
Encoded using the finest acid-free high-entropy
binary digits.
Book version:P1.1__January2016

                                        
                                        Contents
    Acknowledgments                             xi
    Foreword to the First Edition               xv
    Read Me                                   xvii
    Read the Forgotten Manual                  xix
1.  The Vim Way                                  1
    Tip 1.  Meet the Dot Command                 1
    Tip 2.  Don't Repeat Yourself                4
    Tip 3.  Take One Step Back, 
                Then Three Forward               6
    Tip 4.  Act, Repeat, Reverse                 8
    Tip 5.  Find and Replace by Hand             9
    Tip 6.  Meet the Dot Formula                11

//TODO




                                
                                 Acknowledgments

Thanks to Bram Moolenaar for creating Vim and to 
all those who have contributed to its development.
It's a timeless piece of software, and I look 
forward to growing with it.

Thanks to everyone at the Pragmatic Bookshelf for 
working together to make this book the best that
it could be. Special thanks to Kay Keppler, my 
developmental editor, for coaching me as a writer
and for helping to shape this book, despite its 
growing pains and my occasional tantrums. Thanks
also to Katharine Dvorak, my development editor 
for this revised edition. I'd also like to thank
David Kelly for his adept handling of my unusual
formatting requests.

Practical Vim didn't start out as a recipe book,
but Susannah Pfalzer recognized that it would 
work best in this format. It was painful to have
to rewrite so much, but in doing so I produced a
draft that I was happy with for the first time.
Susannah knows what's best, and I thank her for 
sharing that insight.

Thanks to Dave Thomas and Andy Hunt for creating
the Pragmatic Bookshelf. I wouldn't want to be
represented by any other publisher, and I'm 
honored to be listed alongside the other titles
in thier catalog.

Practical Vim wouldn't have been possible without
my technical reviewers. Each of you contributed
something and helped to shape the book.
I'd like to thank Adam McCrea, Alan Gardner, 
Alex Kahn, Ali Alwasity, Anders Janmyr, Andrew
Donaldson, Angus Neil, Charlie Tanksley, Ches
Martin, Daniel Bretoi, Dvid Morris, Denis Gorin, 
Elyezer Mendes Rezende, Erik St. Martin, Federico
Galassi, Felix Geisendorfer, Florian Vallen, 
Graeme Mathieson, Hans Hasselberg, Henrik Nyh, 
Javier Collado, Jeff Holland, Josh Sullivan, 
Joshua Flanagan, Kana Natsuno, Kent Frazier, 
Luis Merino, Mathias Meyer, Matt Southerdenm 
Mislav Marohnic, Mitch Guthrie, Morgan Prior,
Paul Barry. Peter Aronoff, Peter Rihn, Phillip
Roberts, Robert Evans, Ryan Stenhouse, Steven Ragnarok, Tibor Simic, Tim Chase, Tim Pope, Tim
Tyrrell, and Tobias Sailer.

Even with all of the feedback from my technical 
reviewers, some mistakes managed to stay hidden.
I'd like to thank everyone who has reported errors
in the book, helping me to locate and fix them.

Vim's built-in documentation is a terrific 
resource, and I make many references to it 
throughout Practical Vim. I'd like to thank Carlo
Teubner for publishing Vim's documentation online
at vimhelp.appspot.com and for keeping it up to 
date.

Some of the tips in the first edition of Practical
Vim were awkward, but I included them anyway 
because I felt that they were important. For this
revised edition, I'm pleased to have been able to
rewrite those awkward tips. Thanks to Christian
Brabandt for implementing the game-changing gn 
command, which allowed me to rewrite Tips 84, 
Operate in a Complete Search Match, in page 208.
Thanks to Yegappan Lakshmanan for implementing
the cfdo command (and family), which allowed me
to rewrite Tips 97, Find and Replace Across 
Multiple Files, on page 236. I'd also like to thank
David Burgin for patch 7.3.850, which fixed my pet
bug with the vimgrep command.

As a whole, I'd like to thank the Vim community
for sharing their insights across the Internet.
I learned many of the tips in this book by reading
the Vim tag on StackOverflow and by following
the vim_user mailing list.

Tim Pope's rails.vim plugin was instrumental in
convincing me to take Vim seriously, and many of
his other plugin have become essential parts of my
setup. I've also gained insight by using the 
plugins of Kana Natsuno, whose custome text objects
are some of the best extensions to Vim's core 
functioanlity that I've come across. Thank you both
for sharpening the saw so that the rest of us can
benefit.

Thanks to Joe Rozner for providing the wakeup
source code that I used to introduce the :make
command. Thanks to Oleg Efimov for his quick 
response to nodelint issues. Thanks to Ben Cormack
for illustrating the robots and ninjas.

In January 2012, we moved to Berlin, where the 
tech community inspired me to complete this book.
I'd like to thank Gregor Schmidt for founding the
Vim Berlin user group and Jan Schulz-Hofen for
hosting our meetups. The opportunity to speak to 
fellow Vim users really helped me to get my 
thoughts in order, so I'm grateful to everyone
who attended the Vim Berlin meetings. Thank you
to Daniel and Nina Holle for subletting your home
to us. It was wonderful place to live and a 
productive environment in which to work.

In March 2011, when I was living in Egypt, I need
surgery to clear adhesions that were obstructing
my bowel. Unlucky for me, I was a long way from
home. Luckily, my wife was by my side. Hannah
had me admitted to the South Sinai Hospital, where
I received excellent care. I want to thank all the
staff there for their kind help, and Dr.Shawket
Gerges for successfully operating on me.

When my mum learned that I required surgery, she 
dropped everything and was on the next flight to 
Egypt. Considering that the country was in 
revolution, it took enormous courage to do so.
I can't imagine how Hannah and I would have got 
through that diffcult time without the support
and experience that my mum brought. I consider 
myself blessed to have two such wonderful women in
my life.


                      Foreword to the First Edition

Conventional wisdom dictates that Vim has a steep
learning curve. I think most Vim users would 
disagree. Sure, threre's an initial hump, but once
you run through vimtutor and learn the basics of
what to put in your vimrc, you reach a point where
you can actually get work done --a sort of hobbled
productivity.

What comes next? The Internet's answer to this is
the "tip" --a recipe for solving a specific 
problem. You might search for specific tips when
your current solution to a problem feels 
suboptimal, or you might proactivly read some of
the more popular tips. This strategy works --it's
how I learned , after all --but it's slow. 
Learning that * searches for the word under the
cursor is helpful, but it hardly helps you think
like a Vim master.

You can understand my skepticism, then, when I 
found out Practical Vim was using a tips format.
How could a couple of hundred tips accomplish what
took me thousands? A few pages in I realized my
definition of "tip" was narrow-minded. In contrast
to the problem / solution pattern I had expected,
Practical Vim tips reach lessons in thinking like
a proficient Vim user. In a sense, they are more
like parables than recipes. The first few tips are
lessons about the eide applivability of the . 
command. This is a staple of any proficient Vim
user's repertoire, yet without guidance it was
years before I came to realize this on my own.

It is for this reason that I am excited about the
publication of Practical Vim. Because now when Vim
novices ask me what's the next step, I know what
to tell them. After all, Practical Vim even taught
me a few things.

Tim Pope
Vim core contributor
April 2012


                                        Read Me

Practical Vim is for programmers who want to raise
their game. You've heard it said that in the hands
if an expert, Vim shreds text at the speed of
thought. Reading this book is your next step 
toward that end.

Practical Vim is a fast track to Vim mastery. It
won't hold you by the hand, but beginners can find
the prerequisite knowledge by running through the
Vim tutor, an interactive lesson distributes with 
Vim. Practical Vim builds on this foundation by
highlighting core concepts and demonstrating
idiomatic usage.

Vim is highly configurable. However, customization
is a personal thing, so I've tried to avoid
recommending what should or should not got into
your vimrc file. Instead, Practical Vim focuses
on the core functionality of the editor --the stuff
that's always threre, whether you're working over
SSH on a remote server or using a local instance of
GVim, with plugins installed to add extra 
functionality. Master Vim's core, and you'll gain
portable access to a text editing power tool.

How This Book Is Structured

Practical Vim is a recipe book. It's not designed
to be read from start to finish. (I mean it! At the
start of the next chapter, I'll advise you to skip
it and jump straight to the action.) Each chapter
is a collection of tips that are related by a 
theme, and each tip demonstrates a particular 
feature in action. Some tips are self-contained.
Others depend upon material elsewhere in the book.
Those tips are cross-referenced so you can find
everything easily.

Practical Vim doesn't progress from novice to
advanced level, but each individual chapter does.
A less-experienced Vim user might prefer to make a
first pass through the book, reading just the 
early tips in each chapter. A more advanced user
might choose to focus on the later tips or move
around the books as needed.

A Note on the Examples

In Vim, there's always more than one way to 
complete any given task. For example, in Chapter 1,
The Vim Way, on page 1, all of the problems are
designed to illustrate an application of the dot
command, but every one of them could also be solved
using the  :substitute command.

On seeing my solution, you might think to yourself,
"Wouldn't it be quicker to do it this way?" And
you may well be right! My solutions illustrate a 
particular technique. Look beyond their simplicity,
and try to find a resemblance to the problems that
you face daily. That's where these techniques will
save your time.

Learn to Touch Type, Then Learn Vim

If you have to look down to find the keys on the
keyboard, the benefits of learning Vim won't come
fast. Learning to touch type is imperative.

Vim traces its ancestry back to the classic Unix
editors, vi and ed (see On the Etymology of Vim (
and Family), on page 55). These predate the mouse
and all of the point-and-click interfaces that 
came with it. In Vim, everything can be done with
the keyboard. For the touch typist, that means Vim
does everything faster.


                        Read the Forgotten Manual

In Practical Vim, I demonstrate by showing examples
rathar than by describing them. That's not easy to
do with the written word. To show the steps taken
during an interactive editing session, I've adopted
a simple notation that illustrates the keystrokes
and the contents of a Vim buffer side by side.

If you're keen to jump to the action, you can
safely skip this chapter for now. It describes
each of the conventions used throughout Practical
Vim, many of which you'll find to be 
self-explanatory. At some point, you'll probably
come across a symbol and wonder what it stands for.
When that happens, turn back and consult this 
chapter for the answer.

Get to Know Vim's Built-in Documentation

The best way to get to know Vim's documentation
is by spending time in it. To help out, I've 
included "hyperlink" for entries in Vim's 
docmentation. For example, here's the "hyperlink"
for the Vim tutor. :h vimtutor

The icon has a dual function. First, it serves
as a signpost, drawing the eye to these helpful
references. Second, if you're reading this on an
electronic device that's connected to the Internet,
you can click the icon and it will take you to the
relevant entry in Vim's online documentaion.
In this sense, it truly is a hyperlink.

But what if you're reading the paper edition of the
book? Not to worry. If you have an installation of
Vim within reach, simply enter the command as it
appears in front of the icon.

For example, type :h vimtutor (:h is an
abbreviation for the :help command). Consider this
is a unique address for the documentation on 
vimtutor. a URL of sorts. In this sense, the help
reference is a kind of hyperlink to Vim's built-in
documentation.

Notation for Simulating Vim on the Page

Vim's modal interface sets it apart from most other
text editors. To make a musical analogy, let's 
compare the Qwerty and piano keyboards. A pianist
can pick out melody by playing one note at a time
or he or she can hold down several keys at once
to sound a chord. In most text editors, keyboard
shortcuts are triggerd by pressing a key while
holding down one or more modifier buttons, such as
the control and command keys. This is the Qwerty
equivalent of playing a chord on the piano 
keyboard.

Some of Vim's commands are also triggered by 
playing chords, but Normal mode commands are 
designed to be typed as a sequence of keystrokes.
It's the Qwerty equivalent of playing a melogy
on the piano keyboard.

Ctrl-s is a common convention for representing 
chordal key commands. It means "Press the Control
key and the s key at the same time." But this
convention isn't well suited to describing Vim's
modal command set. In this section, we'll meet the
notation the used throghout Practical Vim to 
illustrate Vim usage.

Playing Melodies

In Normal mode, we compose commands by typing one
or more keystrokes in sequence. These command
appear as follows:

Notation    Meaning
x           Press x once
dw          In sequence, press d, then w
dap         In sequence, press d, a, then p

Most of these sequences involve two or three 
keystrokes, but some are longer. Deciphering the
meaning of Vim's Normal mode command sequences
can be challenging, but you'll get better at it
with practice.

Playing Chords

When you see a keystroke such as <C-p>, it doesn't
mean "Press <, then C, then -, and so on." The
<C-p> notation is equivalent to Ctrl-p, which means
"Press the <Ctrl> and p keys at the same time."

I didn't choose this notation without good reason.
Vim's documentation uses it (:h key-notation), and
we can also use it in defining custom kye mappings.
Some of Vim's commands are formed by combining
chords and keystrokes in sequence, and this 
notation handles them well. Consider these 
examples:

Notation    Meaning
<C-n>       Press <Ctrl> and n at the same time
g<C-]>      Press g, followed by <Ctrl> and ] at
                the same time
<C-r>0      Press <Ctrl> and r at the same time,
                then 0
<C-w><C-=>  Press <Ctrl> and w at the same time,
                then <Ctrl> and = at the same time

Placeholders

Many of Vim's commands require two or more 
keystrokes to be entered in sequence. Some commands
must be followed by a particular kind of keystroke,
while other commands can be followed by any key on
the keyboard. I use curly braces to denote the set
of valid keystrokes that can follow a command.
Here are some examples:

Notation        Meaning
f{char}         Press f, followed by any other 
                    characters
`{a-z}          Press `, followed by any lowercase
                    characters
m{a-zA-Z}       Press m, followed by lowercase or
                    uppercase letter
d{motion}       Press d, followed by motion command
<C-r>{register} Press <Ctrl> and r at the same 
                    time, followed by the address
                    of a register

Showing Special Keys

Some keys are called by name. This table shows a
selection of them:

Notation    Meaning
<ESC>       Press the Escape key
<CR>        Press the carriage return key (also
                known as <Enter>
<Ctrl>      Press the Control key
<Tab>       Press the Tab key
<Shift>     Press the Shift key
<S-Tab>     Press the <Shift> and <Tab> keys at 
                the same time
<Up>        Press the up arrow key
<Down>      Press the down arrow key
_           Press the space bar

Note that space bar is represented as _. This 
could be combined with the f{char} command to 
form f_.


Switching Modes Midcommand

When operating Vim, it's common to switch from
Normal to Insert mode and back again. Each 
keystroke could mean something different, depending
on which mode is active. I've used an alternative
style to represent keystrokes entered in Insert
mode, which makes it easy to differentiate them
from Normal mode keystrokes.

Consider this example: cwreplacement<Esc>. The
Normal mode cw command deletes to the end of the
current word and switches to Insert mode. Then we
type the word "replacement" in Insert mode and
press <Esc> to switch back to Normal mode again.

The Normal mode styling is also used for Visual
mode keystrokes, while the Insert mode styling
can indicate keystrokes entered in Command-Line
mode and Replace mode. Which mode is active should
be clear from context.


Interacting with the Command Line

In some tips we'll execute a command line, either
in the shell or from inside Vim. This is what it
looks like when we execute the grep command in the
shell:

$ grep -n Waldo *

And this is how it looks when we execute Vim's
built-in :grep command:

:grep Waldo *

In Practical Vim, the $ symbol that a command line
is to be executed in an external shell, whereas the
: prompt indicates that the command line is to be
excecuted internally from Command-Line mode. 
Occasionally we'll see other prompts, including
these:

Prompt  Meaning
$       Enter the command line in an external shell:       Use Command-Line mode to execute an Ex
            command
/       Use Command-Line mode to perform a forward
            search
?       Use Command-Line mode to perform a backward
            search
=       Use command-Line mode to evaluate a Vim
            script expression
            
Anytime you see an Ex command listed inline, such
as :write, you can assume that <CR> key is pressed
to execute the command. Nothing happend otherwise,
so you can consider <CR> to be implicit.

By contrast, Vim's search command allows us to
preview the first match befor pressing <CR> (see
Tip 82, Preview the First Match Before Execution,
on page 205). When you see a search command listed
inline, such as /pattern<CR>, the <CR> keystroke is
listed explicitly. If the <CR> is ommited, that's
intentional, and it means you shouldn't press the
Enter key just yet.


Showing the Cursor Position in a Buffer

When showing the contents of a buffer, it's useful
to be able to indicate where the cursor is 
positioned. In this example, you should see that
the cursor is placed on the first letter of the
word "One":

|One two three 

When we make a change that involves several steps,
the contents of the buffer pass throgh 
intermediate states. To illustrate the process, I
use a table showing the commands executed in the
left column and the contents of the buffer in the
right column. Here's simple example:

Keystrokes  BufferContents
{start}     |One two three
dw          |two three

In row 2 we run the dw command to delete the word
under the cursor. We can see how the buffer looks
immediately after running this command by looking
at the contents of the buffer in the same row.


Highlighting Search Matches

When demonstrating Vim's search command, it's
helpful to be able to highlight any matches that
occur in the buffer. In this example, searching
for the string "the" causes for occurrences of the
pattern to be highlighted:

Keystrokes  BufferContents
{start}     |the problem with these new recruits
                is that they don't keep their
                boots clean.
/the<CR>    _the_ problem with |the_se new recruits
                is that _the_y don't keep _the_ir
                boots clean.

Skip ahead to Tip 81, Highlight Search Matches, on
page 204, to find out how to enable search 
highlighting in Vim.


Selecting Text in Visual Mode

Visual mode lets us select text in the buffer and
then operate on the selection. Here, we use the it
text object to select the contentes of the <a> tag:

Keystrokes  BufferContents
{start}     <a |href="http://pragprog.com/dnvim/">
                Practical Vim</a>
vit         <a href="http://pragprog.com/dnvim/">
               _Practical Vi|m</a>

Note that the styling for a Visual selection is
the same for highlighted search matches. When you
see this style, it should be clear from context
whether it represents a serch match or a Visual
selection.


Downloading the Examples

The examples in Practical Vim usually begin by
showing the contents of a file before we change it.
These code listings include the file path:

macros/incremental.txt
partridge in a pear tree
turtle doves
French hens
calling birds
golden rings

Each time you see a file listed with its file path
in this manner, it means that you can download the
example. I recommend that you open the file in Vim
and try out the exercises for yourself. It's best
way to learn!

To follow along, download all the examples and
source code from the Pragmatic Bookshelf. If you're
reading on an electronic device that's connected
to the Internet, you can also fetch each file one
by one by clicking on the filename. Try it with 
the example above.


Use Vim's Factory Settings

Vim is highly configurable. If you don't like the
defaults, then you can change them. That's good
thing, but it could cause confusion if you follow
the examples in this book using a customized 
version of Vim. You may find that some things don't
work for you the way that they are described in 
text. If you suspect that your customizations are
causing interference, here's a quick test. Try 
quitting Vim and then launching it with these 
options:

$ vim -u NONE -N

The -u NONE flag tells Vim not to source your
vimrc on startup. That way, your customizations
won't be applied and plugins will be disabled.
When Vim starts up without loading a vimrc file,
it reverts to vi compatible mode, which causes
many useful features to be disabled. The -N flag
prevents this by setting the 'nocompatible'
option.

For most examples in Practical Vim, the vim -u
NONE -N trick should guarantee that you get the
same experience as described, but there are a
couple of exceptions. Some of Vim's built-in 
features are implemented with Vim script. Which
means that they will only work when plugins are
enabled. This file contains the absolute minimum 
configuration that is required to activate Vim's
built-in plugins:

essential.vim
set nocompatible
filetype plugin on

When launching Vim, you can use this file instead
of your vimrc by running the following

$ vim -u code/essential.vim

You'll have to adjust the code/essential.vim path
accordingly. With Vim's built-in plugins enabled,
you'll be able to use features such as netrw (Tip
44, Explore the File System with netrw, on page 104
) and omni-completion (Tip 119, Auto-complete with
Context Awareness, on page 293), as well as many
others. I consider Vim's factory settings to mean
built-in plugins enabled and vi compatibility
disabled.

Look out for subsections titled "Preparation" at
the top of a tip. To follow along with the material
in these tips, you'll need to configure Vim 
accordingly. If you start up with Vim's factory
settings and then apply the customizations on the
fly, you should be able to reproduce the steps
from these tips without any problems.

If you're still having problems, see On Vim 
Versions, on page xxvi.


On the Role of Vim Script

Vim script enables us to add new functionality to
Vim or to change existing functionality. It's a
complete scripting language in itself and a
subject worthy of a book of its own. Practical Vim
is not that book.

But we won't steer clear of the subject entirely.
Vim script is always just below the surface, ready
to do our bidding. We'll see a few examples of how
it can be used for everyday task in Tip 16, Do 
Back-of-the-Envelope Calculations in Place, on page
33; Tip 71, Evaluate an Iterator to Number Item in
a List, on page 177; Tip 95, Perform Arithmetic on
the Replacement, on page 233; and Tip 96, Swap Two
or More Words, on page 234.

Practical Vim show you how to get by with Vim's 
core functionality. In other words, no third-party
plugins assumed. I've made an exception for Tip 87,
Search for the Current Visual Selection, on page 
216. The visual-star.vim plugin adds a feature that
I find indispensable, and it requires very little
code --less than ten lines of Vim script. It 
demonstrates how easily Vim's funcionality can be
extended. The implementation of visual-star.vim is
presented inline without explanation. This should
give you an idea of what Vim script looks like and
what you can accomplish with it. If it piques your
interest, then so much better.


On Vim Versions

All examples in Practical Vim were tested on the
latest version of Vim, which was 7.4 at the time 
of writing. That said, most examples should work
fine on any 7.x release, and many of the features
discussed are also available in 6.x.

Some of Vim's functionality can be disables during
compilation. For example, when configuring the
build, we could provide the --with-features=tiny
option, which would disable all but the most
fundamental features (there are also feature sets
labeled small, nomal, big, and huge). You can
browse the feature list by looking up :h +feature-
list.

If you find that you're missing a feature discussed
in this book, you might be using a minimal Vim
build. Check whether or not the feature is 
available to you with the :version command:

:version
VIM - Vi IMproved 7.4 (2013 Aug 10, compiled Oct
14 2015 18:41:08)
Huge version without GUI. Features included (+) or
not (-):
+arabic +autocmd +baloon_eval +browse 
+builtin_terms +byte_offset +cindent +clientserver
+clipboard +cmdline_compl +cmdline_hist
+cmdline_info +comments
...

On a modern computer, there's no reason to use 
anything less than Vim's huge feature set!


Vim in the Terminal or Vim with a GUI? You Choose!

Traditionally, Vim runs inside of the terminal,
with no graphical user interface (GUI). We could
say instead that Vim has a TUI: a textual user
interface. If you spend most of your day at the
command linem this will feel natural.

If you're accustomed to using a GUI-based text 
editor, then GVim (or MacVim on OS X) will provide
a helpful bridge into the world of Vim 
(see :h gui). GVim supports more fonts and colors
for syntax highlighting. Also, you can use the
mouse. And some of the conventions of the 
operating system are honored. For example, in 
MacVim you can interact with the system clipboard
Cmd-X and Cmd-V, save a document with Cmd-S, or
close a window with Cmd-W. Use these while you find
your bearings, but be aware that there's always a
better way.

For the purpose of this book, it doesn't matter
whether you run Vim in the terminal or as GVim.
We'll focus on core commands that work just as well
in either. We'll learn how to do things the Vim
way.


                                        CHAPTER 1
                                    The Vim Way

Our worlk is repetitive by nature. Whether we're
making the same small change in several places or
moving around between similar regions of a 
document, we repeat many actions. Anything that 
can streamline a repetitive workflow will save our
time multifold.

Vim is optimized for repetition. Its efficiency
stems from the way it tracks our most recent 
actions. We can always replay the last change with
a single keystroke. Powerful as this sounds, it's
useless unless we learn to craft our actions so
that they perform a useful unit of work when 
replayed. Mastering this concept is the key to 
becoming effective with Vim.

The dot command is our starting point. This 
seemingly simple command is the most versatile 
tool in the box, and understanding it is the first
step toward Vim mastery. We'll work through a
handful of simple editing tasks that can be rapidly
completed with the dot command. Although each tasks
looks quite different from the next, their 
solutions almost converge. We'll identify an ideal
editing formula, which requires only one keystroke
to move and another to execute.


                                Tip 1
Meet the Dot Command

The dot command lets us repeat the last change.
It is the most powerful and versatile command in
Vim.

Vim's documentation simply states that the dot 
command "repeats the last change" (see :h .). It
doesn't sound like much, but in that simple 
definition we'll find the kernel of what makes
Vim's mordal editing model so effective. First we
have to ask, "What is a change?"

To understand the power of the dot command, we 
have to realize that the "last change" could be 
one of many things. A change could act at the 
level of individual characters, entire lines, or
even the whole file.

To demonstrate, we'll use this snippet of text:

the_vim_way/0_mechanics.txt
Line one
Line two
Line three
Line four

The x command deletes the character under the 
cursor. When we use the dot command in this 
context, "repeat last change" tells Vim to delete
the character under the cursor:

Keystrokes  BufferContents
--------------------------
{start}     |Line one
             Line two
             Line three
             Line four
--------------------------
x           |ine one
             Line two
             Line three
             Line four
--------------------------
.           |ne one
             Line two
             Line three
             Line four
--------------------------
..          | one
             Line two
             Line three
             Line four

We can restore the file to its original state by 
pressing the u key a few times to undo the changes.

The dd command also performs a deletion, but this
one acts on the current line as a whole. If we use
the dot command after dd, then "repeat last change"
instructs Vim to delete the current line:


Keystrokes  BufferContents
--------------------------
{start}     |Line one
             Line two
             Line three
             Line four
--------------------------
dd          |Line two
             Line three
             Line four
--------------------------
.           |Line three
             Line four

Finally, the >G command increases the indentation
from the current line until the end of the file. 
If we follow this command with the dot command, 
then "repeat last change" tells Vim to increase 
the indentation level from the current position to
the end of the file. In this example, we'll start
with the cursor on the second line to highlight 
the difference

Keystrokes  BufferContents
--------------------------
{start}      Line one
            |Line two
             Line three
             Line four
--------------------------
>G           Line one
                |Line two
             Line three
             Line four
--------------------------
j            Line one
                Line two
                |Line three
                Line four
--------------------------
.            Line one
                 Line two
                   |Line three
                    Line four
--------------------------
j.           Line one
                Line two
                    Line three
                       |Line four

The x, dd, > commands are all executed from Normal
mode, but we also create a change each time we dip
into Insert mode. From the moment we enter Insert
mode (by pressing i, for example) until we return
to Normal mode (by pressing <ESC>), Vim records
every keystroke. After making a change such as 
this, the dot command will replay our keystrokes
(see Moving Around in Insert Mode Resets the 
Change, on page 17, for a caveat).

The Dot Command Is a Micro Macro

Later, in Chapter 11, Macros, on page 161, we'll
see that Vim can record any arbitrary number of
keystrokes to be played back later. This allows us
to capture our most repetitive workflows and
replay them at a key stroke. We can think of the
dot command as being a miniature macro, or a 
"micro" if you prefer.

We'll see a few applications of the dot command
throughout this chapter. We'll also learn a couple
of best practices for working with the dot command
in Tip 9, Compose Repeatable Changes, on page 18,
and Tip 23, Prefer Operators to Visual Commands
Where Possible, on page 45.


                            Tip 2
Don't Repeat Yourself

For such a common use case as appending a semicolon
at the end of a series of lines, Vim provides a
dedicated command that combines two steps into one.

Suppose that we have a snippet of JavaScript code
like this:

the_vim_way/2_foo_bar.js
var foo = 1
var bar = 'a'
var foobar = foo + bar

We need to append a semicolon at the end of each
line. Doing so involves moving our cursor to the
end of the line and then switching to Insert mode
to make the change. The $ command will handle the
motion for us, and then we can run a;<ESC> to make
the change.

To finish the job, we could run the exact same 
sequence of keystrokes on the next two lines, but
that would be missing a trick. The dot command will
repeat that last change, so instead of duplicating
our efforts, we could just run j$. twice. One
keystroke (.) buys us three (a;<ESC>). It's a
small saving, but these efficiencies accumulate
when repeated.

But let's take a closer look at this pattern:
j$.. The j command moves the cursor down one line,
and then the $ command moves it to the end of the
line. We've used two keystrokes just to maneuver
our cursor into position so that we can use the
dot command. Do you sense that there's room for
improvement here?

Reduce Extraneous Movement

While the a command appends after the current 
cursor position, the A command appends at the end
of the current line. It doesn't matter where our
cursor is at the time, pressing A will switch to
Insert mode and move the cursor to the end of the
line. In other words, it squashes $a into a single
keystroke. In Two for the Price of One, on page 6,
we see that Vim has a handful of compound commands.

Here is a refinement of our previous example:

Keystrokes     BufferContents
-----------------------------
{start}       |var foo = 1
               var bar = 'a'
               var foobar = foo + bar
-----------------------------
A;<ESC>        var foo = 1|;
               var bar = 'a'
               var foobar = foo + bar
-----------------------------
j              var foo = 1;
               var bar = '|a'
               var foobar = foo + bar
-----------------------------
.              var foo = 1;
               var bar = 'a'|;
               var foobar = foo + bar
-----------------------------
j.             var foo = 1;
               var bar = 'a';
               var foobar = foo + bar|;

By using A instead of $a, we give the dot command
a boost. Instead of having to position the cursor
at the end of the line we want to change, we just
having to make sure it is somewhere (anywhere!) on
that line. Now we can repeat the change on 
consecutive lines just by typing j. as many times
as it takes.

One keystroke to move, another to execute. That's
about as good as it gets! Watch for this pattern
of usage, because we'll see it popping up in a
couple more examples.

Although this formula looks terrific for our short
example, it's not a universal solution. Imagine if
we had to append a semicolon to fifty consecuitive
lines. Pressing j. for each change starts to look
like a lot of work. For an alternative approach,
skip ahead to Tip 30, Run Normal Mode Commands
Across a Range, on page 63.


Two for the Price of One
We could say that the A command compounds two 
actions ($a) into a single keystroke. It's not 
alone in doing this. Many of Vim's single-key 
commands can be seen as a condensed version of two
or more other commands. The table below shows an
approximation of some examples. Can you identify
anything else that they all have in common?

Compound Command    Equivalent in Longhand
------------------------------------------
C                   c$
s                   cl
S                   ^C
I                   ^i
A                   $a
o                   A<CR>
O                   ko

If you catch yourself running ko (or worse, k$a<CR>
), stop! Think about what you're doing. Then 
recognize that you could have used the 0 command
instead.

Did you identify the other property that these 
command share? They all switch from Normal to 
Insert mode. Think about that and how it might 
affect the dot command.


                            Tip 3
Take One Step Back, Then Three Forward

We can pad a single character with two spaces (one
in front, the other behind) by using an idiomatic
Vim solution. At first it might look slightly odd,
but solution has the benefit of being repeatable,
which allows us to complete the task effortlessly.

Suppose that we have a line of code that looks like
this:

the_vim_way/3_concat.js
var foo = "method("+argument1+","+argument2")";

Concatenationg strings in JavaScript never looks
pretty, but we could make this a little easier on
the eye by padding each + sign with spaces to make
it look like this:

var foo = "method(" + argument1 + "," + argument2
            + ")";

Make the Change Repeatable

This idiomatic approach solves the problem:

Keystrokes  BufferContents
{start}    |var foo = "method("+arg
                ument1+","+argument2+")";
f+          var foo = "method("|+arg
                ument1+","+argument2+")";
s_+_<Esc>   var foo = "method(" +| arg
                ument1+","+argument2+")";
;           var foo = "method(" + arg
                ument1|+","+argument2+")";
.           var foo = "method(" + arg
                ument1 +| ","+argument2+")";
;.          var foo = "method(" + arg
                ument1 + "," + argument2+")";
;.          var foo = "method(" + arg
                ument1 + "," + argument2 + ")";

The s command compounds two steps into one: it
deletes the charactar under the cursor and then
enters Insert mode. Having deleted the + sign, we
then type _+_ and leave Insert mode.

One step back and then three steps forward. It's
a strange little dance that might seem unintuitive,
but we get a big win by doing it this way: we can
repeat the change with the dot command; all we
need to do is position our cursor on the next +
symbolm, and the dot command will repeat that 
little dance.


Make the Motion Repeatable

There's another trick in this example. The f{char}
command tells Vim to look ahead for next occurrence
of the specified character and then move the 
cursor directly ti it if a match is found (see :h
f). So when we type f+, our cursor goes straight
to the next + symbol. We'll learn more about the
f{char} command in Tip 50, Find by Character, on
page 120.

Having made our first change, we could jump to the
next occurrence by repeating the f+ command, but
there's a better way. The ; command will repeat
the last search that the f command performed. So
instead of typing f+ four times, we can use that
command once and then follow up by using ; command
three times.


All Together Now

The ; command takes us to our next target, and the
. command repeats the last change, so we can 
complete the changes by typing ;. three times.
Does that look familiar?

Instead of fighting Vim's modal input model, we're
working with it and look how much easier it makes
this particular task.


                        Tip 4
Act, Repeat, Reverse

When facing a repetitive task, we can achive an
optimal editing strategy by making both the motion
and the change repeatable. Vim has a knack for 
this. It remenbers our actions and keeps the most
common ones within close reach so that we can 
easily replay them. In this tip, we'll introduce
each of the actions that Vim can repeat and learn
how to reverse them.

We've seen that the dot command repeats the last
change. Since lots of operations count as a change,
the dot command proves to be versatile. But some
commands can be repeated by other means, For
example, @: can be used to repeat any Ex commands
(as discussed in Tip 31, Repeat the Last Ex 
Command, on page 65). Or we can repeat the last 
:substitute command (which itself happens to be
an Ex command as well) by pressing & (see Tip 93,
Repeat the Previous Substitute Command, on page 229
).

If we know how to repeat our actions without having
to spell them out single time, then we can be more
efficient. First we act; then we repeat.

But when so much can be achieved with so few
keystrokes, we have to watch our step. It's easy
to get trigger-happy. Rapping out j.j.j. again
and again feels a bit like doing a drum roll. What
happens if we accidentally hit the j key twice in
a row? Or worse, the . key?

Whenever Vim makes it easy to repeat an action or
motion, it always provides some way of backing out
in case we accidentally go too far. In the case of
the dot command, we can always hit the u key to 
undo the last change. If we hit the ; key too many
times afrer using the f{char} command, we'll miss
our mark. But we can back up again by pressing ,
key, which repeats the last f{char} search in the
reverse direction (see Tip 50, Find by Character,
on page 120).

It always helps to know where the reverse gear is
in case you accidentally go a step too far. 
Table 1, Repeatable Actions and How to Reverse 
Them, on page 9, summarizes Vim's repeatable 
commands along with their corresponding reverse 
action. In most cases, the undo command is the one
that we reach for. No wonder the u key on my 
keyboard is so worn out!

Intent          Act         Repeat      Reverse
Make a change   {edit}      .           u
Scan line for next character
                f{char}/t{char}
                            ;           ,
Scan line for previous character
                F{char}/T{char}
                            ;           ,
Scan document for next match
                /pattern<CR>
                            n           N
Scan document for previous match
                ?pattern<CR>
                            n           N
Perform substitution
                :s/target/replacement
                            &           u
Execute a sequence of changes
                qx{changes}q
                            @x          u
--------------------
Table 1 --Repeatable Actions and How to Reverse
            Them


                        Tip 5
Find and Replace by Hand

Vim has a :substitute command for find-and-replace
tasks, but with this alternative technique, we'll
change the first occurrence by hand and then find
and replace every other match one by one. The dot
command will save us from labor, but we'll meet
another nifty one-key command that makes jumping
between matches a snap.

In this excerpt, the word "content" appears on
every line:

the_vim_way/1_copy_content.txt
...We're waiting for content befor the site can go
live...
...If you are content with this, let's got ahead
with it...
...We'll launch as soon as we have the content...

Suppose that we want to use the word "copy" (as in
"copywriting") instead of "content." Easy enough,
you might think; we can just use the substitute
command, like this:

:%s/content/copy/g

But wait a minute! If we run this command, then
we're going to create the phrase "If you are 'copy'
with this," which is nonsense!

We've run into this problem because the word 
"content" has two meanings. One is synonymous with
"copy" (and pronounced ^content), the other with
"happy" (pronounced con^tent). Technically, we're
dealing with heteronyms (words that are spelled 
the same but differ in both meaning and 
pronunciation), but that doesn't really matter.
The point is, we have to watch our step.

We can't just blindly replace every occurence of
"content" with "copy". We have to eyeball each one
and answer "yay" or "nay" to the question, should
this occurrence be changed? The substitute command
is up to the task, and we'll find out how in Tip 
90, Eyeball Each Substitution, on page 223. But
right now, we'll explore an alternative solution
that fits with the theme of this chapter.

Be Lazy: Search Without Typing

You might have guessed by now that the dot command
is my favorite single-key Vim trigger. In second
place is the * command. This executes a search for
the word under the cursor at that moment (see :h *)
.

We could search for the word "content" by pulling
up the search prompt and spelling out the word in
full:

/content

Or we could simply place our cursor on the word 
and hit the * key. Consider the following workflow:

KeyStrokes      BufferContents
--------------------------------------------------
{start}         ...We're waiting for content
                    before the site can go live...
                ...If you are |content with this, 
                    let's got ahead with it...
                ...We'll launch as soon as we have
                    the content...
--------------------------------------------------
*               ...We're waiting for _content_
                    before the site can go live...
                ...If you are _content_ with this, 
                    let's got ahead with it...
                ...We'll launch as soon as we have
                    the |_content_...
--------------------------------------------------
cwcopy<Esc>     ...We're waiting for _content_
                    before the site can go live...
                ...If you are _content_ with this, 
                    let's got ahead with it...
                ...We'll launch as soon as we have
                    the cop|y...
--------------------------------------------------
n               ...We're waiting for |_content_
                    before the site can go live...
                ...If you are _content_ with this, 
                    let's got ahead with it...
                ...We'll launch as soon as we have
                    the copy...
--------------------------------------------------
.               ...We're waiting for cop|y
                    before the site can go live...
                ...If you are _content_ with this, 
                    let's got ahead with it...
                ...We'll launch as soon as we have
                    the copy...

We begin with our cursor positioned on the word
"content" and then use the * command to search for
it. Try it for yourself. Two things should happen:
the cursor will jump forward to the next match, 
and all occurrence will be highlighted. If you
don't see any highlighting, try running :set hls
and then refer to Tip 81, Hightlight Search 
Matches, on page 204, for more detailes.

Having executed a search for the word "content",
we can now advance to the next occurrence just by
hitting the n key. In this case, pressing *nn 
would cycle through all matches, taking us back to
where we started.


Make the Change Repeatable

With our cursor positioned at the start of the
word "content", we are poised to change it. This
involves two steps: delete the word "content" and
then typing its replacement. The cw command deletes
to the end of the word and then drops us into 
Insert mode, where we can spell out the word 
"copy". Vim records our keystrokes until we leave
Insert mode, so the full sequence cwcopy<Esc> is
considered to be a single change. Pressing the .
command deletes to the end of the current word and
changes it to "copy".


All Together Now

We're all set! Each time we press the n key, our
cursor advances to the next occurrence of the word
"content". And when we press the . key, it changes
the word under the cursor to "copy".

If we wanted to replace all occurrence, we could
blindly hammer out n.n.n. as many times as it took
to complete all the changes (although in that case,
we might as well have used the :%s/content/copy/g
command). But we need to watch out for false 
matches. So after pressing n, we can examine the
current match and decide if it should be changed
to "copy". If so, we trigger the . command. If not,
we don't. Whatever our decision, we can then move
on to the next occurrence by pressing n again.
Rinse and repeat until done.


                        Tip 6
Meet the Dot Formula

We've considered three simple editing tasks so far.
Even though each problem was different, we found
a solution using the dot command for each one. In
this tip, we'll compare each solution and identify
a common pattern --an optimal editing strategy
that I call the Dot Formula.

Reviewing Three Dot-Command Editing Tasks

In Tip 2, Don't Repeat Yourself, on page4, we 
wanted to append a semicolon at the end of a 
sequence of lines. We changed the first line by
invoking A;<Esc>, which set us up so that we could
use the dot command to repeat the change on each
subsequent line. We could move between lines using
the j command, and the remaining changes could be
completed simply by pressing j. as many times as 
necessary.

In Tip 3, Take One Step Back, Then Three Forward,
on page 6, we wanted to pad each occurrence of the
+ symbol with a space both in front and behind. We
used the f+ command to jump to our target and then
the s command to substitute one character with
three. That set us up so that we could complete the
task by pressing ;. a few times.

In Tip 5, Find and Replace by Hand, on page 9, we
wanted to substitute every occurrence of the word
"content" with the word "copy". We used the * 
command to initiate a search for the target wor
and then ran the cw command to change the first
occurrence. This set us up so that the n key would
take us to the next match and the . key would apply
the same change. We could complete the task simply 
by pressing n. as many times as it took.

The Ideal: One Keystroke to Move, One Keystroke
            to Execute

In all of these examples, using the dot command
repeats the last change. But that's not the only
thing they share. A single keystroke is all that's
required to move the cursor to its next target.

We're using one keystroke to move and one keystroke
to execute. It can't really get any better than
that, can it? It's an ideal solution. We'll see
this editing strategy coming up again and again,
so for the sake of convenience, we'll refer to this
pattern as the Dot Formula.



                    Part I

                    Modes


        Vim provides a modal user interface.
        This means that the result of pressing
        any key on the keyboard may differ
        depending on which mode is active
        and how to switch between Vim's mode.
        In this part of the book, we'll learn
        how each mode works and what it can
        be used for.



                                        CHAPTER 2
                                        Normal Mode

Normal mode is Vim's natural resting state. If this
chapter seems surprisingly short, then that's
because most of this book is about how to use
Normal mode! Here, however, is where cover some
core concepts and general tips.

Other text editors spend most of their time in
something that resembles Insert mode. So to the
Vim newcomer, it can seem strange that Normal mode
is the default. In Tip 7, Pause with Your Brush
Off the Page, on page 16, we'll begin explaining
why this is by drawing an analogy with the 
workpace of a painter.

Many Normal mode commands can be executed with a
count, which causes them to be run multiple times.
In Tip 10, Use Counts to Do Simple Arithmetic, on
page 20, we'll meet a pair of commands that 
increment and decrement numerical values and see
how these commands can be combined with a count to
do simple arithmetic.

Just because you can save keystroke by using a 
count doesn't mean that you should. We'll look at
some examples where it's better simply to repeat
a command than take the time to count how many 
times you want to run it.

Much of the power of Normal mode stems form the
way that operator commands can be combined with
motions. We'll finish by looking at the 
consequeces of this.


                        Tip 7
Pause with Your Brush Off the Page

For those unused to Vim, Normal mode can seem like
an odd default. But experienced Vim users have
difficulty imaging it any other way. This tip uses
an analogy to illustrate the Vim way.

How much time do you reckon artists spend with 
their paint brushes in contact with the canvas?
No doubt it would vary from artist to artist, but
I'd be surprised if it counted for as much as half
of the time painters spend at worl.

Think of all of the things that painters do besides
paint. They study their subject, adjust the 
lighting, and mix paints into new hues. And when it
comes to applying paint to the canvas, who says 
they have to use brushes? A painter might switch
to a palette knife to achieve a different texture
or use a cotton swab to touch up the paint that's
already been applied.

The painter does not rest with a brush on the 
canvas. And so it is with Vim. Normal mode is the
natural resting state. The clue is in the name,
really.

Just as painters spend a fraction of their time
applying paint, programmers spend a fraction of
their time composing code. More time is spent 
thinking, reading, and navigating from one part of
a codebase to another. And when we do want to make
change, who says we have to switch to Insert mode?
We can reformat existing code, duplicate it, move
it around, or delete it. From Normal mode, we have
many tools at our disposal.


                            Tip 8
Chunk Your Undos

In other text editors, invoking the undo command
after typing a few words might revert the last
typed word or character. However, in Vim we can
control the granularity of the undo command.

The u key triggers the undo command, which reverts
the most recent change. A change could be anything
that modifies the text in the docment. That 
includes commands triggered from Normal, Visual,
and Command-Line modes, but a change could also
encompass any text entered (or deleted) in Insert
mode. So we could also say that i{insert some text}
<Esc> constitutes a change.

In nonmodal text editors, triggering the undo 
command after typing a few words could do one of
two things. It could undo the last character that
was typed. Or, more helpfully, it could chunk a
set of characters together so that each undo 
operation removed a word insterad of a character.

In Vim, we can control the granularity of the undo
command. From the moment we enter Insert mode until
we return to Normal mode, everything we typed (or
deleted) counts as a single change. So we can make
the undo command operate on words, sentences, or
paragraphs just by moderating our use of the <Esc>
key.

So how often should you leave Insert mode? It's a
matter of preference, but I like to make each
"undoable chunk" correspond to a thought. As I
write this text (In Vim, of course!), I often 
pause at the end of a sentence to consider what
I'll write next. No matter how brief its duration,
each pause forms a natural break point, giving me
a cue to leave Insert mode. When I'm ready to 
continue writing, I press A and carry on where I
left off.

If I decided that I've taken a wrong turn, I'll
switch to Normal mode and press u. Each time I 
undo, my text decomposes in coherent chunks that
correspond to my thought process as I was writing
the original text. It means that I can easily try
out a sentence or two and then throw them away 
with a couple of keystrokes.

If I'm in Insert mode with my cursor at the end of
a line, the quickest way to open a new line is to
press <CR>. And yet I sometimes prefer to <Esc>o
just because I anticipate that I might want that
extra granularity from the undo command. If this
sounds hard core, don't worry. As you become adept
with Vim, switching modes feels more and more
lightweight.

As a general rule, if you've paused for long enough
to ask the question, "Should I leave Insert mode?"
then do it.

Moving Around in Insert Mode Resets the Change

When I said that the undo command would revert all
characters entered (or deleted) during a trip into
Insert mode and back, I was glossing over a smal
detail. If we use the <Up>, <Down>, <Left>, or
<Right> cursor keys while in Insert mode, a new
undo chunk is created. It's just as though we had
switched back to Normal mode to move around with
the h, j, k, or l commands, except that we don't
have to leave Insert mode. This also has 
implications on the operation of the dot command.


                            Tip 9
Compose Repeatable Changes

Vim is optimized for repetition. In order to
exploit this, we have to be mindful of how we
compose our changes.

In Vim, we always have more than one way of doing
something. In evaluating which way is best, the
most obvious metric is efficiency: which technique
requires the fewest keystrokes (a.k.a VimGolf).
But how should we pick a winner in the event of
a tie?

Suppose that our cursor is positioned on the "h"
at the end of this line of text, and we want to 
delete the word "nigh".

normal_mode/the_end.txt
The end id nigh

Delete Backward

Since our curdor is already at the end of the word,
we might begin by deleting backward.

KeyStrokes      BufferContents
-------------------------------------------------
{start}         The end is nig|h
db              The end is |h
x               The end is|

Pressing db deletes from the cursor's starting
position to the beginning of the word, but it 
leaves the final "h" intact. We can delete this
rogue character by pressing x. That gives us a Vim
golf score of 3.

Delete Forward

This time, let's try deleting forward instead.

Keystrokes      BufferContents
-------------------------------------------------
{start}         The end is nig|h
b               The end is |nigh
dw              The end is|

We have to start by maneuvering our cursor into 
position with the b motion. Once it's in place, we
can excise the word with a single dw command.
once again, our Vim golf score is 3.

Delete an Entire Word

Both of our solutions so far have involved some
kind of preparation or clean-up. We can be more
surgical by using the aw text object instead of a
motion (see :h aw):

Keystrokes      BufferContents
-------------------------------------------------
{start}         The end is nig|h
daw             The end is|

The daw command is easily remembered by the 
mnemonic delete a word. We'll go into more detail
on text object in Tip 52, Trace Your Selection with
Precision Text Objects, on page 126, and Tip 53,
Delete Around, or Change Inside, on page 129.


Tie-Breaker: Which is Most Repeatable?

We've tried three techniques for deleting a word:
dbx, bdw, and daw. In each case, our Vim golf score
is 3. So how can we settle the question of which is
best?

Remember, Vim is optimized for repetition. Let's go
through these techniques again. This time, we'll 
finish by invoking the dot command and see what
happens. I urge you to try these out for yourself.

The backward deletion technique involves two 
operations: db deletes to the start of the word
and then x deletes a single character. If we 
invoke the dot command, it repeats the single
character deletion (. == x). That's not what I
would call a big win.

The forward deletion technique also involves two
steps. This time, b is just a plain motion, while
dw makes a change. The dot command repeats dw, 
deleting from the cursor position to the beginning
to the next word. It so happens that we're already
at the end of the line. There is no "next word", 
so in this context the dot command isn't useful.
But at least it's shorthand for something longer
(. == dw).

The final solution only invokes a single operation:
daw. This technique doesn't just remove the word,
it also deletes a whitespace character. As a 
result, our cursor ends up on the last character
of the word "is". If we invoke the dot command, it
will repeat the instruction to delete a word. This
time, the dot command does something truly useful
(. == daw).


Discussion

The daw technique invests the most power into the
dot command, so I declare it the winner of this
round.

Making effective use of the dot command often 
requires some forethought. If you notice that you
have to make the same small change in a handful of
places, you can attempt to compose your changes in
such a way that they can be repeated with the dot
command. Recognizing those opportunities takes 
practice. But if you develop a habit of making 
your changes repeatale whenever possible, then Vim
will reward you for it.

Sometimes, I won't see an opportunity to use the 
dot command. After making a change --and finding
that I need to perform an identical edit --I 
realize that the dot command is primed and ready
to do the work for me. It makes me grin every time.


                            Tip 10
Use Counts to Do Simple Arithmetic

Most Normal mode commands can be executed with a
count. We can exploit this feature to do simple
arithmetic.

Many of the commands that are available in Normal
mode can be prefixed with a count. Instead of 
executing the command just once, Vim will attempt
to execute the command the specified number of 
times (see :h count).

The <C-a> and <C-x> commands perform addtion and
subtraction on numbers. When run without a count
they increment by one, but if we prefix a number,
then we can add or subtract by any whole number.
For example, if we positioned our cursor on a 5
character, runnning 10<C-a> would modify it to read
15.

But what happens if the cursor is not positioned
on a numeric digit? The documentation says that the
<C-a> command will "add [count] to the number at
or after the cursor" (see :h ctrl-a). So if the
cursor is not already positioned on a number, then
the <C-a> command will look ahead for a digit on
the current line. If it finds one, it jumps 
straight to it. We can use this to our advantage.

Here's a snippet of CSS:

normal_mode/sprite.css
.blog, .news { background-image: url(/sprite.png);}
.blog { background-position: 0px 0px }

We are going to duplicate the last line and make
two small modifications to it: replace the word
"blog" with "news", and change "0px" to "-180px".
We can duplicate the line by running yyp and then
using cW to change the first word. But how should
we deal with number?

One approach would be to jump to the digit with
f0 and then dip into Insert mode to change the
value by hand: i-18<Esc>. But it's quicker just to
run 180<C-x>. Since our cursor isn't on a digit to
begin with, it jumps forward to the first one that
it finds. That saves us the step of moving the
cursor by hand. Let's see this work flow in action:

keystrokes      BufferContent
----------------------------------------------
{start}         .blog, .news { background-image:
                    url(/sprite.png);}
               |.blog { background-position: 
                    0px 0px }
----------------------------------------------
yyp             .blog, .news { background-image:
                    url(/sprite.png);}
                .blog { background-position: 
                    0px 0px }
               |.blog { background-position: 
                    0px 0px }
----------------------------------------------
cW.news<Esc>    .blog, .news { background-image:
                    url(/sprite.png);}
                .blog { background-position: 
                    0px 0px }
                .new|s { background-position: 
                    0px 0px }
----------------------------------------------
180<C-x>        .blog, .news { background-image:
                    url(/sprite.png);}
                .blog { background-position: 
                    0px 0px }
                .new|s { background-position: 
                    -18|0px 0px }

In this example, we've only duplicated the line 
once and made changes. But suppose we had to make
ten copies, subtracting 180 from the number in each
successive copy. If we were to switch to Insert
mode to amend each number, we'd have to type 
something different each time (-180, then -360, and
so on). But by using the 180<C-x> command, our 
work flow is identical for each successive line.
We could even record our key strokes as a macro
(see Chapter 11, Macros, on page 161) and then
play it back as many times as needed.

Number Formats

What follows 007? No, this isn't a James Bond gag:
I'm asking what result would you expect if you 
added one to 007.

If you answered 008, then you might be in for a
surprise when you try using Vim's <C-a> command
on any number with a leading zero. As is the
convention in some programming languages, Vim
interprets numerals with a leading zero to be in
octal notation rather than in decimal. In the octal
numeric system, 007 + 001 = 010, which looks like
the decimal ten but actually an octal eight.
Confused?

If you work with octal numbers frequently, Vim's
default behavior might suit you. If you don't, you
probably want to add the following line to your 
vimrc:

set nrformats=

This will cause Vim to treat all numerals as 
decimal, regardless of whether they are padded with
zeros.


                        Tip 11
Don't Count If You Can Repeat

We can minimize the keystrokes required to perform
certain tasls by providing a count, but that 
doesn't mean that we should. Consoder the pros and
cons of counting versus repeating.

Suppose that we had the following text in our 
buffer:

Delete |more than one word

We want to do as the text says, changing it to 
read "Delete one word" instead. That is to say, 
we're going to delete two words.

We can approach this in a handful of ways. Both 
d2w and 2dw will work. With d2w, we invoke the
delete command and then give 2w as the motion. We
could read that as "delete two words". However, 
2dw turns things around. This time the count 
applies to the delete command. but the motion acts
over a single word. We could read this as "delete
a word two times". Putting semantics aside, we get
the same result either way.

Now let's consider an alternative: dw. . This we
can read as "Delete a word and then repeat."

To recap, our options are as follows: d2w, 2dw, or
dw. --three keystrokes each. But which is best?

For our discussion, d2w and 2dw are identical.
After running either of these, we can press the u
key to undo, and the two words that were deleted
will appear again. Or, instead of undoing our
change, we could repeat it with the dot command, 
which would delete the next two words.

In the case of dw., the result of pressing u or .
is subtly different. Here, the change was dw --
"delete word". So if we wanted to restore the two
words that were deleted, we'd have to undo twice:
pressing uu (or 2u if you prefer). Pressing the
dot command would just delete the next word rather
than the next two.

Now suppose that instead of deleting two words, our
original intent was to delete three words. By a
small error in judgment, we run d2w instead of d3w.

What next? We can't use the dot command, because
that would cause a total of four words to be 
deleted. So we could either back up and revise our
count (ud3w) or continue by deleting the next word
(dw).

If, on the other hand, we had used the command dw.
in the first place, we would have to repeat the
dot command only one more time. Because our 
original change was simply dw, the u and . 
commands have more granularity. Each acts upon one
word at a time.

Now suppose that we want to delete seven word. We
could either run d7w, or dw..... (that is, dw 
followed by the dot command six times). Counting
keystrokes, we have a clear winner. But would you
trust yourself to make the right count?

Counting is tedious. I'd rather hit the dot command
six times than spend the same time looking ahead
in order to reduce the number of keys that I have
to press. What if I hit the dot command one too
many times? No matter, I just back up by hitting
the u key once.

Remember our mantra (from Tip 4 Act, Repeat,
Reverse, on page 8): act, repeat, reverse. Here it
is in action.


Use a Count When It Matters

Suppose that we wanted to change the text "I have
a couple of questions" to instead read "I have some
more questions." We could do so as follows:

Keystrokes        BufferContents
------------------------------------------
{start}           I have |a couple of questions.
c3wsome more<Esc> I have some mor|e questions.

In this scenario, it doesn't make much sense to use
the dot command. We could delete one word and then
another (with the dot command), but then we'd have
to switch gears and change to Insert mode (using
i or cw, for example). To me, that feels awkward
enough that I'd rather go ahead and use a count.

There's another advantage to using a count: it 
gives us a clean and coherent undo history. Having
made this change, we could undo it with a single
press of the u key, which ties in with the 
discussion in Tip 8, Chunk Your Undos, on page 16.

That same argument also goes in favor of counting
(d5w) over repeating (dw....), so my preferences
may seem inconsisent here. You'll develop your own
opinion on this, depending on how much you value 
keeping your undo history clean and whether or not
you find it tiresome to use counts.


			Tip 12
Conbine and Conquer

Much of Vim's power stems from the way that 
operators and motions can be combined. In this tip,
we'll look at how this works and consider the
implications.


Operator + Motion = Action

The d{motion} command can operate on a single
character (dl), a complete word (daw), or an entire
pragraph (dap). Its reach is defined by the motion.
The same goes for c{motion}, y{motion}, and a handful
fo others. Collectively, these commands are called
operators. You can find the complete list by looking
up :h operator, while Table 2, Vim's Operator Commands,
on page 25, summarizes some of the more common ones.

The g~, gu, and gU commands are invoked by two 
keystrokes. In each case, we can consider the g to be
a prefix that modifies the behavior of the subsequent
keystroke. See Meet Operator-Pending Mode, on page 26,
for further discussion.

The combination of operators with motions forms a kind
of grammer. The first rule is simple: an action is
composed  from an operator followed by a motion. 
Learning new motions and operators is like learning
the vocabulary of Vim. If we follow the simple grammer
rules, we can express more ideas as our vocabulary
grows.

Suppose that we already know how to delete a word using
daw, and then we learn about the gU command (see :h gU).
It's an operator too, so we can invoke gUaw to convert
the current word to SHOUTY case. If we then expand our
vocabulary to include the ap motion, which act upon a
paragraph, then we find two new operations at our 
disposal: dap to delete, or gUap to make the whole
paragraph shout.

Vim's grammer has just one more rule: when an operator
command is invoked in duplicate, it acts upon the
current line. So dd deletes the current line, while >>
indents it. The gU command is a special case. We can
make it act upon the current line by running either
gUgU or the shorthand gUU.

Trigger		Effect
------------------------------------------------------
c		Change
d		Delete
y		Yank into register
g~		Swap case
gu		Make lowercase
gU		Make uppercase
>		Shift right
<		Shift left
=		Autoindent
!		Filter {motion} lines through an 
			external program
------------------------------------------------------
Table 2 --Vim's Operator Commands


Extending Vim's Combinatorial Powers

The number of actions that we can perform using Vim's
default set of operators and motions is vast. But we 
can expand these even further by rolling our own custom
motions and operators. Let's consider the implications.


Custom Operators Work with Existing Motions

The standard set of operators that ships with Vim is 
relatively small, but it is possible to define new ones.
Tim Pope's commentary.vim plugin provides a good example.
This adds a command for commenting and uncommenting lines
of code in all languages supported by Vim.

The commentary command is triggered by \\{motion}, which
toggles commenting for the specified lines. It's an
operator command, so we can combine it with all of usual
motions. \\ap will toggle commenting for the current
paragraph. \\G comments from the current line to the end
of the file. \\\ comments the current line.

If you're curious about how to create your own custom
operators, start by reading :h :map-operator.


Custom Motions Work with Existing Operators

Vim's standard set of motions is fairly comprehensive,
but we can augment it further by defining new motions
and text objects.

Kana Natsuno's textobj-entire plugin is a good example.
It adds two new text objects to Vim: ie and ae, which
act upon the entire file.

If we wanted to autoindent the entire file using the
= command, we could run gg=G (that is, gg to jump to 
the top of the file and then =G to autoindent 
everything from the cursor position to the end of the
file). But if we had the textobj-entire plugin installed,
we could simply run =ae. It wouldn't matter where our
cursor was when we ran this command; it would always
act upon the entire file.

Note that if we had both the commentary and textobj-
entire plugings installed, we could use them together.
Running \\ae would toggle commenting throughout the
current file.

If you're curious about how to create your own custom
motions, start by reading :h omap-info.


Meet Operator-Pendign Mode

Normal, Insert, and Visual modes are readily identified,
but Vim has other modes that are easy to overlook.
Operator-Pending mode is a case in point. We use it 
dozens of times daily, but it usually lasts for just a
fraction of a second. For example, we invoke it when we
run the command dw. It lasts during the brief interval
between pressing d and w keys. Blink and you'll miss it!

If we think of Vim as a finite-state machine, then 
Operator-Pending mode is a state that accepts only 
motion commands. It is activated when we invoke an 
operator command, and then nothing happens until we 
provide a motion, which completes the operation. While
Operator-Pending mode is active, we can return to Normal
mode in the usual manner by pressing escape, which 
aborts the operation.

Many commands are invoked by two or more keystrokes
(for examples, look up :h g, :h z, :h ctrl-w, or :h [),
but in most cases, the first keystroke merely acts as a
prefix for the second. These commands don't initiate
Operator-Pending mode. Instead, we can think of them as
namespaces that expand the number of available command
mappings. Only the operator commands initiate Operator-
Pending mode.

Why, you might be wondering, is an entire mode dedicated
to those brief moments between invoking operator and 
motion commands, whereas the namespaced commands are
merely an extension of Normal mode? Good question! 
Because we can create custom mappings that initiate or
target Operator-Pending mode. In other words, it allows
us to create custom operators and motions, which in turn
allows us to expand Vim's vocabulary.


					CHAPTER 3
					Insert Mode

Most of Vim's commands are triggered from other modes,
but some functionality is within easy reach from Insert
mode. In this capter, we'll explore these commands.
Although delete, yank, and put commands are all triggered
from Normal mode, we'll see that there is a convenient
shortcut for pasting text from a register without leaving
Insert mode. We'll learn that Vim provides two easy ways
for inserting unusual characters that are not represented
on the keyboard.

Replace mode is a special case of Insert mode, which 
overwrites existing characters in the document. We'll 
learn how to invoke this and consider some scenarios where
it proves useful. We'll also meet Insert Normal mode, a
submode that lets us fire a single Normal mode command 
before dropping us back into Insert mode.

Autocompletion is the most advanced functionality 
available to us from Insert mode. We'll cover it in depth
in Chapter 19, Dial X for Autocompletion, on page 275.


				Tip 13
Make Corrections Instantly from Insert Mode

If we make a mistake while composing text in Insert mode,
we can fix it immediately. There's no need to change
modes. Besides the backspace key, we can use a couple of
other Insert mode commands to make quick corrections.

Touch typing is more than just not looking at the 
keyboard; it means doing it by feel. When touch typists 
make an error, they know it even before their eyes 
process the information on the screen in front of them.
They feel it in their fingers, like a misplaced step.

When we make a typing error, we can use the backspace
key to erase the mistake and then make a correction.
As long as the error appears near the end of the word,
this may be the quickest strategy for making amends. 
But what if the mistake was at the start of the word?

Expert typists recommend drastic measures: delete the
entire word; then type it out again. If you can type
at a rate above sixty words per minute, retyping a word
from scratch will only take a second. If you can't type 
that fast, consider this to be good practice! There are
particular words that I consistently mistype. Since I
started following this advice, I've become more aware of
which words trip me up. As a result, I now make fewer
mistakes.

Alternatively, you could switch to Normal mode, navigate
to the start of the word, fix the error, then hit A to
return to where you left off in Insert mode. That little
dance could take longer than a second, and it would do
nothing to improve your touch-typing skills. Just because
we can switch modes doesn't mean that we should.

In Insert mode, the backspace key works just as you could
expect: it deletes the character in front of the cursor.
The following chords are also available to us:

Keystrokes	Effect
------------------------------------------------------
<C-h>		Delete back one character (backspace)
<C-w>		Delete back one word
<C-u>		Delete back to start of line

These commands are not unique to Insert mode or even to
Vim. We can also use them in Vim's command line as well
as in the bash shell.


				Tip 14
Get Back to Normal Mode

Insert mode is specialized for one task --entering text
--whereas Normal mode is where we spend most of our time
(as the name suggests). So it's important to be able to
switch quickly between them. This tip demonstrates a
couple of tricks that reduce the friction of mode 
switching.

The classic way of getting back to Normal mode is with
the <Esc> key, but in many keyboards that can seem like
a long reach. Alternatively, we can press <C-[>, which
has exactly the same effect (see :h i_CTRL-[).

Keystrokes	Effect
------------------------------------------------------
<Esc>		Switch to Normal mode
<C-[>		Switch to Normal mode
<C-o>		Switch to Insert Normal mode

Vim novices frequently become fatigued by the constant
need to switch modes, but with practice it starts to
feel more natural. Vim's modal nature can feel awkward
in one particular scenario: when we're in Insert mode
and we want to run only one Normal command and the 
continue where we left off in Insert mode. Vim has a
neat solution to ease the friction caused by switching
modes: Insert Normal mode.


Meet Insert Normal Mode

Insert Normal mode is a special version of Normal mode,
which gives us one bullet. We can fire off a single 
command, after which we'll be returned to Insert mode
immediately. From Insert mode, we can switch to Insert
Normal mode by pressing <C-o> (:h i_CTRL-O).

When the current line is right at the top or bottom of 
the window, I sometimes want to scroll the screen to
see a bit more context. The zz command redraws the
screen with the current line in the middle of the window,
which allows us to read half a screen above and below the
line we're working on. I'll often trigger this from 
Insert Normal mode by tapping out <C-o>zz. That puts me
straight back into Insert mode so that I can continue
typing uninterrupted.


				Tip 15
Paste from a Register Without Leaving Insert Mode

Vim's yank and put operations are usually executed from
Normal mode, but sometimes we might want to paste text
into the document without leaving Insert mode.

Here's and unfinished excerpt of text:

insert_mode/practical-vim.txt
Practical Vim, by Drew Neil
Read Drew Neil's


Remap the Caps Lock Key

For Vim users, the Caps Lock key is a menace. If Caps
Lock is engaged and you try using the k and j keys to
move the cursor around, you'll instead trigger the K
and J commands. Briefly: K looks up the man page for
the word under the cursor (:h K), and J joins the 
current and next lines together (:h J). It's surprising
how quickly you can mangle the text in your buffer by
accidentally enabling the Caps Lock key!

Many Vim users remap the Caps Lock button to make it act
like another key, such as <Esc> or <Ctrl>. On modern
keyboards, the <Esc> key is difficult to reach, whereas
the Caps Lock key is handy. Mapping Caps Lock to behave
as an <Esc> key can save a lot of effort, especially 
since the <Esc> key is so heavily used in Vim. I prefer
to map the Caps Lock button to behave instead as a <Ctrl>
key. The <C-[> mapping is synonymous with <Esc>, and it's
easier to type when the <Ctrl> key is withing easy reach.
Additionally, the <Ctrl> key can be used for many other
mappings, both in Vim and in other programs too.

The simplest way to remap the Caps Lock is to do it at
the system level. The methods differ on OS X, Linux, and
Windows, so rather than reproducing instructions here for
each system, I suggest that you consult Google. Note
that this customization won't just affect Vim: it applies
system-wide. If you take my advice, you'll throw away the
Caps Lock key forever. You won't miss it, I promise.


We want to complete the last line by inserting the title
of this book. Since that text is already present at the
start of the first line, we'll yank it into a register
and then append the text at the end of the next line in
Inesrt mode:

Keystrokes	BufferContents
------------------------------------------------------
yt,	       |Practical Vim, by Drew Neil
		Read Drew Neil's
------------------------------------------------------
jA_		Practical Vim, by Drew Neil
		Read Drew Neil's |
------------------------------------------------------
<C-r>0		Practical Vim, by Drew Neil
		Read Drew Neil's Practical Vim.
------------------------------------------------------
.<Esc>		Practical Vim, by Drew Neil
		Read Drew Neil's Practical Vim.

The command yt, yanks the word Practical Vim into the
yank register (we'll meet the t{char} motion in Tip 49,
on page 114). In Insert mode, we can press <C-r>0 to 
paste the text that we just yanked at the current cursor
position. We'll discuss registers and the yank operation
at greater length in Chaprer 10, Copy and Paste, on page
141.

The general format of the command is <C-r>{register}, 
where {register} is the address of the register we want
to insert (see :h i_CTRL-R).


Use <C-r>{register} for Character-wise Registers

The <C-r>{register} command is convenient for pasting a
few words from Insert mode. If the register contains a lot
of text, you might notice a slight delay before the screen
updates. That's because Vim inserts the text from the 
register as if it were being typed one character at a time.
If the 'textwidth' or 'autoindent' options are enabled, you
might end up with unwanted line breaks or extra 
indentation.

The <C-r><C-p>{register} command is smarter. It inserts
text literally and fixes any unintended indentaion (see 
:h i_CTRL-R_CTRL-P). But it's a bit of a handful! If I 
want to paste a register containing multiple lines of
text, I prefer to switch to Normal mode and use one of
the put command (see Tip 62, on page 151).


				Tip 16
Do Back-of-the-Envelope Calculations in Place

The expression register allows us to perform calculations
and then insert the result directly into our document.
In this tip, we'll see one application for this powerful
feature.

Most of Vim's registers contain text either as a string
of characters or as entire lines of text. The delete and
yank command allows us to set the contents of a resigter,
while the put command allows us to get the contents of a
register by inserting it into the document.

The expression register is different. It can evaluate a
piece of Vim script code and return the result. Here, we
can use it like a calculator. Passing it a simple 
arithmetic expression, such as 1+1, gives a result of 2.
We can use the return value from the expression register
just as though it were a piece of text saved in a plain
old register.

The expression register is addressed by the = symbol.
From Insert mode we can access it by typing <C-r>=. This
opens a prompt at the bottom of the screen where we can
type the expression that we want to evaluate. When done,
we hit <CR>, and Vim inserts the result at our current
position in the document.

Suppose that we've just typed the following:

insert_mode/back-of-envelope.txt
6 chairs, each costing $35, totals $

There's no need to scribble on the back side of an
envelope. Vim can do the math for us, and we don't
have to leave Insert mode. Here's how:

Keystrokes	BufferContents
------------------------------------------------------
A		6 chairs, each costing $35, totals $|
<C-r>=6*35<CR>  6 chairs, each costing $35, totals $210|

The expression register is capable of much more than 
simple arithmetic. We'll meet a slightly more advenced
example in Tip 70, on page 174.


				Tip 17
Insert Unusual Characters by Character Code

Vim can insert any character by its numeric code. This
can be handy for entering symbols that are not found on
the keyboard.

We can tell Vim to insert any arbitrary character if we
know its numeric code. From Insert mode, we just have to
type <C-v>{code}, where {code} is the address of the 
character that we want to insert.

Vim expects the numeric code to consists of three digits.
Suppose, for example, that we wanted to insert an 
uppercase "A" character. The character code is 65, so we
would have to enter is as <C-v>065.

But what if we wanted to insert a character whose numeric
code is longer than three digits? For example, the Unicode
Basic Multilingual Plane has an address space for up to
65,535 characters. It turns out that we can enter all of
these using a four-digit hexadecimal code if we type 
<C-v>u{1234} (note the u pressing the digit this time).
Let's say we wanted to insert an inverted question mark 
symbol ("¿"), which is represented by the character code
00bf. From Insert mode, we would just have to type 
<C-v>u00bf . See :h i_CTRL-V_digit for more details.

If you want to find out the numeric code for any character
in your document, just place the cursor on it and trigger
the ga command. This outputs a message at the bottom of the
screen, revealing the character code in decimal and 
hexadecimal notations (see :h ga). Of course, this is of 
little help if you want to know the code for a character
that is not already present in your document. In that case, 
you might want to look up the unicode tables.

In another scenario, if the <C-v> command is followed by 
any nondigit key, it will insert the character represented
by that key literally. For example, if the 'expandtab' 
option is enabled, then pressing the <Tab> key will insert
space characters instead of a tab character. However, 
pressing <C-v><Tab> will always insert a tab character
literally, regardless of whether 'expandtab' is enabled or 
not.

Table 3, Inserting Unusual Characters, on page 33, 
summarizes the commands for entering unusual characters.

Keystrokes		BufferContents
------------------------------------------------------
<C-v>{123}		Insert character by decimal code
<C-v>u{1234}		Insert character by hexadecimal 
				code
<C-v>{nondigit}		Insert nondigit literally
<C-k>{char1}{char2}	Insert character represented by
				{char1}{char2} digraph
------------------------------------------------------
Table 3 --Inserting Unusual Characters


				Tip 18
Insert Unusual Characters by Digraph

While Vim allows us to insert any character by its
numeric code, these can be hard to remember and awkward
to type. We can also insert unusual characters as 
digraphs: pairs of characters that are easy to remember.

Digraphs are easy to use. From Insert mode, we just type
<C-k>{char1}{char2} . So if we wanted to insert the "¿"
character, which is represented by the digraph ?I, we 
would simply type <C-k>?I . 

The character pairs that make up a digraph are chosen to
be descriptive, making them easier to remember or even
guess. For example, the double-angle quotation marks
« and » are represented by the digraphs << and >>; the
vulgar (or common) fractions ½, ¼, and ¾are
represented by the digraphs 12, 14, and 34, respectively.
The default set of digraphs that ship with Vim follows
certain conventions, which are summarized under 
:h digraph-deault.

We can view a list of the available digraphs by running
:digraphs, but the output of this command is difficult
to digest. A more usable list can be found by looking 
up :h digraph-table .

				
				Tip 19
Overwrite Existing Text with Replace Mode

Replace mode is identical to Insert mode, except that
it overwrites existing text in the document.

Suppose that we had an excerpt of text such as this:

insert_mode/replace.txt
Typing in Insert mode extends the line. But in Replace
mode the line length doesn't change.

Instead of using two separate sentences, we're going to
run this together into single sentence by changing the
period to a comma. We also have to downcase the "B" in 
the word "But". This example shows how we could do this
using Replace mode.

Keystrokes	BufferContents
-----------------------------------------------------
{start}	       |Typing in Insert mode extends the line.
		 But in Replace mode the line length
		 doesn't change.
-----------------------------------------------------
f.		Typing in Insert mode extends the line|.
		 But in Replace mode the line length
		 doesn't change.
-----------------------------------------------------
R,b<Esc>	Typing in Insert mode extends the line,
		 but in Replace mode the line length
		 doesn't change.

From Normal mode, we can engage Replace mode with the
R command. As the example demonstrates, typing ",b"
overwrites the existing ".B" characters. And when we're
finished with Replace mode, we can hit the <Esc> key to
return to Normal mode. Not all keyboards have an <Insert>
key, but if yours does, then you can use it to toggle
between Insert and Replace modes.


Overwrite Tab Characters with Virtual Replace Mode

Some characters can complicate matters for Replace mode.
Consider the tab character. This is represented by a 
single character in the file, but onscreen it expands to
fill several columns, as defined by the 'tabstop' setting
(see :h 'tabstop'). If we placed our cursor on a tab stop
and initiated Replace mode, then the next character we 
typed would overwrite the tab character. Supposing that
the 'tabstop' option was set to 8 (the default), this
would appear to replace eight characters with one, 
causing a drastic reduction in the length of the current
line.

Vim has a second variant of Replace mode. Virtual Replace
mode is triggered with gR and treats the tab character
as though it consisted of spaces. Suppose that we position
the cursor on a tab stop spanning eight columns of screen
real estate. If we switch to Virtual Replace mode, we 
could type up to seven characters, each of which would be
inserted in front of the tab character. Finally, if we
typed an eighth character, it would replace the tab stop.

In Virtual Replace mode, we overwrite characters of 
screen real estate rather than dealing with the actual
characters that would eventually be saved in a file. This
tends to produce fewer surprises, so I would recommend
using Virtual Replace mode whenever possible.

Vim also provides a single-shot version of Replace mode
and Virtual Replace mode. The r{char} and gr{char} 
commands allow us to overwrite a single character before
switching straight back to Normal mode (:h r).


					CHAPTER 4
					Visual Mode

Vim's Visual mode allow us to define a selection of text
and then operate upon it. This should feel pretty 
intuitive, since it is the model that most editing
software follows. But Vim's take is characteristically
different, so we'll start by making sure we grok Visual
mode (Tip 20, on page37).

Vim has three variants of Visual mode involving working
with characters, lines, or rectangular blocks of text.
We'll explore ways of switching between these mode as
well as some useful tricks for modifying the bounds of 
a selection (Tip 21, on page 39).

We'll see that the dot command can be used to repeat
Visual mode commands, but that it's especially effective
when operating on line-wise regions. When working with
character-wise selections, the dot command can sometimes
fall short of our expectations. We'll see that in these
scenarios, operator commands may be preferable.

Visual-Block mode is rather special in that it allows us
to operate on rectangular columns of text. You'll find
many uses for this feature, but we'll focus on three tips
that demonstrate some of its capabilities.


				Tip 20
Grok Visual Mode

Visual mode allows us to select a range of text and then
operate upon it. However intuitive this might seem, Vim's
perspective on selecting text is different from other 
text editors.

Suppose for a minute that we're not working with Vim but
instead filling out a text area on a web page. We've 
written the word "March", but it should read "April", so
using the mouse, we double-click the word to select it.
Having highlighted the word, we could hit the backspace
key to delete it and then type out the correct month as
a replacement.

You probably already know that there's no need to hit the
backspace key in this example. With the word "March" 
selected, we would only have to type the letter "A" and
it would replace the selection, preparing the way so that
we could type out the rest of the word "April". It's not
much, but a keystrokes saved is a keystroke earned.

If you expect this behavior to carry over to Vim's 
Visual mode, you're in for a surprise. The clue is right
there in the name: Visual mode is just another mode, which
means that each key performs a different function.

Many of the commands that you are familiar with from
Normal mode work just the same in Visual mode. We can 
still use h, j, k, and l as cursor keys. We can use
f{char} to jump to a character on the current line and
then repeat or reverse the jump with the ; and , commands,
respectively. We can even use the search command (and n/N
) to jump to pattern matches. Each time we move our 
cursor in Visual mode, we change the bounds of the 
selection.

Some Visual mode commands perform the same basic function
as in Normal mode but with a slight twist. For example, 
the c commands is consistent in both modes in that it
deletes the specified text and then switches to Insert
mode. The difference is in how we specify the range on
which to act. From Normal mode, we trigger the change
command first and then specify the range as a motion.
This, if you'll remember from Tip 12, on page 24, is
called an operator command. Whereas in Visual mode, we
start off by making the selection and then trigger the
change command. This inversion of control can be 
generalized for all operator commands (see Table 2, Vim's
Operator Commands, on page 25). For most people, the 
Visual mode approach feels more intuitive.

Let's revisit the simple example where we wanted to 
change the word "March" to "April". This time, suppose
that we have left the confines of the text area on a web
page and we're comfortably back inside Vim. We place 
our cursor somewhere on the word "March" and run viw to
visually select the word. Now, we can't just type the
word "April" because that would trigger the A command
and append the text "pril"! Instead, we'll use the c
command to change the selection, deleting the word and
dropping us into Insert mode, where we can type out the
word "April" in full. This pattern of usage is similar
to our original example that we use the c key instead
of backspace.


Meet Select Mode

In a typical text editing environment, selected text is
deleted when we type any printable character. Vim's 
Visual mode doesn't follow this convention --but Select
mode does. According to Vim's built-in documentation, 
it "resembles the selection mode in Microsoft Widows"
(see :h Select-mode). Printable characters cause the
selection to be deleted, Vim enters Insert mode, and the
typed character is inserted.

We can toggle between Visual and Select modes by pressing
<C-g>. The only visible difference is the message at the
bottom of screen, which switches between -- VISUAL -- and
-- SELECT --. But if we type any printable character in
Select mode, it will replace the selection and switch to
Insert mode. Of course, from Visual mode you could just
as well use the c key to change the selection.

If you are happy to embrace the modal nature of Vim, then
you should find little use for Select mode, which holds
the hand of users who want to make Vim behave more like
other text editors. I can think of only one place where
I consistently use Select mode: when using a plugin that
emulates TextMate's snippet functionality, Select mode
highlights the active placeholder.


				Tip 21
Difine a Visual Selection

Visual mode's three submodes deal with different kinds
of text. In this tip, we'll look at the ways of enabling
each visual submode, as wekk as how to switch between
them.

Vim has three kinds of Visual mode. In character-wise
Visual mode, we can select anything from a single 
charecter up to a range of characters withing a line or
spanning multiple lines. This is suitable for working
at the level of individual words or phrases. If we want
to operate on entire lines, we can use line-wise Visual
mode instead, Finally, block-wise Visual mode allows us
to work with columnar regions of the document. Block-wise
Visual mode is quite special, so we'll discuss it at
greater length in Tip 24, on page 45, Tip 25, on page 47,
and Tip 26, on page 48.


Enabling Visual Modes

The v key is our gateway into Visual mode. From Visual
mode, we can press v by itself to enable character-wise
Visual mode. Line-wise Visual mode is enabled by pressing
V (with the Shift key), and block-wise Visual mode by 
pressing <C-v> (with the Control key). These commands are
summarized in the following table:

Command	Effect
v	Enable character-wise Visual mode
V	Enable line-wise Visual mode
<C-v>	Enable block-wise Visual mode
gv	Reselect the last visual selection

The gv command is a useful littele shortcut. It reselects
the range of text that was last selected in Visual mode.
No matter whether the previous selection was 
character-wise, line-wise, or block-wise, the gv command
should do the right thing. The only case where it might
get confused is if the last selection has since been
deleted.


Switching Between Visual Modes

We can switch between the different flavors of Visual 
mode in the same way that we enable them form Normal
mode. If we're in character-wise Visual mode, we can
switch to the line-wise variant by pressing V, or to
block-wise Visual mode with <C-v>. But if we were to
press v from character-wise Visual mode, it would
switch us back into Normal mode. So you can think of
the v key as a toggle between Normal mode and 
character-wise Visulal mode. The V and <C-v> keys also
toggle between Normal mode and their respective flavors
of Visual mode. Of course, you can always switch back
to Normal mode by pressing <Esc> or <C-[> (just like
getting out of Insert mode). This table summarizes the
commands for switching between Visual modes:

Command	Effect
---------------------------------------------------------
<Esc> / Switch to Normal mode
<C-[>
---------------------------------------------------------
v / V / Switch to Normal mode (when used form character-,
<C-v>	 line-, or block-wise Visual mode, respectively)
---------------------------------------------------------
v	Switch to character-wise Visual mode
---------------------------------------------------------
V	Switch to line-wise Visual mode
---------------------------------------------------------
<C-v>	Switch to block-wise Visual mode
---------------------------------------------------------
o	Go to other end of highlighted text


Toggling the Free End of a Selection

The range of a  Visual mode selection is marked by two
ends: one end is fixed and the other moves freely with
our cursor. We can use the o key to toggle the free 
end. This is really handy if halfway through defining
a section we realize that we started the wrong place.
Rather than leaving Visual mode and starting afresh, 
we can just hit o and redefine the bounds of the 
selection. The following demonstrates how we can use
this technique:

Keystrokes	BufferContents
---------------------------------------------------------
{start}		Select from here to |here.
---------------------------------------------------------
vbb		Select from |_here to h_ere.
---------------------------------------------------------
o 		Select from  _here to |_here.
---------------------------------------------------------
e		Select from _here to her|e_.


				Tip 22
Repeat Line-Wise Visual Commands

When we use the dot command to repeat a change made to a
visual selection, it repeats the change on the same range
of text. In this tip, we'll make a change to a line-wise 
selection and then repeat it with the dot command.

When we execute a command from Visual mode, we are dropped
back into Normal mode and the range of text that was 
marked out in Visual mode is unselected. So what should 
we do if we want to perform another Visual mode command
on the same range of text?

Suppose that we had the following excerpt of malformatted
Python:

visual_mode/fibonacci-malformed.py
def fib(n):
    a, b = 0, 1
    while a < n:
print a,
a, b = b, a + b
fib(42)

This code sample uses four spaces per indentation. First,
we'll have to configure Vim to match this style.


Preparation

To make the < and > commands work properly, we should set
the 'shiftwidth' and 'softtabstop' settings to 4 and 
enable 'expandtab'. If you want to understand how these
settings work together, check out the "Tabs and Spaces"
episode on Vimcasts.org This one-liner does the trick:

:set shiftwidth=4 softtabstop=4 expandtab


Indent Once, Then Repeat

In our malformed Python excerpt, the two lines below the
while keyword should be indented further by two levels.
We could fix it by visually selecting the text and 
triggering the > command to indent it. But that would
only increase the indentation by one level before 
dropping us back into Normal mode.

One solution would be to reselect the same text using
the gv command and then invoke the indentation command
again. But if you're getting a feel for the Vim way, 
then this should raise alarm bells for you.

When we need to repeat ourselves, the dot command is
our friend. Rather than reselecting the same range of
the text and repeating the same command manually, we
can just hit the . key form Normal mode. Here it is in
action:

Keystrokes  BufferContents
------------------------------------------------------
{start}     def fib(n):
                a, b = 0, 1
                while a < n:
           |print a,
            a, b = b, a+b
            fib(42)
------------------------------------------------------
Vj          def fib(n):
                a, b = 0, 1
                while a < n:
           _print a,
           |a, b = b, a+b_
            fib(42)
------------------------------------------------------
>.          def fib(n):
                a, b = 0, 1
                while a < n:
                   |print a,
                    a, b = b, a+b


If you're good at counting, you might prefer to hit the
target in a single blow by running 2> from Visual mode.
I prefer using the dot command because it gives me 
instant visual feedback. If I need to trigger the 
indentation command again, I just hit . another time. Or
if I get trigger-happy and overshoot my mark, I press the
u key to bring it back in line. Tip 11, on page 22, 
discusses the difference in a little more detail.

When we use the dot command to repeat a Visual mode 
command, it acts on the same amount of text as was marked
by the most recent visual selection. This behavior tends
to work in our favor when we make line-wise visual 
selections, but it can have surprising results with
character-wise selections. Next, we'll look at an example
that illustrates this.


                            Tip 23
Prefer Operators to Visual Commands Where Possible

Visual mode may be more intuitive than Vim's Normal mode
of operation, but it has a weakness: it doesn't always
play well with the dot command. We can route around this
weakness by using Normal mode operators when appropriate.

Suppose that we want to transform the following list of
links to make them shout:

visula_mode/list-of-links.html
<a href="#">one</a>
<a href="#">two</a>
<a href="#">three</a>

We can select the inner contents of a tag by running vit,
which can be read as visually select inside the tag. The
it command is a special kind of motion called a text
object, which we'll cover in detail in Tip 51, on page
120.


Using a Visual Operator

In Visual mode, we make a selection and then act on it.
In this case, we could use the U command which converts
the selected charecters to uppercase (:h v_U). See 
Table 4, Uppercasing in Visual Mode, on page 44.

Having transformed the first line, we now want to 
perform the same change on the next two lines. How about
we try using the Dot Formula?

Keystrokes  BufferContents  
------------------------------------------------------
{start}    |<a href="#">one</a>
            <a href="#">two</a>
            <a href="#">three</a>
------------------------------------------------------
vit         <a href="#">_on|e_</a>
            <a href="#">two</a>
            <a href="#">three</a>
------------------------------------------------------
U           <a href="#">|ONE</a>
            <a href="#">two</a>
            <a href="#">three</a>
------------------------------------------------------
Table 4 --Uppercasing in Visual Mode

Running j. advances our cursor to the next line and then
repeats the last change. It works fine on line two, but
if we try it again we end up with this strange-looking
result:

<a href="#">ONE</a>
<a href="#">TWO</a>
<a href="#">THRee</a>

Do you see what's happened? When a Visual mode command
is repeated, it affects the same range of text (see :h
visual-repeat). In this case, the original command 
affected a word consisting of three letters. This works
fine for line two, which happens to also contain a 
three-letter word, but it falls short when we try to 
repeat the command on a word containing five letters.


Using a Normal Operator

The Visual mode U command has a Normal mode equivalent:
gU{motion} (:h gU). If we use this to make the first
change, we can complete the subsequent edits using the 
Dot Formula as shown in Table 5, Normal Operator in 
Visual Mode, on page 45.


Discussion

Both of these techniques require only four keystrokes:
vitU versus gUit, but the underlying semantics are
quite different. In the Visual mode approach, the four
keystrokes can be considered as two separate commands:
vit to make a selection and U to transform the selection.
In contrast, gUit can be considered as a single command
comprised of an operator (gU) and a motion (it).

If we want to set up the dot command so that it repeats
something useful, then we're better off staying out of
Visual mode. As a general rule, we should

Keystrokes  BufferContents
------------------------------------------------------
{start}    |<a href="#">one</a>
            <a href="#">two</a>
            <a href="#">three</a>
------------------------------------------------------
gUit        <a href="#">|ONE</a>
            <a href="#">two</a>
            <a href="#">three</a>
------------------------------------------------------
j.          <a href="#">ONE</a>
            <a href="#">|TWO</a>
            <a href="#">three</a>
------------------------------------------------------
j.          <a href="#">ONE</a>
            <a href="#">TWO</a>
            <a href="#">THREE</a>
------------------------------------------------------
Table 5 --Normal Operator in Visual Mode


prefer operator commands over their Visual mode 
equivalents when working through a repetitive set of
changes.

That's not to say that Visual mode is out of bounds.
It still has a place. Not every editing task needs to 
be repeated, so Visual mode is perfectly adequate for
one-off changes. And even though Vim's motions allow 
for surgical precision, sometimes we need to modify a
range of text whose structure is difficult to trace.
In these cases, Visual mode is the right tool for the
job.


                        Tip 24
Edit Tabular Data with Visual-Block Mode

We can work with rows of text in any editor, but 
manipulating columns of text requires a more specialized
tool. Vim provides this capability in the form of its
Visual-Block mode, which we'll use to transform a 
plain-text table.

Suppose that we have a plain-text table such as this one:

visual_mode/chapter-table.txt
Chapter         Page
Normal mode       15
Insert mode       31
Visual mode       44

We want to draw a vertical line out of pipe characters to
separate the two columns of text and make it look more
like a table. But first, we'll reduce the spacing between
the two columns, which are farther apart than they need
to be. We can make both these changes using Visual-Block
mode. See how in Table 6, Adding vertical pipes between
columns, on page 46.

Keystrokes  BufferContents  
------------------------------------------------------
{start}     Chapter       | Page
            Normal mode       15
            Insert mode       31
            Visual mode       44
------------------------------------------------------
<C-v>3j     Chapter      _  Page
            Normal mode  _    15
            Insert mode  _    31
            Visual mode  |    44
------------------------------------------------------
x...        Chapter      |  Page
            Normal mode       15
            Insert mode       31
            Visual mode       44
------------------------------------------------------
gv          Chapter      _  Page 
            Normal mode  _    15 
            Insert mode  _    31 
            Visual mode  |    44 
------------------------------------------------------
r|          Chapter     ||  Page
            Normal mode  |    15
            Insert mode  |    31
            Visual mode  |    44
------------------------------------------------------
yyp         Chapter      |  Page
           |Chapter      |  Page
            Normal mode  |    15
            Insert mode  |    31
            Visual mode  |    44
------------------------------------------------------
Vr-         Chapter      |  Page
            ---------------------
            Normal mode  |    15
            Insert mode  |    31
            Visual mode  |    44
------------------------------------------------------
Table 6 --Adding vertical pipes between columns


To begin, we use <C-v> to engage Visual-Block mode;
then we define the column selection by moving our 
cursor down several lines. Pressing the x key deletes
that column, and the dot command repeats the deletion
for the same range of text. We repeat until the two
columns are about the right distance apart.

Instead of using the dot command, we could have 
expanded our column selection into a box by moving
the cursor two or three steps to the right. Then we
would have to make only a single deletion. I prefer
the instant visual feedback that we get when we delete
a single column and repeat it.

Now that we've lined up the two columns of text where
we want them, we're ready to draw a line between them.
We can reselect our last visual selection using the gv
command and then press r| to replace each character in
the selection with a pipe character.

While we're at it, we may as well draw a horizontal line
to separate the table headers from the rows beneath. We
do a quick line-wise yank-and-put to duplicate the top
line (yyp) and then replace every character in that line
with a dash character (Vr-).


                            Tip 25
Change Columns of Text

We can use Visual-Block mode to insert text into 
several lines of text simultaneously. Visual-Block mode
is not just useful to us when working with tabular data.
Oftentimes, we can benefit from this feature when 
working with code. For example, take this snippet of 
(suboptimal) CSS:

visual_mode/sprite.css
li.one      a{ background-image: url('/images/sprite.png'); }
li.two      a{ background-image: url('/images/sprite.png'); }
li.three    a{ background-image: url('/images/sprite.png'); }

Suppose that the sprite.png file has been moved from images/
into a components/ directory. We'll need to change each of
these lines to reference the file's new location. We could
do this using Visual-Block mode as shown in Table 7, 
Inserting into Multiple Lines, on page 48.

The procedure should look pretty familiar. We begin by
defining the selection that we want to operate on, 
which happens to be a rectangular Visual-Block. When we
hit the c key, all of the selected text disappears and
we are dropped into Insert mode.

As we type the word "components" in Insert mode, it 
appears on the topmost line only. Nothing happens to 
the two lines below. We see the text that we typed in
those lines only when we press <Esc> to return to 
Normal mode.

The behavior of Vim's Visual-Block change command may
be a little surprising. It seems inconsistent that
the deletion shoud affect all marked lines 
simultaneously, but the insertion affects only the
topmost line (at least for the duration of Insert mode
). Some text editors provide similar functionality,
but they update all selected lines at the same time.
If you're used to that kind of behavior (as I was),
then you might find Vim's implementation less polished.

Keystrokes      BufferContents
------------------------------------------------------
{start}         li.one   a{ background-image:
                    url('/|images/sprite.png'); }
                li.two   a{ background-image: 
                    url('/images/sprite.png'); }
Normal mode     li.three a{ background-image: 
                    url('/images/sprite.png'); }
------------------------------------------------------
<C-v>jje        li.one   a{ background-image:
                    url('/_images_/sprite.png'); }
                li.two   a{ background-image: 
                    url('/_images_/sprite.png'); }
Visual mode     li.three a{ background-image: 
                    url('/_image|s_/sprite.png'); }
------------------------------------------------------
c               li.one   a{ background-image:
                    url('/|/sprite.png'); }
                li.two   a{ background-image: 
                    url('//sprite.png'); }
Insert mode     li.three a{ background-image: 
                    url('//sprite.png'); }
------------------------------------------------------
components      li.one   a{ background-image:
                    url('/components|/sprite.png'); }
                li.two   a{ background-image: 
                    url('//sprite.png'); }
Insert mode     li.three a{ background-image: 
                    url('//sprite.png'); }
------------------------------------------------------
<Esc>           li.one   a{ background-image:
                    url('/component|s/sprite.png'); }
                li.two   a{ background-image: 
                    url('/components/sprite.png'); }
Normal mode     li.three a{ background-image: 
                    url('/components/sprite.png'); }
------------------------------------------------------
Table 7 --Inserting into Multiple Lines


But in practice, it makes no difference in the final
outcome. So long as you dip into Insert mode only for
short bursts, you shouldn't have any surprises.


                            Tip 26
Append After a Ragged Visual Block

Visual-Block mode is great for operating on 
rectangular chunk of code such as lines and columns,
but it's not confined to rectangular regions of text.

We've already met this snippet of JavaScript:

the_vim_way/2_foo_bar.js
var foo = 1
var bar = 'a'
var foobar = foo + bar

Three consecuitive lines, each of different length.
We want to append a semicolon at the end of each.
In Tip 2, on page 4, we solved this problem using the
dot command, but we could just as well use Visual-
Block mode. Table8, Appending a Semicolon to Multiple
Lines in Visual-Block Mode, on page 49 shows how.

After engaging Visual-Block mode, we extend our
selection to the end of each line by pressing $. At
first glance, one might expect this to cause difficulty
because each line is a different length. But in this
context, Vim understands

Keystrokes    BufferContents
------------------------------------------------------
{start}       var foo = |1
              var bar = 'a'
Normal mode   var foobar = foo + bar
------------------------------------------------------
<C-v>jj$      var foo = _1_
              var bar = _'a'_
Visual-Block  var foobar_ = foo + ba|r_
------------------------------------------------------
A;            var foo = 1;|
              var bar = 'a'
Insert mode   var foobar = foo + bar
------------------------------------------------------
<Esc>         var foo = |1;
              var bar = 'a';
Normal mode   var foobar = foo + bar;
------------------------------------------------------
Table 8 --Appending a Semicolon to Multiple Lines in
            Visual-Block Mode

that we want to extend our selection to the end of all
selected lines. This lets us break free from our 
rectangular constraints, creating a selection that
traces the ragged right edge of our text.

Having defined our selection, we can append at the end
of each line using the A command (see Vim's Conventions
for "i" and "a" Keys, on page 49). This drops us into
Insert mode on the topmost line of our selection.
Anything that we type will appear on this line only
for the duration of Insert mode, but as soon as we 
revert to Normal mode, our changes are propagated 
across the rest of the lines that we selected.


Vim's Conventions for "i" and "a" Keys

Vim has a couple of conventions for switching from
Normal to Insert mode. The i and a commands both do it,
positioning the cursor in front of or after the current
character, respectively. The I and A commands behave
similarly, except that they position the cursor at the
start or end of the current line.

Vim follows similar conventions for switching from
Visual-Block to Insert mode. The I and A commands both
do it, placing the cursor at the start or end of the
selection, respectively. So what about the i and a
commands; what do they do in Visual mode?

In Visual and Operator-Pending modes the i and a keys
follows a different convention: they form the first
half of a text object. These are covered in greater
depth in Tip 51, on page 120. If you've made a selection
with Visual-Block mode and you wonder why you're not 
Insert mode after pressing i, try using I instead.


In the beginning, there was ed. ed begat ex, and
ex begat vi, and vi begat Vim.
	The Old Testament of Unix

					CHAPTER 5
				Command-Line Mode

Vim traces its ancestry back to vi, which is where
the modal editing paradigm was cnceived. In turn, 
vi traces its ancestry back to a line editor called
ex, which is why we have Ex commands. The DNA of 
these early Unix text editors is preserved in modern
Vim. For some line-oriented tasks, Ex commands are
still the best tool for the job. In this chapter, 
we'll learn how to use Command-Line mode, which 
exposes us to the vestiges of ex.


				Tip 27
Meet Vim's Command Line

Command-Line mode prompts us to enter an Ex command,
a search pattern, or an expression. In this tip, we'll
meet a selection of Ex commands that operate on the
text in a buffer, and we'll learn about some of the
specilal key mappings that can be used in this mode.

We can press the : key, Vim switches into Command-Line
mode. This mode has some resemblance to the command 
line that we use in the shell. We can type the name
of a command and then execute it by pressing <CR>.
At any time, we can switch from Command-Line mode
back to Normal mode by pressing <Esc>.

For historical reasons, the commands that we execute
from Command-Line mode are called Ex command (see
On the Etymology of Vim (and Family), on page 53).
Command-Line mode is also enabled when we press /
to bring up a search prompt or <C-r>= to access the
expression register (see Tip 16, on page 31). Some
of the tricks in this chapter are applicable with
each of these different prompts, but for the most
part we'll focus on Ex commands.

Command			Effect
------------------------------------------------------
:[range]delete[x]	Delete specified lines [into
			  register x]
------------------------------------------------------
:[range]yank[x]		Yank specified lines [into 
			  register x]
------------------------------------------------------
:[line]put[x]		Put the text from register x
			  after the specified line
------------------------------------------------------
:[range]copy{address}	Copy the specified lines to
			  below the line specified
			    by {address}
------------------------------------------------------
:[range]move{address}	Move the specified lines to
			  below the line specified
			    by {address}
------------------------------------------------------
:[range]join		Join the specified lines
------------------------------------------------------
:[range]normal		Execute Normal mode {commands}
  {commands}		  on each specified line
------------------------------------------------------
:[range]substitute/	Replace occurrence of {pattern}
  {pattern}/{string}	  with {string} on each specified
    /[flags]		    line
------------------------------------------------------
:[range]global/		Execute the Ex command [cmd]
  {pattern}/[cmd]	  on all specified lines where
			    the {pattern} matches
------------------------------------------------------
Table 9 --Ex Commands That Operate on the Text 
		in a Buffer

We can use Ex commands to read and write files (:edit
and :write), to create tabs (:tabnew) or split windows
(:split), or to interact with the argument list (:prev
/ :next) or the buffer list (:bprev / :bnext). In fact,
Vim has an Ex command for just about everything (see
:h ex-cmd-index for the full list).

In this chapter, we'll focus mainly on the handful of
Ex commands we can use to edit text. Table 9, Ex 
Commands That Operate on the Text in a Buffer, on page
52, shows a selection of some of the most useful ones.

Most of these commands can accept a range. We'll find
out what this means in Tip 28, on page 54. The :copy
command is great for quickly duplicating a line, as
we'll see in Duplicate Lines with the :t Command, on
page 59. The :normal command provides a convenient way
to make the same change on a range of lines, as we'll
see in Tip 30, on page 61.

We'll learn more about :delete, :yank, and :put commands
in Chapter 10, Copy and Paste, on page 141. The 
:substitute and :global commands are very powerful, so
they each get a chapter of their own. See Chapter 14, 
Substitution, on page 215, and Chapter 15, Global
Commands, on page 237.


Special Keys in Vim's Command-Line Mode

Command-Line mode is similar to Insert mode in that
most of the buttons on the keyboard simply enter a
character. In Insert mode, the text goes into

On the Etymology of Vim (and Family)

ed was the original Unix text editor. It was written
at a time when video displays were uncommon. Source
code was usually printed on to a roll of paper and
edited on a teletype terminal. Commands entered at the
terminal would be sent to a mainframe computer for
processing, and the output from each command would be
printed. In those days, the connection between a 
terminal and a mainframe was slow, so much so that a
quick typist could outpace the network, entering
commands faster than they could be sent for processing.
In this context, it was vital that ed provide a terse
syntax. Consider how p prints the current line, while
%p ptints the entire file.

ed went through several generations of improvements,
including em (dubbed the "editor for mortals"), en,
and eventually ex. By this time, video displays were
more common. ex added a feature that turned the
terminal screen into an interactive window that showed
the contents of a file. Now it was possible to see
change as they were made in real time. The screen-
editing mode was activated by entering the :visual
command, or just :vi for short. And that is where the
name vi comes form.

Vim stands for vi improved. That's an understatement
--I can't stand to use regular vi! Look up :h vi-
differences for a list of Vim features that are 
unavailable in vi. Vim's enhancements are essential,
but it still owes much to its heritage. The constraints
that guided the design of Vim's ancestors have endowed
us with a highly efficient command set that's still
valuable today.


a buffer, whereas in Command-Line mode the text
appears at the prompt. In both of these modes, we can
use control key chords to trigger commands.

Some of these commands are shared between Insert mode
and Command-Line mode. For example, <C-w> and <C-u>
delete backward to the start of the previous word or
to the start of the line, respectively. We can use
<C-v> or <C-k> to insert characters that are not found
on the keyboard. And we can insert the contents of any
register at the command line using the <C-r>{register}
command, just as we saw in Tip 15, on page 29. Some
Command-Line mode mappings are not found in Insert 
mode. We'll meet a few of these in Tip 33, on page 66.

At the command-line prompt, we are limited in the renge
of motions that we can use. The <left> and <right> arrow
keys move our cursor one character at a time in either
direction. Compared to the rich set if motions that 
we're used to using in Normal mode, this can feel quite
limiting. But as we'll see in Tip 34, on page 68, Vim's
command-line window provides all of the editing power
that we could want for composing complex commands at 
the prompt.


Ex Commands Strike Far and Wide

It can sometimes be quicker to use an Ex command than
to get the same job done with Vim's Normal commands.
For example, Normal commands tend to act on the current
character or the current line, whereas an Ex command
can be executed anywhere. This means that we can use
Ex commands to make change without having to move our
cursor. But the greatest feature that distinguishes
Ex commands is their ability to be executed across
many lines at the same time.

As a general rule, we could say that Ex commands are 
long range and have the capacity to modify many lines
in a single move. Or to condense that even further:
Ex commands strike far and wide.


				Tip 28
Execute a Command on One or More Consective Lines

Many Ex commands can be given a [range] of lines to
act upon. We can specify the start and end of a range
with either a line number, a mark, or a pattern.

One of the strengths of Ex commands is that they can 
be executed across a range of lines. We'll use this
short excerpt of HTML as an example:

ex_mode/practical-vim.html
<!DOCTYPE html>
<html>
  <head><title>Practical Vim</title></head>
  <body><h1>Practical Vim</h1></body>
</html>

To demonstrare, we'll use the :print command, which
simply echoes the specified lines below Vim's command
line. This command doesn't perform any useful work, 
but it helps to illustrate which lines make up a range.
Try replacing :print in each of the following examples
with a command such as :delete, :join, :substitute, or
:nomal, and you should get a feel for how useful Ex
commands can be.


Use Line Number as an Address

If we enter an Ex command consisting only of a number,
then Vim will interpret that as an address and move
our cursor to the specified line. We can jump to the
top of the file by running the following:

> :1
> :p
< 1 <!DOCTYPE html>

This file contains only five lines. If we wanted to
jump to the end of the file, we could enter :5 or we
could use the special $ symbol:

> :$
> :p
< 5 </html>

Here we've used :p, which is the abbreviated form of
:print. Instead of splitting up the two commands, we
could roll them into a single incantation:

> :3p
< 3 <head><title>Practical Vim</title></head>

That moves the cursor to line 3 and then echoes the
contents of that line. Remember, we're just using the
:p command for illustrative purpose here. If we had 
issued the command :3d, then we would have jumped to
line 3 and deleted it in a single move. The equivalent
Normal mode commands would be 3G followed by dd. So 
this is one example where an Ex command can be quicker
than a Normal mode command.


Specify a Range of Lines by Address

So far, we've specified adresses as a single line 
number. But we can also specify a range of lines.
Here's an example:

> :2,5p
< 2 <html>
  3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>
  5 </html>

That prints each line from 2 to 5, inclusive. Note
that after running this command, the cursor would
be left positioned on line 5. In general, we could
say that a range takes this form:

:{start},{end}

Note that both the {start} and {end} are addresses.
So far, we've looked at using line numbers for 
addresses, but we'll soon see that using a pattern
or a mark is also possible.

We can use the . symbol as an address to represent
the current line. So, we can easily compose a range
representing everything from here to the end of the
file:

> :2
> :.,$p
< 2 <html>
  3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>
  5 </html>

The % symbol also has a special meaning --it stands
for all the lines in the current file:

> :%p
< 1 <!DOCTYPE html>
  2 <html>
  3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>
  5 </html>

This is equivalent to running :1,$p . Using this
shorthand in combination with the :substitute command
is very common:

> :%s/Practical/Pragmatic/

This command tells Vim to replace the first occurrence
of "Practical" with "Pragmatic" on each line. We'll
learn more about this command in Chapter 14, 
Substitution, on page 215.


Specify a Range of Lines by Visual Selection

Instead of addressing a range of lines by number, we
could just make a visual selection. If we ran the
command 2G followed by VG, we would make a visual
selection that looks like this:

<!DOCTYPE html>
_<html>_
 _ <head><title>Practical Vim</title></head>_
 _ <body><h1>Practical Vim</h1></body>_
_</html>_

If we press the : key now, the command-line prompt
will be prepopulated with the range :'<,'>. It looks
cryptic, but you can think of it simply as a range
standing for the visual selection. Then we can 
specify our Ex command, and it will execute on every
selected line:

> :'<,'>p
< 2 <html>
  3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>
  5 </html>

This range can be really handy if we want to run a
:substitute command on a subset of the file.

The '< symbol is a mark standing for the first line
of the visual selection, while '> stands for the last
line of the visual selection (see Tip 53, on page 126,
for more about marks). These markes persist even we
leave Visual mode. If you try running :'<,'>p straight
from Normal mode, it will always act on the lines that
most recently formed a Visual mode selection.


Specify a Range of Lines by Patterns

Vim also accepts a pattern as an address for an Ex
command, such as the one shown here:

> :/<html>/,/<\/html>/p
< 2 <html>
  3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>
  5 </html>

This looks quite complex, but it follows the usual
form for a range: :{start},{end}. The {start} address
in this case is the pattern /<html>/, while the {end}
address is /<\/html>/. In other words, the range begins
on the line containing an opening <html> tag and ends
on the line containing the corresponding closing tag.

In this particular case, we could achieve the same
result using the address :2,5, which is shorter but
more brittle. If we use patterns to specify the range,
then our command will always operate on the entire
<html></html> element, no matter how many lines it
comprises.


Modify an Address Using an Offset

Suppose that we wanted to run an Ex command on every
line inside the <html></html> block but not on the
lines that contain the <html> and </html> tags 
themselves. We could do so using an offset:

> :/<html>/+1,/<\/html>/-1p
< 3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>

The general form for an offset goes like this:

:{address}+n

If n is omitted, it defaults to 1. The {address}
could be a line number, a mark, or a pattern.

Suppose that we wanted to execute a command on a
particular number of lines, starting with the current
line. We could use an offset relative to the current
line:

> :2
> :.,.+3p

The . symbol stands for the current line, so :.,.+3 
is equivalent to :2,5 in this case.


Discussion

The syntax for defining a range is very flexible.
We can mix and match line numbers, marks, and patterns,
and we can apply an offset to any of them. This table
summarizes a few of the symbols that can be used to
create addresses and ranges for Ex commands:

Symbol	Address
------------------------------------------------------
1	First line of the file
$	Last line of the file
0 	Virtual line above first line of the file
.	Line where the cursor is placed
'm	Line containing mark m
'<	Start of visual selection
'>	End of visual selection
%	The entire file (shorthand for :1,$)

Line 0 doesn't really exist, but it can be useful as
an address in certain contexts. In particular, it can
be used as the final argument in the :copy{address}
and :move{address} commands when we want to copy or
move a range of lines to the top of a file. We'll see
examples of these commands in the next two tips.

When we specify a [range], it always represents a set
of contiguous lines. It's also possible to execute an
Ex command on a set of noncontiguous line using the
:global command. We'll learn more about that in Chapter
15, Global Commands, on page 237.

		
				Tip 29
Duplicate or Move Lines Using ':t' and ':m' Commands

The :copy commands (and its shorthand :t) lets us 
duplicate one or more lines from one part of the 
document to another, while the :move command lets us
place them somewhere else in the document.

For demonstration purposes, we'll use this shopping
list:

ex_mode/shopping-list.todo
Shopping list
	Hardware Store
	    Buy new hammer
	Beauty Parlor
	    Buy nail polish remover
	    Buy nails


Duplicate Lines with the 't' Command

Our shopping list is incomplete: we also need to buy
nails at the hardware store. To fix the list, we'll
reuse the last line of the file, creating a copy of
it below "Hardware Store". We can easily do so using
the :copy Ex command:

Keystrokes	BufferContents
------------------------------------------------------
{start}		Shopping list
                       |Hardware Store
                	    Buy new hammer
                	Beauty Parlor
                	    Buy nail polish remover
                	    Buy nails
------------------------------------------------------
:6copy.		Shopping list
                        Hardware Store
                	   |Buy nails
                	    Buy new hammer
                	Beauty Parlor
                	    Buy nail polish remover
                	    Buy nails


The format of the copy command goes like this (see
:h :copy):

:[range]copy {address}

In our example, the [range] was line 6. For our 
{address}, we use the . symbol, which stands for the
current line. So we can read the :6copy. command as
"Make a copy of line 6 and put it below the current
line".

We could shorten the :copy command to only two letters,
as :co. Or we can be even more succinct by using the 
:t command, which is a synonym for :copy . As a
mnemonic, you can think of it as copy TO. This table
shows a few examples of the :t command in action:

Command	  Effect
------------------------------------------------------
:6t.	  Copy line 6 to just below the current line
:t6	  Copy the current line to just below line 6
:t.	  Duplicate the current line (similar to 
	   Normal mode yyp)
:t$	  Copy the current line to the end of the file
:'<,'>t0  Copy the visually selected lines to the 
	   start of the file

Note that :t. duplicates the current line. Alternatively,
we could achieve the same effect using Normal mode yank
and put commands (yyp). The one notable difference
between these two techniques for duplicating the current
line is that yyp uses a register, whereas :t. doesn't.
I'll sometimes use :t. to duplicate a line when I don't
want to overwrite the current value int the default
register.

In this example, we could have used a variant yyp to
duplicate the line we wanted, but it would require
some extra moving around. We would have to jump to
the line we wanted to copy (6G), yank it (yy), snap
back to where we started (<C-o>), and use the put
command (p) to duplicate the line. When duplicating
a distant line, the :t command is usually more
efficient.

In Ex Commands Strile Far and Wide, on page 54, we
observed the general rule that Normal commands act
locally, whereas, Ex commands are long range. This
example demonstrates this principle in action.


Move Lines with the ':m' Command

The :move command looks similar to the :copy command
(see :h :move):

:[range]move{address}

We can shorten it to a single letter: :m . Suppose
that we want to move the Hardware Store section after
the Beauty Parlor section. We could do so using the
:move command as shown in Table 10, Moving a Set of
Lines with the ':m' Command, on page 61.

Having make our visual selection, we simply have to 
run the command :'<,'>m$ . Alternatively, we could
run dGp. This breaks down like this: d to delete the
visual selection, G to jump to the end of the file,
and p to paste the text that was deleted.

Keystrokes	BufferContents
------------------------------------------------------
{start}		Shopping list
                       |Hardware Store
                	    Buy nails
                	    Buy new hammer
                	Beauty Parlor
                	    Buy nail polish remover
                	    Buy nails
------------------------------------------------------
Vjj		Shopping list
               _        Hardware Store_
               _	    Buy nails_
               _       |    Buy new hammer_
                	Beauty Parlor
                	    Buy nail polish remover
                	    Buy nails
------------------------------------------------------
:'<,'>m$	Shopping list
                	Beauty Parlor
                	    Buy nail polish remover
                	    Buy nails
                        Hardware Store 
                	    Buy nails 
                           |Buy new hammer 
------------------------------------------------------
Table 10 --Moving a Set of Lines with the ':m' Command


Remember that the '<,'> range stands for the visual
selection. We could easily make another visual selection
and then repeat the :'<,'>m$ command to move the 
selected text to the end of the file. Repeating the last
Ex command is as easy as pressing @: (see Tip 31, on 
page 63, for another example), so this method is more
easily reproducible than using Normal mode commands.


				Tip 30
Run Normal Mode Commands Across a Range

If we want to run a Normal mode command on a series
of consecutive lines, we can do so using the :normal
command, When used in combination with the dot command
or a mocro, we can perform repetitive task with very
little effort.

Consider the example we met in Tip 2, Don't Repeat
Yourself, on page 4. We wanted to append a 
semicolon at the end of a series of lines. Using
the Dot Formula allowed us to complete the task
rapidly, but in that example we need to make the
change only on three consecutive lines. What if we
had to make the same change fifty times? Using the
Dot Formula, we would have to press j. fifty times.
That makes a total of one hundred keystrokes!

There is a better way. To demonstrate, we'll append
a semicolon at the end of each line in this file.
To save space, I've only included five lines, but
if you can imagine instead that there are fifty
lines, then this technique will seem more potent:

cmdline_mode/foobar.js
var foo = 1
var bar = 'a'
var baz = 'z'
var foobar = foo + bar
var foobarbaz = foo + bar + baz

We'll start off as we did before, by changing the
first line:

Keystrokes  BufferContents
---------------------------------------------------
{start}    |var foo = 1
            var bar = 'a'
            var baz = 'z'
            var foobar = foo + bar
            var foobarbaz = foo + bar + baz
--------------------------------------------------
A;<Esc>     var foo = 1|;
            var bar = 'a'
            var baz = 'z'
            var foobar = foo + bar
            var foobarbaz = foo + bar + baz

We want to avoid executing the . command on each
line one by one. Instead, we can use the :normal
Ex command to execute the dot command across a 
range of lines:

Keystrokes  BufferContents
---------------------------------------------------
jVG         var foo = 1;
           _var bar = 'a'_
           _var baz = 'z'_
           _var foobar = foo + bar_
          _|var foobarbaz = foo + bar + baz_
--------------------------------------------------
:'<,'>      var foo = 1;
  normal.   var bar = 'a';
            var baz = 'z';
            var foobar = foo + bar;
            var foobarbaz = foo + bar + baz|;
            
The :'<,'>normal. command can be read as follows:
"For each line in the visual selection, execute
the Normal mode . command. "This technique works
just as well whether we're operating on five lines
or fifty lines. The real beauty of it is that we
don't even have to count the lines --we can get
away with selecting them in Visual mode.

In this case, we've used :normal to execute the
dot command, but we can execute any Normal mode
commands in the same way. For example, we could
have solved the problem above with this single
command:

:%normal A;

The % symbol is used as a range representing the
entire file. So :%normal A; instructs Vim to append
a semicolon at the end of every line of the file.
Making this change involves switching into Insert
mode, but Vim automatically reverts to Normal mode
afterward.

Before executing the specified Normal mode command
on each line, Vim moves the cursor to the beginning
of the line. So we don't have to worry about where
the cursor is positioned when we execute the
command. This single command could be used to 
comment out entire JavaScript file:

:%normal i//

While it's possible to use :normal with any normal
command, I found it most powerful when used in
combination with one of Vim's repeat commands:
either :normal . for simple repeats or :normal @q
for more complex tasks. Skip ahead to Tip 68, 
Repeat a Change on Contiguous Lines, on page 168,
and Tip 70, Act Upon a Collection of Files, on
page 173, for a couple of examples.

In Ex Commands Strike Far and Wide, on page 56, we
noted that Ex commands can change multiple lines
at once. The :normal command allows us to combine
the expressive nature of Vim's Normal mode 
commands with the range of Ex commands. It's a
powerful combination!

For yet another alternative solution to the problem
covered in this tip, refer to Tip 26, Append After
a Ragged Visual Block, on page 50.


                            Tip 31
Repeat the Last Ex Command

While the . command can be used to repeat our most
recent Normal mode command. we have to use @:
instead if we want to repeat the last Ex command.
Knowing how to reverse the last command is always
useful, so we'll consider that, too, in our
discussion.

In Chapter 1, The Vim Way, on page 1, we saw how
the . command can be used to repeat the last 
change. But the dot command won't replay changes 
make from Vim's command line. Instead, we can
repeat the last Ex command by pressing @: (see
:h @:).

For example, this command can be useful when 
iterating through items in the buffer list. We can
step forward through the list with the :bn[ext]
command and backward with the :bp[revious] 
command (Tip 37, Track Open Files with the Buffer
List, on page 83, discusses the buffer list in more
detail). Suppose that we had a dozen or so items 
in the buffer list, and we wanted to take a look
at each one of them. We could type this command
once:

:bnext

Then we use @: to repeat the command. Note the
similarity between this and the method for 
executing a macro (Play Back a Sequence of Commands
by Executing a Macro, on page 163). Also note that
the :register always holds the most recently
executed command line (see :h quote_:). After
running @: for the first time, we can subsequently
repeat it with the @@ command.

Suppose that we got trigger-happy and fired the
@: command too many times, overshooting our mark.
How would we change direction then? We could
execute :bprevious command. But think about what
would happen if we were to use the @: command 
again. It would go backward through the buffer 
list, which is the exact opposite of what it did
before. That could be confusing.

In this case, a better option would be to use the
<C-o> command (see Tip 56, Traverse the Jump List,
on page 135). Each time we run :bnext (or repeat
it with the @: command), it adds a record to the
jump list. The <C-o> command goes back to the 
previous record in the jump list.

We could run :bnext once and then repeat it as
often as we like using the @: command. If we needed
to back up, we could do so using the <C-o> command.
Then, if we wanted to continue going forward 
through the buffer list, we could go back to using
the @: command. Remember our mantra from Tip 4, 
Act, Repeat, Reverse, on page 8: act, repeat, 
reverse.

Vim provides an Ex command for just about 
everything. While it's always possible to repeat
the last Ex command by pressing @:, it's not always
straightforward to reverse the effects. The <C-o>
trick covered in this tip also works for reversing
the effects of :next, :cnext, and :tnext commands
(and so on). Whereas, for each of the items in 
Table 7, Ex Commands That Operate on the Text in
a Buffer, on page 54, we could undo their effects
by pressing u.


                            Tip 32
Tab-Complete Your Ex Commands

Just like in the shell, we can use the <Tab> key
to autocomplete commands at the prompt.

Vim is smart about picking suggestions for 
tab-completion. It looks at the context of what has
already been typed at the command line and builds
a list of suitable suggestions. For example, we
could type this:

:col<C-d>
colder  colorscheme

The <C-d> command asks Vim to reveal a list of 
possible completions (see :h c_CTRL-D). If we hit
the <Tab> key, the prompt will cycle through 
colder, colorscheme, and then the original col
again. We can scroll backward through the 
suggestions by pressing <S-Tab>.

Suppose we want to change the color scheme, but
we can't remember the name of the theme we want.
We could use the <C-d> command to show all the
options:

:colorscheme <C-d>
blackboard desert      morning     shine
blue       elflord     murphy      slate
darkblue   evening     pablo       solarized
default    koehler     peachpuff   torte
delek      mac_classic ron         zellner

This time, <C-d> shows a list of suggestions
based on the color schemes that are available.
If we wanted to enable the solarized theme, we
could just type the letters "so" and then hit the
Tab key to complete our command.

In many scenarios, Vim's tab-completion does the
right thing. If we type a command that expects a
filepath as an argument (such as :edit or :write),
then <Tab> will complete directories and filenames
relative to the current working directory. With
the :tag command we can autocomplete tag names.
The :set and :help commands know about every
configuration option in Vim.

We can even define the tab-completion behavior
when creating our own custom Ex commands. To see
what's possible, check out :h :command-complete.


Choosing form Multiple Matches

When Vim finds only a single suggestion for 
tab-completion, it uses the entire match. But if
Vim finds multiple suggestions, then one of 
several things could happen. By default, Vim 
expands the first suggestion when the Tab key is
pressed for the first time. With each subsequent
press of the Tab key, we can scroll through the
remaining suggestions.

We can customize this behavior by tweaking the
'wildmode' option (see :h 'wildmode'). If you're
used to working with the bash shell, then this
setting will match your expectations:

set wildmode=longest, list

If you're used to the autocomplete menu provided
by zsh, you might want to try this instead:

set wildmenu
set wildmode=full

With the 'wildmenu' option enabled, Vim provides
a navigable list of suggestions. We can scroll
forward through the items by pressing <Tab>, <C-n>
, or <Right>, and we can scroll backward through
them with <S-Tab>, <C-p>, or <Left>.


                            Tip 33
Insert the Current Word at the Command Prompt

Even in Command-Line mode, Vim always knows where
the cursor is positioned and which split window
is active. To save time, we can insert the current
word (or WORD) from the active document onto our
command prompt.

At Vim's command line, the <C-r><C-w> mapping 
copies the word under the coursor and inserts it
at the command-line prompt. We can use this to
save ourselves a bit of typing.

Suppose that we want to rename the tally variable
in this excerpt to counter:

cmdline_mode/loop.js
var tally;
for (tally=1; tally <= 10; tally++ ) {
    // do something with tally
};

With our cursor positioned on the word tally, we
could use the * command to search for each 
occurrence. (The * command is equivalent to typing
the sequence /\<C-r><C-w\><CR>. See Tip 77, Stake
the Boundaries of a Word, on page 193, for a
discussion of how \< and \> items work in a 
pattern.)

Keystrokes  BufferContents
---------------------------------------------------
{start}     var |tally;
            for (tally=1; tally <= 10; tally++ ) {
                // do something with tally
            };
---------------------------------------------------
*           var _tally_;
            for ( |_tally_=1;  _tally_<= 10;
                                 _tally_++ ) {
                // do something with _tally_
            };
---------------------------------------------------
cwcounter   var _tally_;
 <Esc>      for ( counte|r=1;  _tally_<= 10;
                                 _tally_++ ) {
                // do something with _tally_
            };

When we press the * key, our cursor jumps forward
to the next match, but the cursor ends up on the
same word anyway. Typing cwcounter<Esc> makes the
change.

We'll carry out the remaining changes using a 
:substitute command. Since our cursor is on the
word "counter", we dont need to type it out again.
We can just use the <C-r><C-w> mapping to populate
the replacement field:

:%s//<C-r><C-w>/g

That command doesn't look very succinct when 
written down, but two keystrokes to insert a word
ain't bad. We didn't have to type the search
pattern either, thanks to the * command. Refer to
Tip 91, Reuse the Last Search Pattern, on page 225,
to see why we can leave the search field blank
like that.

While <C-r><C-w> gets the word under the cursor,
we can instead use <C-r><C-a> if we want to get
the WORD (for an explanation, see Tip 49, Move
Word-Wise, on page 118). See :h c_CTRL-R_CTRL-W 
for more details. We've used the :substitute 
command in this example, but these mapping can be
used with any Ex command.

For another application, try opening your vimrc
file, place your cursor on a setting, and then
type :help <C-r><C-w> to look up the documentation
for that setting.


                            Tip 34
Recall Commands from History

Vim records the commands that we enter in 
Command-Line mode and provides two ways of 
recalling them: scrolling through past command-
lines with the cursor keys or dialing up the 
command-line window.

Vim keeps a history of our activity in Command-Line
mode. We can easily recall previous commands, so
there's no need to type out a long Ex command
at the prompt more than once.

To begin with, let's switch to Command-Line mode
by pressing the : key. Leave the prompt empty;
then press the <Up> arrow key. The command line
should be populated with the most recent Ex
command that we executed. We can use the <Up> key
again to go further back through our Ex command
history or use the <Down> key to go in the opposite
direction.

Now try typing :help, followed by the <Up> key.
Again, this should scroll through previous Ex 
commands, but instead of showing everything, the
list will be filtered to only include Ex commands
that started with the word "help".

By default, Vim records the last twenty commands.
With memory becoming ever cheaper in today's 
computers, we can probably afford to up this limit
by changing the 'history' option. Try adding this
line to your vimrc:

set history=200

Note that history is not recorded just for the
current editing session. It persists even when we
quit and relaunch Vim (see :h viminfo). Increasing
the number of items recorded in history can be
really useful.

As well as recording a history of Ex commands, Vim
keeps a separate record of our search history. If
we press / to bring up the search prompt, we can
also scroll backward and forward through previous
searches with the <Up> and <Down> keys. The search
prompt is, after all, just another form of Command-
Line mode.


Meet the Command-Line Window

Like Insert mode, Command-Line mode is fine for
composing something from scratch, but it's not a
comfortable place to edit text.

Suppose we're working on a simple Ruby script.
Each time we make a change, we find ourselves
running the following two commands:

:write
:!ruby %

After running these two commands in quick 
succession a couple of times, we realize that we
could streamline our workflow by folding them into
a single command line. This way we can dial up one
complete command from our history and replay it:

:write | !ruby %

Each of these commands is already in our history,
so we shouldn't have to type the entire command
line from scratch. But how can we merge two records
from our history into one? Press q: and meet the
command-line window (see :h cmdwin).

The command-line window is like a regular Vim
buffer, where each line contains an item from our
history. With the k and j keys, we can move 
backward and forward through our history. Or we can
use Vim's search feature to find the line that 
we're looking for. When we press the <CR> key, the
contents of the current line are executes as an
Ex command.

The beauty of the command-line window is that is
allows us to change historical commands using the
full modal editing power of Vim. We can navigate
with any of the motion we're accustomed to using
in Normal mode. We can operate on visual selection
or switch to Insert mode. We can even run Ex 
commands on the contents of the command-line
window!

Having summoned the command-line window by pressing
q:, we could solve our problem as follows:

keystrokes      BufferContents
---------------------------------------------------
{start}        |write
                !ruby %
---------------------------------------------------
A_|<Esc>        write ||
                !ruby %
---------------------------------------------------
J               write ||!ruby%
---------------------------------------------------
:s/write/update |update | !ruby %

Pressing <CR> would then execute the :update | 
!ruby % commands as though we had typed it into 
the command line.

When the command-line window is open, it always
gets the focus. That means we can't switch to
other windows except by dismissing the command-line
window. We can close the command-line window by
running the :q command (just like any ordinary
Vim window) or by pressing <CR>.

Note that when we press <CR> in the command-line
window, the command is executed in the context of
active window: that is, the window that was active
before the command-line window was summoned. Vim
doesn't indicate which is the active window when
the command-line window is open, so pay attention
if you're using split windows!

What if halfway through composing an Ex command at
the prompt, we realize that we need more editing
power? In Command-Line mode, we can use the <C-f>
mapping to switch to the command-line window, 
preserving a copy of the command that was typed
at the prompt. This table summarizes a few of the
methods for summoning the command-line window:

Command Action
---------------------------------------------------
q/      Open the command-line window with history
            of searches
---------------------------------------------------
q:      Open the command-line window with history
            of Ex commands
---------------------------------------------------
ctrl-f  Switch from Command-Line mode to the
            command-line window

It's easy to mix up the q: and :q commands. I'm
sure that we've all opened the command-line window
by accident when we actually meant to quit Vim!
It's a shame, because this feature is really
useful, but many people are frustrated by their
first (accidental) encounter with it. Skip ahead
to Tip 85, Create Complex Patterns by Iterating
upon Search History, on page 211, for another
example of the command-line window in action.


                            Tip 35
Run Commands in the Shell

We can easily invoke external programs without
leaving Vim. Best of all, we can send the contents
of a buffer as standard input to a command or use
the standard output from an external command to 
populate our buffer.

The commands discussed in this tip work best when
used from Vim inside a terminal. If you're using
GVim (or MacVim), then things may not work quite
as smoothly. That shouldn't come as a great
surprise. It's much easier for Vim to delegate
work to the shell if Vim itself is already running
inside a shell. GVim does some things better, but
this is one area where terminal Vim has the edge.


Executing Programs in the Shell

From Vim's Command-Line mode, we can invoke
external programs in the shell by prefixing them
with a bang symbol (see :h :!). For example, if we
want to examine the contents of the current 
directory, we could run the following:

:!ls
duplicate.todo          loop.js
emails.csv              practical-vim.html
foobar.js               shopping-list.todo
history-scrollers.vim

Press ENTER or type command to continue


Note the difference between :!ls and :ls --the 
former calls the ls command in the shell, whereas,
:ls calls Vim's built-in command, which shows the
contents of the buffer list.

On Vim's command line, the % symbol is shorthand
for the current file name (see :h cmdline-special).
We can exploit this to run external commands that 
do something with the current file. For example,
if we're working on a Ruby file, we could execute
it  by running this:

:!ruby %

Vim also provides a set of filename modifiers, 
which allow us to extract information from the
current filename, such as its path or extension
(see :h filename-modifiers). Skip ahead to Tip 45,
Save Files to Nonexistent Directories, on page 107,
for an example of how these can be used.

The :!{cmd} syntax is great for firing one-off
commands, but what if we want to run several 
commands in the shell? In that case, we can use
Vim's :shell command to start an interactive shell
session (see :h :shell).

:shell
$ pwd
/Users/drew/books/PracticalVim/code/cmdline_mode
$ ls
duplicate.todo          loop.js
emails.csv              practical-vim.html
foobar.js               shopping-list.todo
history-scrollers.vim
$ exit

The exit command kills the shell and returns us
to Vim.


Putting Vim in the Background

The :shell command is a feature provided by Vim,
which lets us switch to an interactive shell. But
if we're already running Vim in a terminal, then
we also have access to built-in shell commands.
For example, the bash shell supports job control,
which allows us to suspend a job by putting it 
into the background and then lets us resume it
later by bringing it back into the foreground.

Suppose that we're running Vim inside a bash shell
and we want to execute a series of shell commands.
Pressing Ctrl-z suspends the process that's 
running Vim and returns control to bash. The Vim
process sits idle in the background, allowing us 
to interact with our bash session as normal. We
can inspect the list of jobs by running this 
command

$ jobs
[1]+ Stopped    vim

In bash, we can use the fg command to resume a
suspended job, bring it back into the foreground.
That brings Vim back to life exactly as we left
it. The Ctrl-z and fg commands are quicker and
easier to use than Vim's equivalent :shell and
exit commands. For more information, run man bash
and read the section on job control.


Using the Contents of a Buffer for Standard
    Input or Output

While we use the :!{cmd} syntax, Vim echoes output
from the {cmd}. This works fine if the command
produves little or no output, but it's not very
helpful if the command produces many lines of
output. As an alternative, we can use the :read
!{cmd} command, which puts the output from the
{cmd} into our current buffer (see :h :read!).

The :read !{cmd} command lets us direct standard
output into a buffer. As you might expect, the 
:write !{cmd} does the inverse: it uses the 
contents of the buffer as standard input for the 
specified {cmd} (see :h :write_c). Skip ahead to
Tip 46, Save a File as the Super User, on page
108, to see an example of this feature in use.

The bang symbol can take on different meanings
depending on where it is placed withing the 
command line. Compare these commands:

:write !sh
:write ! sh
:write! sh

The first two commands pass the contents of the
buffer as standard input to the external sh
command. The last command writes the contents of
the buffer to a file called sh by calling the
:write! command. In this case, the bang tells Vim
to overwrite any existing sh file. As you can see,
the placement of the bang symbol can drastically
alter the outcome. Take care when composing this
sort of command!

The effect of the :write !sh command is that each
line of the current buffer is executed in the
shell. Refer to :h rename-files for a nice example
of this command on use.


Filtering the Contents of a Buffer Through an 
    External Command

The :!{cmd} command takes on a different meaning
when it's given a range. The lines specified by
[range] are passed as standard input for the {cmd},
and then the output from {cmd} overwrites the 
original contents of [range]. Or to put it
another way, the [range] is filtered through the
specified {cmd} (see :h :range!). Vim defines a
filter as "a program that accepts text as standard
input, changes it some way, and sends it to 
standard output".

As a demonstration, let's use the external sort
command to rearrange the records in this CSV file:

cmdline_mode/email.csv
first name,last name.email
john,smith,john@example.com
drew,neil,drew@vimcasts.org
jane,doe,jane@example.com

We'll sort the records by the second field:
last name. We can use the -t',' option to tell the
sort command that fields are separated with commas,
and we can use the -k2 flag to indicate that the
second field is to be used for the sort.

The first line of the file contains header 
information. We want to leave it at the top
of the file, so we'll execute it from the sort
operation by using a range of :2,$. This command
line does what we want:

:2,$!sort -t',' -k2

The records in our CSV file should now be sorted
by last name:

first name,last name.email
jane,doe,jane@example.com
drew,neil,drew@vimcasts.org
john,smith,john@example.com

Vim provides a convenient shortcut for setting the
range of a :[range]!{filter} command such as this.
The !{motion} operator command drops us into 
Command-Line mode and prepopulates the [range] with
the lines covered by the specified {motion} (see
:h !). For example, if we place our cursor on line
2 and then invoke !G, Vim opens a prompt with the
:.,$! range set up for us. We still have to type
out the rest of the {filter} command, but it saves
a little work.


Discussion

When operating Vim, we're never more than a couple
of keystrokes away from the shell. This table 
summarizes a selection of the most useful methods
for calling external commands:

Command         Effect
---------------------------------------------------
:shell          Start a shell (return to Vim by
                 typing exit)
---------------------------------------------------
:!{cmd}         Execute {cmd} with the shell
---------------------------------------------------
:read !{cmd}    Execute {cmd} in the shell and 
                 insert its stadard output below
                  the cursor
---------------------------------------------------
:[range]write   Execute {cmd} in the shell with
 !{cmd}          [range] lines as standard input
---------------------------------------------------
:[range]!       Filter the specified [range]
 {filter}        through external program {filter}


Vim gives special treatment to some commands. For
example, both make and grep have wrapper commands.
Not only are they easy to execute from inside Vim,
but their output is parsed and used to populate
the quickfix list. These commands are covered in
greater depth in both Chapter 17, Compile Code
and Navigate Errors, on page 263, and Chapter 18,
Search Project-Wide, on page 273.


                            Tip 36
Run Multipe Ex Commands as a Batch

If we need to execute a sequence of Ex commands,
we can save ourselves work by putting those
commands in a script. Next time we want to run
those commands, we can source the script rather
than typing the commands one by one.

This file contains links to the first couple of
episodes from the Vimcasts archive:

cmdline_mode/vimcasts/episode-1.html
<ol>
  <li>
    <a href="/episodes/show-invisibles/">
      Show invisibles
    </a>
  </li>
  <li>
    <a href="/episodes/tabs-and-spaces/">
      Tab and Spaces
    </a>
  </li>
</ol>

We need to midify this into a plain-text format
showing the title follwoed by the URL:

cmdline_mode/vimcasts/episode-1.txt
Show invisibles: http://vimcasts.org/episode
                    /show-invisibles/
Tabs and Spaces: http://vimcasts.org/episode
                    /tabs-and-spaces/

Let's suppose we anticipate having to make these
same transformations across a series of files that
follow a similar format. We'll look at a couple
of different ways we could approach this.


Run Ex Commands One by One

It might be possible to make this transformation
using a single :substitute command, but my
preference would be to break this up into several
small tasks. This sequence of Ex commands is one
possible solution:

:g/href/j
:v/href/d
8 fewer lines
:%norm A: http://vimcasts.org
:%norm yi"$p
:%s/\v^[^\>]+\s//g

You don't have to understand what each of these
commands does to follow the rest of this tip, but
if you're curious, here's a brief outline. The
:global and :vglobal commands work together to
collapse the file down into two lines that contain
the information we need, albeit in the wrong
order (Tip 99, Delete Lines Containing a Pattern,
on page 242). The :normal commands append the URL
at the end of the line (Tip 30, Run Normal Mode
Commands Accross a Range, on page 63). And the
:substitute command removes the opening <a href=
""> out for yourself.


Write Ex Commands to a Script and Source It

Instead of executing these commands one by one,
we could put them all into a file and save it to
disk. Let's call it batch.vim (Using the .vim
extension will make Vim use the correct syntax
highlighting). Each line of this file corresponds
to a command line from the workflow outlined 
earlier. In this context we don't need to prefix
each line with a : character. Personally, I
prefer to use the longhand names for Ex commands
when putting them in a script. Saving keystrokes
is less of a concern than making the script easy
to read.

cmdline_mode/batch.vim
global/href/join
vglobal/href/delete
%normal A: http://vimcasts.org
%normal yi"$p
%substitute/\v^[^\>]+\>\s//g

We can use the :source command to execute the
batch.vim script (see :h source). Each line of the
script is executed as an Ex command, just as
though we had typed it at Vim's command line. 
You've probably come across the :source command
before in another context: it's commonly used to
load configuration setting from a vimrc file at 
runtime. (See Save Your Configuration in a vimrc
File, on page 304, for more details.)

I suggest you try this out for yourself. You can
download the source code from Practical Vim's
book page on the Pragmatic Bookshelf site. Before
opening Vim, change to the cmdline_mode directory,
where you'll find both the batch.vim and 
episode-1.html files.

$ pwd 
~/dnvim2/code/cmdline_mode
$ ls *.vim
batch.vim       history-scrollers.vim
$ vim vimcasts/episodes-1.html

Now we can execute our script:

:source batch.vim

With that single command line, we've executed each
of the Ex commands from batch.vim. If you change
your mind, you can undo those changes by pressing
the u key once.


Source the Script to Change Multiple Files

There's little point in saving our Ex commands to
a file if we're only going to execute the script
one time. This trick comes into its own if we want
to run that same sequence of Ex commands several
times.

The code samples provided with this book include
a few files with the same format as the episode-1.
html file. Make sure that you're in the cmdline_
mode directory and launch Vim:

$ pwd
~/dnvim2/code/cmdline_mode
$ ls vimcasts
episodes-1.html episode-2.html  episode-3.html
$ vim vimcasts/*.html

Launching Vim with a wildcard will populate the
argument list with all of the files that match
that pattern. We could step through those files
one by one, sourcing our batch.vim for each one:

:args
[vimcasts/episode-1.html] vimcasts/episode-2.html
vimcasts/episode-3.html
:first
:source batch.vim
:next
:source batch.vim
etc.

Or better still, we could use the :argdo command
(:h :argdo):

:argdo source batch.vim

Boom! With a single command we've executed each
of the Ex commands in batch.vim across each of the
files in the argument list.

I've chosen to illustrate this technique using
a varied selection of Ex commands to demonstrate
what's possible. In practice, I most commonly use
this technique to execute one or more :substitute
commands if I find myself using them again and 
again. I'll often discard the batch.vim file
after use, but I might put it under source control
if I think it could be useful in the future.




		Part II

		Files


	In this part of the book, we'll learn
	how to work with files and buffers.
	Vim lets us work on multiple files in 
	a single editing session. We can view
	them one at a time or divide our 
	workspace into spit windows or tabs,
	each containing a separate buffer.
	We'll look at several different ways
	of opening files from inside Vim. We'll
	also learn a couple of work arounds for
	common gotchas that may prevent us from
	saving our buffers to a file.



					CHAPTER 6
			Manage Multiple Files

Vim lets us work on multiple files at the same 
time. The buffer list lets us keep track of the set
of files that we've opened in the course of an 
editing session. In Tip 36, on page 77, we'll learn
how to interact with this list as well as learn the
distinction between a file and a buffer.

The argument list is a great complement to the
buffer list. In Tip 37, on page 80, we'll see how
to use the :args command to group files from the
buffer list into a collection. We can then traverse
the list or execute an Ex command on each member of
the set using the :argdo command.

Vim allows us to divede our workspace into split
windows. We'll learn how in Tip 39, on page 85.
Then in Tip 40, on page 89, we'll see how Vim's
tabbed interface can be used to organize split
windows into a collection.


			Tip 36
Track Open Files with the Buffer List

We can load multiple files during an editing 
session. Vim lets us manage them using the buffer
list.


Understanding the Distinction Between Files and
Buffers

Just like any other text editor, Vim allows us to
read files, edit them, and save our changes. When
we discuss our workflow, it's tempting to say that
we're editing a file, but that's not what we're
actually doing. Instead, we're editing an in-memory
representation of a file, which is called a buffer
in Vim's terminology.

Files are stored on the disk, whereas buffer exist
in memory. When we open a file in Vim, its contents
are read into a buffer, which takes the same name
as the file. Initially, the contents of the buffer
will be identical to those of the file, but the two
will diverge as we make changes to the buffer. If
we decide that we want to keep our changes, we can
write the contents of the buffer back into the
file. Most Vim commands operate on buffers, but
a few operate on files, including the :write, 
:update, and :saveas commands.


Meet the Buffer List 

Vim allows us to work with multiple buffers
simultaneously. Let's open a few files by running
these commands in the shell:

$ cd code/files
$ vim *.txt
2 files to edit

The *.txt wildcard matches two files in the
current directoty: a.txt and b.txt. This commad tells Vim to open both of 
those files. When Vim starts up, it shows a single window with a buffer
representing the first of the two files. The other file isn't visible, but
it has been loaded into a buffer in the background, as we can see by running
the following:

:ls
1 %a	"a.txt"		line 1
2 	"b.txt"		line 0

The :ls command gives us a listing all the buffers that have been loaded into
memory (:h :ls). We can switch to the next buffer in the list by running the
:bnext command:

:bnext
:ls
1 #	"a.txt"		line 1
2 %a	"b.txt"		line 1

The % symbol indicates which of the buffers is visible in the current window,
while the # symbol represents the alternate file. We can quickly toggle
between the current and alternate files by pressing <C-^>. Press it once, and
we'll switch to a.txt; press it a second time, and we'll get back to b.txt.


Use the Buffer List

We can traverse the buffer list using four commands --:bprev and :bnext to
move backward and forward one at a time, and :bfirst and :blast to jump to the
start or end of the list. It's a good idea to map them to something easier to
reach.

See Create Mapping to Quickly Traverse Vim's Lists, on page 79, for a 
suggested mapping.

The :ls listing starts with a digit, which is assigned to each buffer 
automatically on creation. We can jump directly to a buffer by number, using
the :buffer N command (see :h :b). Alternatively, we can use the more 
intuitive form, :buffer {bufname}. The {bufname} need only contain enough
characters from the filepath to uniquely identify the buffer. If we enter a
string that matches more than one of the items in the buffer list, we can use
tab-completion to choose between the options (see Tip 32, on page 65).

The :bufdo command allows us to execute an Ex command in all of the buffers
listed by :ls (:h :bufdo). In practice, I usually find that it's more 
practical to use :argdo instead, which we'll meet in Tip 37, on page 80.


Create Mappings to Quickly Traverse Vim's Lists

Typing :bn and :bp can feel laborious. To speed things up a bit, I use these
mappings from Tim Pope's unimpaired.vim plugin:

nnoremap <silent> [b :bprevious<CR>
nnoremap <silent> ]b :bnext<CR>
nnoremap <silent> [B :bfirst<CR>
nnoremap <silent> ]b :blast<CR>

Vim already uses the [ and ] keys as prefixes for a series of related commands
(see :h [), so these mappings have a consistent feel to them. The 
unimparied.vim plugin provides similar mappings for scrolling through the
argument ([a and ]a), quickfix ([q and ]q), location ([l and ]l), and tag
lists ([t and ]t). Check it out.


Deleting Buffers

Vim creates a new buffer any time we open a file, and we'll learn a few ways
of doing that in Chapter 7, Open Files and Save Them to Disk, on page 93. If
we want to delete a buffer, we can do so using the :bdelete command. This can
take one of these forms:

:bdelete N1 N2 N3
:N,M bdelete

Note that deleting a buffer has no effect on its associated file; it simply
removes the in-memory representation. If we wanted to delete buffers numbered
5 through 10 inclusive, we could do so by running 5,10bd. But if we wanted to
keep buffer number 8, then we'd instead have to run :bd 5 6 7 9 10.

Buffer numbers are automatically assinged by Vim, and we have no means of
changing them by hand. So if we wanted to delete one or more buffers, we 
first have to  look them up to find out their numbers. This procedure  is 
relatively time-consuming. Unless I have a good reason to delete a buffer,
I usually don't bother. As a result, the :ls listing comes to represent all
of the files that I have opend in the course of an editing session.

Vim's built-in controls for managing the buffer list lack flexibility. If we
wanted to arrange buffers in a way that makes sense for our workfow, 
attempting to organize the buffer list is not the way to go. Instead, we're
better off diving our workspace using split windows, tab pages, or the 
argument list. The next tips will show how.


					Tip 37
Group Buffers into a Collection with the Argument List

The argument list is easily managed and can be useful for grouping together
a collection of files for easy navigation. We can run an Ex command on each
item in the arfument list using the :argdo command.

Let's start by opening a handful of files in Vim:

$ cd code/files/letters
$ vim *.txt
5 files to edit

In Tip 36, on page 77, we saw that the :ls command provides a listing of
buffers. Now let's examine the argument list:

:args
[a.txt] b.txt c.txt d.txt e.txt

The argument list represents the list of files that was passed as an argument
when we ran the vim command. In our case, we provided a single argument, 
*.txt, but our shell expanded the * wildcard, matching the five files that
we see in our argument list. The [] characters indicate which of the files in
the argument list is active.

Compared to the listing provided by the :ls command, the output from running
:args looks crude. It shoul come as no surprise to learn that the argument 
list was a feture of vi, whereas the buffer list is an enhancement introduced
by Vim. But give the argument list a chance, and you'll see that it makes a
fine complement to the buffer list.

Like many features in Vim, the functionality of the argument list has been
enhanced, while the original name has stuck. We can change the contents of
the argument list at any time, which means that the :args listing doesn't
necessarily reflect the values that were passed to the vim command when we
launched the editor. Don't take the name literally! (Also, see ':compiler'
and ':make' Are Not Just for Compiled Language, on page 268.)


Populate the Argument List

When the :args Ex command is run without arguments, it prints the contents
of the argument list. We can also set the contents of the argument list using
this form (:h :args_f):

:args {arglist}

The {arglist} can include filenames, wildcards, or even the output from a
shell command. To demonstrate, we'll use the files/mvc directory, which you
can find in the source files that come distributed with this book. If you
want to follow along, switch to that directory and launch Vim:

$ cd code/files/mvc
$ vim

For an overview of the directory tree, refer to the code listing on page 94.


Specify Files by Name

The simplest way of populating the argument list is by specifying filenames
one by one:

:args index.html app.js
:args
[index.html] app.js

This technique works fine if we only want to add a handful of buffers to our
set. It has the advantage that we can specify the order, but doing it by hand
can be laborious. If we want to add a lot of files to the argument list, we
can get the job done faster by using wildcards.


Specify Files by Glob

Wildcards are placeholders that can stand in for characters in the name of a
file or directory. The * symbol will match zero or more characters, but only
in the scope of the specified directory (:h wildcard). The ** wildcard also
matches zero or more characters, but is can recurse downward into directories
below the specified directory (:h statstar-wildcard).


We can combine these wildcards and use partial filenames or directories to
form patterns, also known as globs, that match the set of files we're 
interested in. This table shows a representative summary of some (but not all)
of the files in the files/mvc directory that are matched by the specified
globs.

Glob		Files Matiching the Expansion
-----------------------------------------------------------------------------
:args *.*	index.html
		app.js
-----------------------------------------------------------------------------
:args **.*.js	app.js
		lib/framework.js
		app/controllers/Mailer.js
		...etc
-----------------------------------------------------------------------------
:args **/*.*	app.js
		index.js
		lib/framework.js
		lib/theme.css
		app/controllers/Mailer.js
		...etc

Just as we can use more than one filename in the {arglist}, we can also 
supply more than one glob. If we wanted to build an argument list containing
all .js and .css files but not other file types, we could use these globs:

:args **/*.js **/*.css


Specify Files by Backtick Expansion

As I wrote this book, I sometimes wanted to populate the argument list with
the chapters in the same order that they appear in the table of contents.
For this purpose, I maintained a plain-text file that contains one filename
per line. Here's an excerpt from it:

files/.chapters
the_vim_way.pml
normal_mode.pml
insert_mode.pml
visual_mode.pml

I can populate the argument list from this file by running this:

:args `cat .chapters`

Vim executes the text inside the backtick characters in the shell, using the
output from the cat command as the argument for the :args command. Here, 
we've used the cat command to get the contents of the .chapter file, but we
could use any command that's available in the shell. This feature is not 
available on all systems. See :h backtick-expansion for more details.


Use the Argument List

The argument list is simpler to manage than the buffer list, making it the
ideal place to group our buffers into a collection. With the :args {arglist}
command, we can clear the argument list and then repopulate it from scratch
with a single command. We can traverse the files in the argument list using
:next and :prev commands. Or we can use :argdo to execute the same command
on each buffer in the set.

The way I see it, the buffer list is like my desktop: it's always messy. The
argument list is like a separate workspace that I always keep tidy, just in
case I need space to stretch out. We'll see a few examples of how the
argument list can be used in other tips, such as Tip 69, on page 169, and
Tip 96, on page 223.


						Tip 38
Manage Hidden Files

When a buffer has been modified, Vim gives it special treatment to ensure 
that we don't accidentally quit the editor without saving our changes. Find
out how to hide a modified buffer and how to handle hidden buffers when
quitting Vim.

Run these commands in the shell to launch Vim:

$ cd code/files
$ ls
a.txt	b.txt
$ vim *.txt
2 files to edit

Let's make a change to a.txt: we'll just press Go to append a blank line at
the end of the buffer. Without saving the changes, let's examine the buffer
list:

:ls
1 %a + "a.txt"		line 1
2      "b.txt"		line 0

The buffer representing a.txt is annotated with a + sign, which indicates 
that it has been modified. If we were to save the file now, the contents of
the buffer would be written to disk and the + annotation would go away. But
let's not save the buffer just yet. Instead, we'll try to switch to the next
buffer:

:bnext
E37: No write since last change (add ! to override)

Vim raises an error message, reporting that the current buffer contains 
unsaved changes. Let's try following the advice in parentheses and add a 
trailing bang symbol:

:bnext!
:ls
1 #h + "a.txt"		line 1
2 %a   "b.txt"		line 1

The bang symbol forces Vim to switch buffers, even if our current buffer has
unsaved changes. When we run the :ls command now, b.txt is marked with the
letter a for active, while a.txt is marked with the letter for hidden.


Handle Hidden Buffer on Quit

When a buffer is hidden, Vim lets us go about our business as usual. We can
open other buffers, change them, save them, and so on, all without 
consequences --that is, right up until we attempt to close our editing 
session. That's when Vim reminds us that we have unsaved changes in one of
our buffers:

:quit
E37: No write since last change (add ! to override)
E162: No write since last change for buffer "a.txt"

Vim loads the first hidden buffer with modifications into the current window
so that we can decide what to do with it. If we want to keep the changes, we
can run :write to save the buffer to a file. Or if we want to discard the
changes, we can instead :edit!, which rereads the file from disk, 
overwriting the contents of the buffer. Having reconciled the contents of the
buffer with the file on disk, we can try :quit command again.

If we have more than one hidden buffer with modifications, then Vim activates
the next unsaved buffer each time we enter the :quit command. Again, we could
:write or :edit! to keep or discard the changes. This cycle continues until
we make a decision for each of the hidden buffers with modifications. When
there are no more windows and no more hidden modified buffers, the :q command
closes Vim.

If we want to quit Vim without reviewing our unsaved changes, we can issue
the :qall! command. Or, if we want to write all modified buffers without
reviewing them one by one, we use :wall command. Table 11, Options for Hidden
Buffers on Quit, on page 85 summarizes our options.


Enable the 'hidden' Setting Before Running ':argdo' or ':bufdo'

By default, Vim prevents us form abandoning a modified buffer. Whether we use
the :next!, :bnext!, :cnext!, or any similar command, if we omit the trailing

Command		Effect
-----------------------------------------------------------------------------
:w[rite]	Write the contents of the buffer to disk
:e[dit]!	Read the file from disk back into the buffer (that is, 
			revert changes)
:qa[ll]!	Close all windows, discarding changes withou warning
:wa[ll]		Write all modified buffers to disk
-----------------------------------------------------------------------------
Table 11 --Options for Hidden Buffers on Quit


bang symbol, Vim will nag us with the "No write since last change" error
message. In most cases, this message is a useful reminder. But in one
scenario it becomes a nuisance.

Consider the :argdo and :bufdo commands. The :argdo {cmd} command works like
this:

:first
:{cmd}
:next
:{cmd}
etc.

If our chosen {cmd} modifies the first bufferm the :next command will fail.
Vim won't permit us to advance to the second item in the argument list until
we save the changes to the first item in the list. That's not much use!

If we enable the 'hidden' setting (see :h 'hidden'), then we can use the 
:next, :bnext, :cnext (and so on) commands without a trailing bang. If the
active buffer is modified, Vim will automatically hide it when we navigate
away from it. The 'hidden' setting makes it possible to use :argdo and :bufdo
to change a collection of buffers with a single command.

After running :argdo {cmd}, we'll want to save the changes that were made to
each item in the argument list. We could do it one at a time by running 
:first and then :wn, which would give us the opportunity to eyball each file.
Or if we're confident that everything is in order, we could run :argdo write
(or :wall) to save all buffers.


					Tip 39
Divide Your Workspace into Split Windows

Vim allows us to view multiple buffers side by side dviding our workspace 
into split windows.

In Vim's terminology, a window is a viewport onto a buffer (:h window). We
can open multiple windows, each containing the same buffer, or we can load
different buffers into each window. Vim's window magiment system is flexible,
allowing us to build a workspace tailored to the demands of our workflow.


Creating Split Windows

When Vim starts up, it contains a single window. We can divide this window
horizontally with the <C-w>s command, which creates two windows of equal
height. Or we can use the <C-w>v command to split the window vertically, 
producing two windows of equal width. We can repeat these commands as often
as we like, splitting our workspace again and again in a process that 
resembles cell division.

The following figure illustrates a few of the possible results. In each case,
the shaded rectangle represents the active window.

Each time we use the <C-w>s and <C-w>v commands, the two resulting split
windows will contain the same buffer as the original window that was devided.
Having the same buffer displayed in separate windows can be useful, 
especially if we're working on a long file. For example, we could scroll one
of the window to show a part of the buffer that we want to refer to while 
making changes to another part of the buffer in the other window.

We can use the :edit command to load another buffer into the active window.
If we run <C-w>s followed by :edit{filename}, we can divide our workspace and
then open another buffer in one split window while keeping the existing 
buffer visible in the other split. Alternatively, we could use the command
:split {filename}, which combines those two steps into one. This table
summarizes the ways of dividing our workspace into split windows:

Command		Effect
-----------------------------------------------------------------------------
<C-w>s		Split the current window horizontally, reusing the current
		 buffer in the new window
-----------------------------------------------------------------------------
<C-w>v		Split the current window vertically, reusing the current
		 buffer in the new window
-----------------------------------------------------------------------------
:sp[lit]{file}	Split the current window horizontally, loading {file} into
		 the new window
-----------------------------------------------------------------------------
:vsp[lit]{file}	Split the current window vertically, logding {file} into
		 the new window

Changing the Focus Between Windows

Vim provides a handful of commands for switching the focus between split 
windows. This table summarizes some of the highlights (for the complete list,
see :h window-move-cursor):

Command		Effect
-----------------------------------------------------------------------------
<C-w>w		Cycle between open windows
<C-w>h		Focus the window to the left
<C-w>j		Focus the window below
<C-w>k		Focus the window above
<C-w>l		Focus the window to the right


In fact, <C-w><C-w> does the same thing as <C-w>w. That means we can press
the <Ctrl> key and hold it while typing ww (or wj or any of the others from
the table) to change the active window. It's easier to type <C-w><C-w> than
<C-w>w, even though it looks nastier when written down. Still, if you use
windows heavily, you might want to consider mapping these commands to 
something even more convenient.

If your terminal supports mouse interactions or if you're using GVim, then
you can also activate a window by clicking it with the mouse. If it doesn't
work for you, check that the 'mouse' option is set appropriately (:h 'mouse'
).


Closing Windows

If we want to reduce the number of windows in our workspace, we can take one
of two strategies. We could use the :close command to close the active
window, or if we want to close all windows except the active one, we can
instead use the :only command. This table summarizes the options and shows
the normal mode equivalentes:

Ex Command	Normal Command	Effect
:cl[ose]	<C-w>c		Close the active window
:on[ly]		<C-w>o		Keep only the active window, closing all					others

Resizing and Rearranging Windows

Vim provides several key mappings for resizing windows. For the full list, 
look up :h window-resize. This table summarizes a handful of the most useful
commands:

Keystrokes	BufferContents
-----------------------------------------------------------------------------
<C-w>=		Equalize width and height of all windows
<C-w>_		Maximize height of the active window
<C-w>|		Maximize width of the active window
[N]<C-w>_	Set active window height to [N] rows
[N]<C-w>|	set active window width to [N] columns

Resizing windows is one of the few tasks I prefer to do with the mouse. It's
simple: click on the line that separates two windows, drag the mouse until
each window is the desired size, and then let go the mouse. This works only
if your terminal supports the mouse or if you're using GVim.

Vim includes commands for rearranging windows, but rather than decribing them
here, I'd like to point to you toward a screencast on Vimcasts.org that 
demonstrates the possibilities. You can also find more details by looking up
:h window-moving

	
					Tip 40
Organize Your Window Layouts with Tab Pages

Vim's tabbed interface is different from that of many other text editors. We
can use tab pages to organize split windows into a collection of workspaces.

In Vim, a tab page is a container that can hold a collection of windows (:h
tabpage). If you're accustomed to using another text editor, then Vim's 
tabbed interface might seem strange at first. Let's begin by considering how
tabs work in many other text editors and IDEs.

The classic graphical user interface (GUI) for a text editor features a main
workspace for editing files and a sidebar that show the directory tree of the
current project. If we click on a file in the sidebar, it opens a new tab in
the main workspace for the specified file. A new tab is created for each file
that we open. In this model, we could say that the tabs represent the set of
files that are currently open.

When we open a file using the :edit command, Vim doesn't automatically create
a new tab. Instead, it creates a new buffer and loads it into the current
window. Vim keeps track of the set of files that are open using the buffer
list, as we say in Tip 36, on page 77.

Vim's tab pages are not mapped to buffers in a one-to-one relationship.
Instead, think of a tab page as a container that can hold a collection of
windows. Figure 1, Organizing split windows into tab pages, on page 89,
illustrates a workspace with three tab pages, each containing one or more
windows. In each scenario, the shaded rectangles represent the active windows
and tabs.

Tab pages are available to us whether we're using GVim or running Vim inside
a terminal. GVim draws a tab bar as part of the GUI, giving it an appearance
much like that of a we browser or any other tabbed interface. When Vim runs
inside a terminal, it draws a tab bar as a textual user interface (TUI).
Apart from the differences in appearance, tab pages are functionally 
identical whether rendered as a GUI or a TUI.


How to Use Tabs

Vim's tab pages can be used to partition work into different workspaces. They
have more in common with the virtual desktops in Linux than they do with the
tabbed interface of most other text editors.

Suppose that we're at work on a project, with our workspace divided into a 
few split windows. Out of the blue, something urgent comes up and we have to
switch contexts. Rather than opening new files in our current tab page, which
would mess up our carefully assembled workspace, we can create a new tab page
and do the work there. When we're ready to resume our previous work, we just
have to switch back to the original tab page where all of our windows will
have been preserved as we left them.

The :lcd{path} command lets us set the working directory locally for the 
current window. If we create a new tab page and then use the :lcd command to
switch to another directory, we can then comfortably scope each tab page to
a different project. Note that :lcd applies locally to the current window,
not to the current tab page. If we have a tab page containing two or more
split windows, we could set the local working directory for all of them by
running :windo lcd{path}. Check out episode 9 of Vimcasts for more 
information.


Opening and Closing Tabs

We can open a new tab page with the :tabedit {filename} command. If we omit
the {filename} argument, then Vim creates a new tab page containing an empty
buffer. 

Alternatively, if the current tab page contains more than one window, we can
use the <C-w>T command, which moves the current window into a new tab page
(see :h CTRL_T).

If the active tab page contains only a single window, the :close command will
close the window and the tab page with it. Or we can use the :tabclose 
command, which closes the current tab page no matter how many windows it 
contains. Finally, if we want to close all tab pages except for the current
one, we can use the :tabonly command.


Command			Effect
:tabe[dit]{filename}	Open {filename} in a new tab
<C-w>T			Move the current window into its own tab
:tabc[lose]		Close the current tab page and all of its windows
:tabo[nly]		Keep the active tab page, closing all others


Switching Between Tabs

Tabs are numbered starting from 1. We can switch between tabs with the {N}gt
command, which can be remembered as goto tab{N}. When this command is 
prefixed with a number, Vim jumps to the specified tab, but if the number is
ommited, Vim advances to the next tab. The gT command does the same but in
reverse.

Ex command	Normal Command	Effect
:tabn[ext]{N}	{N}gt		Switch to tab page number {N}
:tabn[ext]	gt		Switch to the next tab page
:tabp[revious]	gT		Switch to the previous tab page


Rearranging Tabs

We can use the :tabmove [N] Ex command to rearrange tab pages. When [N] is 0,
the current tab page is moved to the beggining, and if we omit [N], the
current tab page is moved to the end. If your terminal supports the mouse or
if you're using GVim, reordering tab pages by drag and drop is also possible.


						CHAPTER 7
					Open Files and Save Them to Disk

Vim has a few ways of opening files. In Tip 41, on page 93, we'll look at the
:edit command, which can be used to open any file by providing a filepath.

If we're working on files that are two or more directories beneath our 
project root, having to specify a complete filepath for every file we want
to open can be awkward. In Tip 42, on page 96, we'll learn how to configure
the 'path' option, which makes it possible to use the :find command. This 
saves us from having to specify fully qualified filepaths and allows us to
simply enter the filename.

The netrw plugin, which ships with Vim, makes it possible to explore the 
contents of a directory tree. We'll find out how to use it in Tip 43, on page
98.

The :write command lets us save the contents of a buffer to disk. Its usage
is generally straightforward, but it can become complicated if we attempt to
save to a nonexistent directory or if we don't have the permissions required
to write a file. We'll find out how to cope with these scenarios in Tip 44,
on page 101, and Tip 45, on page 102.


						Tip 41

Open a File by Its Filepath Using ':edit'

The :edit command allows us to open files from within Vim, either by 
specifying an absolute or a relative filepath. We also learn how to specify
a path relative to the active buffer.

As a demonstration, we'll use the files/mvc directory, which you can find in
the source files that come distributed with this book. It contains the 
following directory tree:

app.js
index.html
app/
    controllers/
        Mailer.js
        Main.js
        Navigation.js
    models/
        User.js
    views/
        Home.js
        Main.js
        Setting.js
lib/
    framework.js
    theme.css

In the shell, we'll start by changing to the files/mvc directory and then
launching Vim:

$ cd code/files/mvc
$ vim index.html


Open a File Relative to the Current Working Directory

In Vim, just as in bash and other shells, we have the notion of a working 
directory. When Vim is launched, it adopts the same working directory that was
active in the shell. We can confirm this by running the :pwd Ex command, which
(just as in bash) stands for "print working directory":

:pwd
/Users/drew/practical-vim/code/files/mvc

The :edit {file} command can accept a filepath relative to the working directory.
If we wanted to open the lib/framework.js, we could do so by running this 
command:

:edit lib/framework.js

Or we could open the app/controllers/Navigation.js file by running this:

:edit app/controllers/Navigation.js

We can use the tab key to autocomplete these filepaths (see Tip 32, Tab-Complete
Your Ex Commands, on page 67, for more details). So if we wanted to open the
Navigation.js file, we could simply press :edit a<Tab>c<Tab>N<Tab>.


Open a File Relative to the Active File Directory

Suppose that we're editing the app/controllers/Navigation.js file, and we 
decide that we want to edit the Main.js file in the same directory.  We could
drill down to it from our working directory, but that feels like unneccessary
work. The file we want to open is in the same directory as our active buffer.
It would be ideal if we could use the context of the active buffer as a 
reference point. Try this:

:edit %<Tab>

The % symbol is a shorthand for the filepath of the active buffer (see
:h cmdline-specal). Pressing the <Tab> key expands the filepath, revealing
the absolute path of the active buffer. That's not quite what we want, but
it's getting close. Now try this instead:

:edit %:h<Tab>

The :h modifier removes the filename while preserving the rest of the path
(see :h ::h). In our case, typing %:h<Tab> is expanded to the full path of
the current file's directory:

:edit app/controllers/

From there, we can type Main.js (or have the tab key autocomplete it for us),
and Vim will open the file. In total, we have to enter only the following
keystrokes:

:edit %:h<Tab>M<Tab><Tab>

The %:h expansion is so useful that you might want to consider creating a
mapping for it. Check out Easy Expansion of the Active File Directory, on
page 101, for a suggestion.


Easy Expansion of the Active File Directory

Try sourcing this line in your vimrc file:

cnoremap <expr> %% getcmdtype() == ':' ? expand ('%:h').'.' : '%%'

Now when we type %% on Vim's : command-line prompt, it automatically expands
to the path of the active buffer, just as though we had typed %h<Tab>. Besides
working nicely with :edit, this can come in handy with other Ex commands such
as :write, :saveas, and :read.

For more ideas on how to use this mapping, see the Vimcasts episode on the 
:edit command.


                                                    Tip 43
Open a File by Its Filename Using ':find'

The :find command allows us to open a file by its name without having to
provide a fully qualified path. To exploit this feature, we first have to
configure the 'path' setting.

We can always use the :edit command to open a file by providing its full 
path. But what if we're working on a project where the files are nested
a few directories deep? Entering the full path every time we want to open
a file can get tiresome. That's where the :find command comes in.


Preparation

We'll use the files/mvc directory to demonstrate. The source files are
distributes with this book. In the shell, we'll launch Vim from the 
files/mvc directory:

$ cd code/files/mvc
$ vim index.html

Let's see what happens if we attempt to use the :find command right now:

:find Main.js
E345: Can't find file "Main.js" in path

The error message tells us that no Main.js file can be found in the path. 
So let's do something about it.


Configure the 'path'

The 'path' option allows us to specify a set of directories inside of which
Vim will search when the :find command is invoked (see :h 'path'). In our
case, we want to make it easier to look up files in the app/controllers
and app/view directories. We can add these to our path simply by running 
this:

:set path+=app/**

The ** wildcard matches all subdirectories beneath the app/ directory.
We discussed wildcards in Populate the Argument List, on page 87, but the
treatment of * and ** is slightly different in the context of the 'path'
setting (see :h file-searching). The wildcards are handled by Vim rather
than by shell. 


Smart Path Management with rails.vim

Tim pope's rails.vim plusin does some clever things to make navigating
around a Rails project easier. The plugin automatically configures the 
'path' setting to include all the directories found in a conventional 
Rails project. This means that we can use the :find command without having
to worry about setting up the 'path'.

But rails.vim doesn't stop there. It also provides convenience commands,
such as :Rcontroller, :Rmodel, :Rview, and others. Each of these acts as
a specialized version of the :find command, scoping its search to the
corresponding directory.


Use ':find' to Look up Files by Name

Now that we've configured our 'path', we can open files in the directories
we specified by providing just their filename. For example, if we wanted
to open the app/controllers/Navigation.js file, we could enter this command:

:find Navigation.js

We can use the <Tab> key to autocomplete filenames, so in fact we can get 
what we want by typing as little as :find nav<Tab> followed by the Enter
key.

You might be wondering what happens if the specified filename is not 
unique. Let's find out. In our demo codebase, we have two files named
Main.js: one is in the app/controllers directory and the other is in
app/views.

:find Main.js<Tab>

If we type out the Main.js filename and then hit <Tab>, Vim expands the
entire path of the first full match: ./app/controllers/Main.js. Press
<Tab> a second time, and the next matching filepath  takes its place, in
this case ./app/view/Main.js. When we press the Enter key, Vim will use
the entire filepath if it has been expanded or the first full match if no
<Tab> expansion has been performed.

You may observe silightly different tab-completion behavior if you have
changed the 'wildmode' setting form its default value of full. Refer to
Tip 32, Tab-Complete Your Ex Commands, on page 67, for more details.


                                                Tip 44
Explore the File System with netrw

In addition to letting us view (and edit) the contents of a file, Vim also
lets us view the contents of a directory. The netrw plugin, included in the
Vim distribution, allows us to explore the file system.


Preparation

The functionality described in this tip is not implemented in Vim's core
source code but in a plugin called netrw. This plugin comes as standard
with the Vim distribution, so we don't have to install anything, but we
do need to make sure that Vim is configured to load plugins. These line of
configuration are the minimum requirement for your vimrc file:

essential.vim
set nocompatible
filetype plugin on


Meet netrw --Vim's Native File Explorer

If we launch Vim with the path to a directory rather than a file, it will
start up with a file explorer window:

$ cd code/file/mvc
$ ls 
app app.js  index.html  lib
$ vim .

The screenshot on page 105 shows how the file explorer looks. It's a 
regular Vim buffer, but instead of showing the contents of a file, it 
represents the contents of a directory.

We can move the cursor up and down using the k and j keys. When we press
the <CR> key, it opens the item under the cursor. If the cursor is 
positioned on a directory, the explorer window is redrawn to show the
contents of that directory. If the cursor is positioned on a filename,
the file is loaded into a buffer in the current window, replacing the
file explorer. We can open the prarent directory by pressing the - key
or by positioning the cursor on the .. item and pressing <CR>.

We're not limited to navigating the directory listing with j and k keys.
We can use all of the motions that are available to us in a regular Vim
buffer.

For example, if we wanted to open the index.html file, we could search
for /html<CR>, putting our cursor right where we need it.


Opening the File Explorer

We can open the file explorer window with the :edit {path} command by
supplying a directory name (instead of a filename) as the {path} argument.
The dot symbol stands for the current working directory, so if we run the
:edit . command, we can bring up a file explorer for the project root.

If we wanted to open a file explorer for the directory of the current file,
we could do so by typing :edit %:h (see Open a File Relative to the Active
File Directory, on page 101, for an explanation). But the netrw plugin
provides a more convenient way with the :Explore command (see :h :Explore).

Both of these commands can be abbreviated. Instead of typing out :edit .,
we can get away with just :e. --we don't even need the space before the dot.
And :Explore can be truncated right down to :E. This table summarizes the 
long and shorthand forms of these commands:

Ex Command      Shorthand   Effect
:edit .         :e.         Open file explorer for current working directory
:Explore        :E          Open file explorer for the directory of the active
                             buffer

In addition to :Explore, netrw also provides :Sexplore and :Vexplore commands,
which open the file explorer in a horizontal split window or vertical split 
window, respectively.


Working with Split Windows

The classic GUI for a text editor presents the file explorer in a 
sidebar, sometimes known as the project drawer. If you're used to this
kind of interface, then it might seem strange that Vim's :E and :e. commands
behave the way they do by replacing the contents of the current window with
a file explorer. ThereUs a good reason for this: it works well with split
windows.

Consider the layout in the first frame of this image:

Here we see three split windows, each displaying a different buffer. 
Let's imagine for a moment that a project drawer containing a file
explorer was bolted to the side of Vim's interface. If we want to open
a file by clicking its name in the project drawer, where would it open?

The window labeled C is active (as indicated by the shading), so that
would seem to be the natural target. But the relationship between the
project drawer and the active window is not immediately apparent. It would
be easy to lose track of which window was active, leading to a surprise
result when, on selecting a file from the project drawer, it didn't open
where you expected it to.

Now let's remove our imaginary project drawer from this scenario and consider
the way it actually works in Vim. If we run the :Explore command, the active
window is replaced with a file explorer, as illustrated by frame 2 of the
figure. There can be no doubt that when a file is selected it will load in
the same window.

Think of each window as a playing card. One side of the card shows the
contents of a file, and the other side shows the fiel explorer. When
we run the :Explore command, the card for the active window flips over
to show the side with the file explorer (frame 2 of the figure). After
choosing the file we want to edit, we press <CR> and the card flips over
again, this time showing the contents of the file that we just selected
(frame 3 of the figure). After summoning the file explorer view, if we 
decide that we want to switch back to the buffer we were already editing,
we can do so using the <C-^> command.

In a sense, we could say that Vim's windows have two modes: one for working
with files and one for working with directories. This model works together
with Vim's split window interface perfectly, whereas the notion of a project
drawer doesn't really fit.


Doing More with netrw

The netrw plugin doesn't just let us explore the file system. We can create
new files (:h netrw-%) or directories (:h netrw-d), rename existing ones
(:h netrw-rename), or delete them (:h netrw-del). For a demonstration,
watch episode 15 of Vimcasts.

We haven't even touched on the killer feature that gives the plugin its
nema: netrw makes it possible to read and write files across a network.
The plugin can use many protocols, including scp, ftp, curl, and wget,
depending on what's available on your system. To find out more, look up
:h netrw-ref.


                                                    Tip 45
Save Files to Nonexistent Directories

Vim is happy to let us edit a buffer whose path includes directories that
don't exist. It's only when we attempt to write the buffer to a file that
Vim's objects. Here's a quick tip on how to deal with this situation.

The :edit {file} command is most commonly used to open a file that already
exists. But if we specify a filepath that doesn't correspond to an existing
file, then Vim will create a new empty buffer. If we press <C-g>, we'll see
that the buffer is labeled as "new file" (the <C-g> command echoes the name
and status of the current file: see :h ctrl-G). When we run the :write
command, Vim will attempt to write the contents of that buffer to a new file
using the filepath that was specified when the buffer was created.

If we run :edit {file} and specify a filepath that contains nonexistent
directories, things can get a little awkward:

:edit madeup/dir/doesnotexist.yet
:write
"makeup/dir/doesnotexist.yet" E212: Can't open file for writing

In this case, the madeup/dir directories do not exist. Vim creates a new
buffer anyway, but this time it's labeled as "new DIRECTORY". It's only
when we attempt to write the buffer to disk that Vim raises an error.

We can remedy this situation by calling the external mkdir program:

:!mkdir -p %:h
:write

The -p flag tells mkdir to create intermediate directories. See Open a
File Relative to the Active File Directory, on page 101, for an 
explanation of what the %:h characters stand for.


                                            Tip 46
Save a File as the Super User

Running Vim as the super user isn't normal, but sometimes we have to save
changes to a file that requires sudo permission. We can do so without
restarting Vim by delegating the task to a shell process and running that
with sudo.

This tip may not work in GVim and certainly won't work on Windows. It does
work on Unix systems when you run Vim inside a terminal, which is a common
enough scenario to make thip tip worthy of inclusion.

Let's use the /etc/hosts file to demonstrate. The file is owned by root,
but we're logged in with username "drew", so we have permission only to
read this file

$ ls -al /etc/ | grep hosts
-rw-r--r--      1 root wheel    634     6 Apr  15:59 hosts
$ whoami
drew

We'll open up the file in Vim as user drew:

$ vim /etc/hosts

The first thing to note is that if we press <C-g> to view the file status,
Vim labels it as [readonly].

Let's try to make a change and see what happens. We'll run the Go commands
to add a blank line at the end of the file. Vim echoes a message that reads
"W10: Warning: Changing a readonly file." Consider this a friendly reminder
rather than an absolute rule. After showing the message, Vim proceeds by
making the change anyway.

Vim won't prevent us from making changes to a readonly buffer, but it will
prevent us from saving the changes to disk in the usual manner:

:write
E45: 'readonly' option is set (add ! to override)

Let's follow the advice in the message and repeat the command with a 
trailing bang symbol (which can be read as "This time I mean it!"):

:write!
"/etc/hosts" E212: Can't open file for writing

The problem here is that we don't have permission to write the /etc/hosts 
file. Remember: it's owned by root, and we're running Vim as user drew.
The remedy is this strange-looking command:

:w !sudo tee % > /dev/null
Password:
W12: Warning: File "hosts" has changed and the buffer was changes in Vim as 
well
[O]k, (L)oad File, Load (A)ll, (I)gnore All:

Vim requires interaction from us in two ways: first we have to enter
the password for user drew (look away while I type it); then Vim warns
us that the file has changes and prompts us with a menu of options. I
recommend pressing l to load the file back into the buffer.

How does it work? The :write !{cmd} command sends the contents of the
buffer as standard input to the specified {cmd}, which can be any external
program (see :h :write_c). Vim is still running as user drew, but we can
tell our external program process to operate as the superuser. In this case,
the tee utilily is executed with sudo permissions, which means that it can
write to the /etc/hosts file.

The % symbol has special meaning on Vim's command line: it expands to 
represent the path of the current buffer (see :h :_%), in this case
/etc/hosts. So we can expand the final part of this command to read as
follows: tee /etc/hosts > /dev/null. This command receives the contents
of the buffer as standard input, using it to overwrite the contents of the
/etc/hosts file." E212: Can't open file for writing

The problem here is that we don't have permission to write the /etc/hosts 
file. Remember: it's owned by root, and we're running Vim as user drew.
The remedy is this strange-looking command:

:w !sudo tee % > /dev/null
Password:
W12: Warning: File "hosts" has changed and the buffer was changes in Vim as 
well
[O]k, (L)oad File, Load (A)ll, (I)gnore All:

Vim requires interaction from us in two ways: first we have to enter
the password for user drew (look away while I type it); then Vim warns
us that the file has changes and prompts us with a menu of options. I
recommend pressing l to load the file back into the buffer.

How does it work? The :write !{cmd} command sends the contents of the
buffer as standard input to the specified {cmd}, which can be any external
program (see :h :write_c). Vim is still running as user drew, but we can
tell our external program process to operate as the superuser. In this case,
the tee utilily is executed with sudo permissions, which means that it can
write to the /etc/hosts file.

The % symbol has special meaning on Vim's command line: it expands to 
represent the path of the current buffer (see :h :_%), in this case
/etc/hosts. So we can expand the final part of this command to read as
follows: tee /etc/hosts > /dev/null. This command receives the contents
of the buffer as standard input, using it to overwrite the contents of the
/etc/hosts file.

Vim detects that the file has been modified by an external program. 
Usually that would mean that the contents of the buffer and the file were
out of sync, which is why Vim prompts us to choose whether we want to keep
the version in the buffer or load the version on disk. In this case, the
file and buffer happen to have the same contents.



                        Part III

                Getting Around Faster


        Motions are some of the most important commands
        for operating Vim. Not only do they let us move our
        cursor around, but when used in Operator-Pending
        mode, they also allow us to specify the range of
        text on which an operation will act. We'll meet some
        of the most useful motions in this part of the book.
        allow us to quickly navigate between files.



                                                        CHAPTER 8
                                    Navigate Inside Files with Motions

Vim provides many ways of moving around within a document as well as commands
for jumping between buffers. In this chapter we'll focus on motions, which
allow us to move around within a document.

Perhaps the simplest way of moving around is using the cursor keys. Vim 
allows us to navigate up, down, left and right without moving our hands
from the home row, as we'll see in Tip 47, Keep Your Fingers on the Home
Row, on page 114. That's a start, but there are quicker ways of moving
around: Tip 49, Move Word-Wise, on page 118, shows how to move a word at
a time: Tip 50, Find by Character, on page 120, shows how to move with
precision to any character within the current line; and Tip 51, Search
to Navigate, on page 124, shows how to use the search command for getting
around.

Motions are not just for navigating around a document. They can also be used
in Operator-Pending mode to perform real work, as discussed in Tip 12, 
Combine and Conquer, on page 24. Throughout this chapter, we'll study
examples of how motions can be used in combination with operator commands.
The stars of Operator-Pending mode are text objects, on page 126, and
Tip 53, Delete Around, or Change Inside, on page 129.

Vim has a vast number of motions. We can't cover them all in this chapter,
so I recommend that you look up the :h motion.txt section of Vim's 
documentation for a complete reference. Set yourself the goal of adding
a couple of motions to your repertoire each week.


                                            Tip 47
Keep Your Fingers on the Home Row

Vim is optimized for the touch typist. Learn to move around without
removing your hands from the home row, and you'll be able to operate
Vim quicker.

The first thing you learn as a touch typist is that your fingers should
rest on the home row. On a Qwerty keyboard, that means the left-hand fingers
rest on a ,s ,d and f, while the right-hand fingers rest on j, k, l, and ;
keys. When poised in this position, we can reach for any other key on the
keyboard without having to move our hands or look at our fingers. It's the
ideal posture for touch typing.

Just as with any other text editor, Vim lets us use the arrow keys to move
the cursor around, but it also provides an alternative by way of the h, j, k
, and l keys. They work as follows:

Command     Move cursor
h           One column left
l           One column right
j           One line down
k           One line up

Admittedly, these cursor motions are not aas intuitive to use as the
arrow keys. The j and k keys are side by side, making it difficult to
rememer which goes up and which goes down. And the l key doesn't move
left, it moves right! The keys are assigned this way for historical reasons,
so don't go looking hard for a logical pattern.

Here are a few pointers that might help if you're struggling to remember
which key does what. The letter j sort of looks like an arrow pointing
downward. On a Qwerty keyboard, the h and l keys are positioned to the left
and right each other, mirroring the direction in which they move the cursor.

Although h, j, k, and l may seem unintuitive at first, learning to use them
is worth your while. To reach for the arrow keys, you have to move your hand
away from tis resting place on the home row. Because the h, j, k, and l keys
are all within easy reach, you can move Vim's cursor without having to move
your hand.

That might sound like a trival saving, but it adds up. Once you've acquired
the habit of using h, j, k, and l to move around, using any other editor
that depends on the arrow keys will feel strange. You'll wonder how you put
up with it for so long!


Leave Your Right Hand Where It Belongs

On a Qwerty keyboard, the j, k, and l keys fall directly beneath the
index, middle, and ring fingers of the right hand. We use the index finger
to press the h key, but we have to reach for it. Some people see this as
a problem, and as a solution they recommend shifting your entire right
hand one step to the left so that h, j, k, and l are each covered by a
finger. Please don't do that.

As we'll see throughout the rest of this chapter, Vim provides much
quicker ways of moving around. You're wasting keystrokes if you press
the h key more than two times in a row. When it comes to moving 
horizontally, you can get around quicker using word-wise or character
search motions (see Tip 49, Move Word-Wise, on page 118, and Tip 50,
Find by Character, on page 120).

I use the h and l keys for off-by-one errors, when I narrowly miss my
target. Apart from that, I hardly touch them. Given how little I use the
h key, I'm happy to have to stretch for it on a Qwerty keyboard. On the
flip side, I use the character search commands often (see Tip 50, Find by
character, on page 120), so I'm pleased that the ; key rests comfortably
beneath my little finger.


Break the Habit of Reaching for the Arrow Keys

If you're finding it difficult to break the habit of using the arrow keys,
try putting this in your vimrc file:

motions/disable-arrowkeys.vim
noremap <Up> <Nop>
noremap <Down> <Nop>
noremap <Left> <Nop>
noremap <Right> <Nop>

This maps each of the arrow keys to do nothing. Each time you reach for
the arrow keys, you'll be reminded that you should have left your hand on
the home row. It won't take long to get the hang of using h, j, k, and l
instead. 

I don't recommend keeping those mapping in your vimrc forever, just long
enough to get into the habit of using h, j, k, and l. After that, you could
always consider mapping the arrow keys to something more useful.


                                                Tip 48
Distinguish Between Real Lines and Display Lines

Avoid frustrationby learning the difference between real lines and display
lines. Vim lets us operate on both.

Unlike many text editors, Vim makes a distinction between real lines and
display lines. When the 'wrap' setting is enabled (and it's on by default),
each line of the text that exceeds the width of the window will display as
wrapped, ensuring that no text is truncated from view. As a result, a single
line in the file may be represented by multiple lines on the display.

The easiest way to tell the difference between real lines and display lines
is by enabling the 'number' setting. Lines that begin with a number 
correspond to the real lines, which may span one or more display lines.
Each time a line is wrapped to fit inside the window, it begins without
a line number. This screenshot shows a Vim buffer containing three real
lines (numbered) and nine display lines:

Understanding the difference between real and display lines is important
because Vim provides motions for interacting with both kinds. The j and
k commands move down and up by real lines, whereas the gj and gk commands
move down and up by display lines.

Consider our screenshot. Suppose that we wanted to move the cursor 
upward to position it on the word "vehicula". Our target is one display
line above the cursor, so we could get where we want to go by pressing
gk. The k key would move up by a real line, placing our cursor on the
word "ac", which is not what we want in this case.

Vim also provides commands for jumping directly to the first or last
character of a line. This table summarizes the commands for interacting
with real and display lines:

Command     Move Cursor
j           Down one real line
gj          Down one display line
k           Up one real line
gk          Up one display line
0           To first character of real line
g0          To first character of display line
^           To first nonblank character of real line
g^          To first nonblank character of display line
$           To end of real line
g$          To end of display line

Note the pattern :j, k, 0, and $ all interact with real lines, while
prefixing any of these with g tells Vim to act on display lines instead.

Most other text editors have no notion of the concept of real lines, and
they provide the means to interact with display lines only. When you start
out, it can be frustrating to discover that Vim seems to treat lines
differently. When you learn to use the gj and gk commands, you'll appreciate
that j and k may let you cover more distance with fewer keystrokes.


Remap Line Motion Commands

If you would prefer to have the j and k keys operate on display lines rather
than on real lines, you can always remap them. Try putting these lines into
your vimrc file:

motions/cursor-maps.vim
nnoremap k gk
nnoremap gk k
nnoremap j gj
nnoremoap gj j

These mappings make j and k move down and up by display lines, while gj 
and gk would move down and up by real lines (the opposite of Vim's default
behavior). I wouldn't recommend using these mappings if you have to work
with Vim on many different machines. In that case, getting used to Vim's
default behavior would be better.


                                            Tip 49
Move Word-Wise

Vim has two speeds for moving backward and forward word-wise. Both allow
for a more rapid traversal than moving by one column at a time.

Vim provides a handful of motions that let us move the cursor forward and
backward by one word at a time (see :h word-motions). They're summarized in
this table:

Command     Move Cursor
w           Forward to start of next word
b           Backward to start of current/previous word
e           Forward to end of current/next word
ge          Backward to end of previous word

We can think of these motions as coming in pairs: the w and b commands
both target the start of a word, while the e and ge commands target the
end of a word. w and e both advance the cursor forward, while b and ge
move the cursor backward. This matrix of word-wise motions is illustrated
here:

Trying to memorize all four of these commands isn't easy, and I wouldn't
recommend it. Start off by using the w and b commands (think of them as
(for-)word and back-word if you need a mnemonic). You should find that
moving back and forward a word at a time is considerably faster than using
h and l to move a column at a time.

The e and ge commands complete the set, but you can get by without them at
first. Eventually you'll notice that sometimes it would be useful to go
directly to the end of the current word in a single move. For example, 
suppose that we want to turn the word "fast" into "faster" in this excerpt:

Keystrokes      BufferContents
{start}         Go |fast.
eaer<Esc>       Go faste|r.

Taken together, the ea commands can be read as "Append at the end of the
current word". I use ea often enough that it feels to me like a single
command. Occasionally useful, the gea command can be read as "append at the
end of the previous word".


Known Your Words from Your WORDS

We've been talking a lot about words, but so far we haven't pinned down
what a word actually is. Vim provides two definitions and distinguishes
between them calling one a "word" and the other a "WORD". Each word-wise
motion we met earlier has a WORD-wise equivalent, including W, B, E, and
gE.

A word consists of a sequence of letters, digits, and underscores, or as a
sequence of other nonblank characters separated with whitespace (see :h
word). The definition of a WORD is simpler: it consists of a sequence of
nonblank characters separated with whitespace (see :h WORD).

Ok, but what does that actually mean? The details we can leave to Vim's
implememtors. As users, we can think of them in simpler terms: WORDS are
bigger than words! Look at this text and quickly count the number of words:

e.g. we're going too slow

Did you count five or ten (or something in between)? That example contains
five WORDS and ten words. The periods and apostrophes count as words, so if
we try to advance through this text with the w command, it'll be slow going:

keystrokes      BufferContents
{start}        |e.g. we're going too slow
wwww            e.g. |we're going too slow
www             e.g. we're |going too slow

If we move WORD-wise insteat, we make progress with fewer keystrokes:

keystrokes      BufferContents
{start}        |e.g. we're going too slow
W               e.g. |we're going too slow
W               e.g. we're |going too slow

In this example, the WORD-wise motions appear to be the better choise, but
that won't be true every time. Sometimes we'll want to act on "we" as a 
word. For example, if we wanted it to read "you" instead, we would do this:

keystrokes      BufferContents
{start}         e.g. |we're going too slow
cwyou<Esc>      e.g. |you're going too slow

Other times, we might prefer to treat "we're" as a WORD. For example, if we
wantes to change it to read "it's" instead, we would do this:


keystrokes      BufferContents
{start}         e.g. |we're going too slow
cWit's<Esc>      e.g. |it's going too slow

Use WORD-wise motions if you want to move faster, and use word-wise
motions if you want a more fine-grained traversal. Play around with them, 
and you'll get a feel for when to use words and when to use WORDS. You can
develop an intuition for these things without fully understanding the
implementation details.


                                            Tip 50
Find by Character

Vim's character search commands allow us to move quickly within a line, 
and they work beautifully in Operator-Pending mode.

The f{char} command is one of the quickest methods of moving around in
Vim. It searches for the specified character, starting with the cursor
position and continuing to the end of the current line. If a match is 
found, then the cursor advances to the specified character. If no match
is found, then the cursor stays put (see :h f).

That may sound complex, but it's quite simple in practice. Observe:

keystrokes      BufferContents
{start}        |Find the first occurrence of {char} and move to it.
fx             |Find the first occurrence of {char} and move to it.
fo              Find the first |occurrence of {char} and move to it.

In this case, the fx command does nothing. Vim searches forward for an
occurrence of the "x" character, but no matches are found, so the cursor
doesn't move. The fo command finds an occurrence of the "o" character, so
the cursor is positioned on top of the first match.

If we need to position our cursor at the start of the word "occurrence",
there's no way we can do it with fewer than two keystrokes. The f{char}
command is efficient, and when it works as well as it does in this example,
it feels as though Vim is reading our minds.

But the f{char} command doesn't always work out so well. Suppose that we
wanted to position our cursor on the "c" at the start of the word {char}.
Watch what happens when we use the fc command:

keystrokes      BufferContents
{start}        |Find the first occurrence of {char} and move to it.
fc              Find the first o|ccurrence of {char} and move to it.
;               Find the first oc|currence of {char} and move to it.
;               Find the first occurren|ce of {char} and move to it.
;               Find the first occurrence of {|char} and move to it.

The "c" character occurs several times on this line, so this time we don't
make a direct hit on our target. It takes a few attempts to move the cursor
to the position where we want it. Luckily we don't have to explicitly repeat
the fc command. Vim keeps track of the most recent f{char} search, and we can
repeat it using the ; command (see :h ;). In this example, we have to press
; three times to maneuver the cursor into position.

The f{char} and ; commands make a powerful combination, and we can cover a
lot of distance with very few keystrokes. But where the cursor will end up
isn't always obvious. As a result, it's easy to get trigger-happy with the
; key, and occasionally we'll miss our target. For example, suppose that we
want to place the cursor at the start of the word "of":

keystrokes      BufferContents
{start}        |Find the first occurrence of {char} and move to it.
fo              Find the first |occurrence of {char} and move to it.
;;              Find the first oc|currence of {char} and m|ove to it.
,               Find the first occurrence |of {char} and move to it.

Having accidentally overshot our mark, we can back up using the , command.
This repeats the last f{char} search but in the opposite direction (see :h
,). Remember our mantra from Tip 4, Act, Repeat, Reverse, on page 8:act,
repeat, reverse. I think of , as a safety net for those times when I get
overzealous with the ; key.


Don't Throw Away the Reverse Character Search Command

Vim assigns a function to almost every key on the keyboard. If we want to
create our own custom mappings, which keys should we bind them to? Vim 
provides the <Leader> key as a namespace for our own user-defined commands.
Here is how we can create our own custom mappings using <Leader>:

noremap <Leader>n nzz
noremap <Leader>N Nzz

The default leader key is \, so we could trigger these custom mappings by
pressing \n and \N. If you want to know what these mappings do, look up
:h zz.

On some keyboards, the \ command is inconvenient to reach, so Vim makes it
easy to set the leader key to something else (see :h mapleader). A common
choise is to set the comma key as leader. If you take this route, I strongly
recommend mapping the reverse character search command to another key. Here's
an example:

let mapleader=","
noremap \ ,

The ; and , commands complement each other. If you take one of them away,
then the whole family of character search commands becomes much less useful.


Character Searches Can Include or Exclude the Target

The f{char}, ;, and , commands are part of a set of character-search
commands. This table lists them all:

Command     Effect
f{char}     Forward to the next occurrence of {char}
F{char}     Backward to the previous occurrence of {char}
t{char}     Forward to the character before the next occurrence of {char}
T{char}     Backward to the character after the previous occurrence of {char}
;           Repeat the last character-search command
,           Reverse the last character-search command

Think of the t{char} and T{char} commands as searching till the specified
character. The cursor stops one character before {char}, whereas the 
f{char} and F{char} commands position the cursor on top of the specified
character.

It's not immediately obvious why you would want both kinds of character
search. This example demonstrates them in action:

Keystrokes      BufferContents
{start}         |I've been expecting you, Mister Bond.
f,               I've been expecting you|, Mister Bond.
dt.              I've been expecting you|.

To begin with, we want to position our cursor directly on top of the
comma symbol. For this we can use the f, command. Next we want to delete
all of the text until the end of the sentence, but not including the period
symbol itself. This time, the dt. command does the job.

Alternatively, we could have used dfd, which would delete everything from
the cursor position to the last letter of the word "Bond". The end result
is the same either way, but I find that dt. requires less concentration.
Deleting through the letter "d" is not a common pattern, whereas deleting
the last clause of a sentence is something we do often enough that we can
treat f,dt. as a finger macro.

In general, I tend to use f{char} and F{char} in Normal mode when I want
to move the cursor quickly withing the current line, whereas I tend to use
the t{char} and T{char} character search commands in combination with 
d{motion} or c{motion}. To put it another way, I use f and F in Normal mode,
and t and T in Operator-Pending Mode. Refer to Tip 12, Combine and Conquer,
on page 24 (and Meet Operator-Pending Mode, on page 27), for more details.


Think Like a Scrabble Player

The character search commands can be highly economical with keystrokes,
but thier efficiency varies depending on our choice of target. As any
Scrabble player can tell you, some letters appear more frequently than
others. If we can make a habit of choosing less common characters for use
with the f{char} command, then we'll be more likely to strike our target
with a singel move.

Suppose that we wanted to delete the only adjective from this sentence:

|Improve your writing by deleting excellent adjectives.

What motion should we use to position our cursor on the word "excellent"?
If we target the first letter by pressing fe, then we have to follow up by
pressing ;;; to skip all of the obstacles in between. A better choice 
would be fx, which gets us where we want to go with a single move. From
there, we can delelte the word with the daw command (for more details about
aw, see Tip 53, Delete Around, or Change Inside, on page 129).

Take a look at the text that you're reading. It's composed almost entirely
of lowercase letters. Capital letters are much rarer, and so too are 
punctuation marks. When using the character search commands, it's better
to choose target characters with a low frequency of occurrences. With 
practice you'll learn to spot them.


                                            Tip 51
Search to Navigate

The search command allows us to rapidly cover distances both large and
small with very few keystrokes.

The character search commands (f{char}, t{char}, and so on) are fast and
lightweight, but they have limitations. They can only serch for a single
character at a time, and they can only operate within the current line.
If we need to search for more than one character or move beyond the current
line, then we can use the search command instead.

Suppose that we want to position our cursor on the word "takes" in this
sample:

mortions/serch-haiku.txt
serch for your target
it only takes a moment
to get where you want

We could do so by searching for the word: /takes<CR>. It onlu occurs once
in this short sample, so that would be sure to get us where we want to go
in single move. But let's see if we can we do it with even fewer keystrokes:

Keystrokes      BufferContents
{start}"takes" in this
sample:

mortions/serch-haiku.txt
serch for your target
it only takes a moment
to get where you want

We could do so by searching for the word: /takes<CR>. It onlu occurs once
in this short sample, so that would be sure to get us where we want to go
in single move. But let's see if we can we do it with even fewer keystrokes:

Keystrokes      BufferContents
---------------------------------------
{start}        |serch for your target
                it only takes a moment
                to get where you want
---------------------------------------
/ta<CR>         serch for your |_ta_rget
                it only _ta_kes a moment
                to get where you want
-----------------------------------------
/tak<CR>        serch for your target
                it only |_tak_es a moment
                to get where you want

Searching for the two-letter string "ta" gets two hits, but the three-letter
stirng "tak" has one unique hit. In this example, the search motion makes a
short hop, but in a large document we can use this technique to cover great
distances with few keystrokes. The search command is a very economical way
to move around.

Even if we had searched for the two-letter "ta" fragment and ended up in the
wrong place, we could jump to the next occurrence by repeating the previous
serch with the n command. Also, if we pressed the n key too many times, we 
could back up again with the N command. The mantra from Tip 4, Act, Repeat,
Reverse, on page 8, should be becoming familiar by now: act, repeat, reverse.

In the previous tip, we saw that the fe command was rarely useful because 
the letter e is so common. We can get around this shortcoming by searching
for a string of two or more letters in sequence. Although e may appear many
times in the English language, only a fraction of those occurrences are
succeeded immediately by the letter r. It's surprising how often we can
jump to any word of our choice just by searching for the first few 
characters.

In our "takes" example, I enabled the 'hlsearch' feature to highlight
the search matches. When searching for a short string, we'll often find
multiple matches scattered across the document. Results can get unsightly
when the 'hlsearch' option enabled, so you might want to disable this
feature if you make a habit of using the search command to navigate (it's
off by default). However, the 'incsearch' option is very useful in this
use case. Refer to Tip 82, Preview the First Match Before Execution, on
page 205, for more details.


Operate with a Search Motion

We're not limitied to using the search command in Normal mode. We can use
it from Visual and Operator-Pending modes just as well to do real work.
For example, suppose that we wanted to delete the text "takes time but
eventually" from this phrase:

keystrokes      BufferContents
---------------------------------------------
v               This phrase |takes time but
                eventually gets to the point.
---------------------------------------------
/ge<CR>         This phrase _takes time but
                eventually |g_ets to the point.
---------------------------------------------
h               This phrase _takes time but
                eventually_| gets to the point.
---------------------------------------------
d               This phrase gets to the point.

To begin with, we press v to switch to Visual mode. Then we can extend
the selection by searching for the short "ge" string, which puts the
cursor where we want it in a single bound. Well, almost --we have an
off-by-one error. The selection includes the "g" at the start of the
word, but we don't want to delete that. We'll use h to back up one
character. Then, having defined our selection, we'll delete it with the d
command.

Here's an even quicker way of doing the same thing:

keystrokes      BufferContents
---------------------------------------------
v               This phrase |takes time but
                eventually gets to the point.
---------------------------------------------
d/ge<CR>         This phrase gets to the point.

Here, we use the /ge<CR> search motion to tell the d{motion} command what
to delete. The search command is an exclusive motion. That means that even
though our cursor ends up on the "g" at the start of the word "gets", that
character is excluded from the delete operation (see :h exclusive).

By staying out of Visual mode, we've cut out two unnecessary keystrokes
(see also Tip 23, Prefer Operators to Visual Commands Where Possible, on
page 45). It takes a bit of getting used to, but combining the d{motion} 
operator with the search motion is a power move. Use it to amaze your friends
and coworkers.


                                                Tip 52
Trace Your Selection with Precision Text Objects

Text objects allow us to interact with parentheses, quotes, XML tags, and
other common patterns that appear in text

Take a look at this code sample:

motions/template.js
var tpl = [
    '<a href="{url}">{titile}</a>'
]

Each opening { character is balanced by a closing } character. The same is
true of [ and ], < and >, and the opening and closing HTML tags, <a> and 
</a>. This sample also contains single and double quotation marks, which
come in pairs.

Vim understands the structure of these well-formed patterns, and it allows
us to operate on the regions of text that they delimit. Text objects define
regions of text by structure (see :h text-objects). With only a couple of 
keystrokes, we can use these to select or operate on a chunk of text.

Suppose that our cursor was positioned inside a set of curly braces and
we wanted to visually select the text inside the {}. Press vi}:

Keystrokes      BufferContents
-------------------------------------------------------
{start}         var tpl = [
                    '<a href="{u|rl}">{titile}</a>'
                ]
-------------------------------------------------------
vi}             var tpl = [
                    '<a href="{_url_|}">{titile}</a>'
                ]
-------------------------------------------------------
a"              var tpl = [
                    '<a href=_"{url}"_|>{titile}</a>'
                ]
-------------------------------------------------------
i>              var tpl = [
                    '<_a href="{url}"_|>{titile}</a>'
                ]
-------------------------------------------------------
it              var tpl = [
                    '<a href="{url}">_{titile}_|</a>'
                ]
-------------------------------------------------------
at              var tpl = [
                    '_<a href="{url}">{titile}</a>_|'
                ]
-------------------------------------------------------
a]              var tpl = _[
                    '<a href="{url}">{titile}</a>'
                ]_|

Normally when we use Visual mode, one end of the selection is anchored to
a particular character, while the other end of the selection is free to move.
When we use motions such as l, w, and f{char}, we can expant or contract the
selection by moving the free end of the visual range.

What's happening here is different. When we press vi}, Vim initiates
Visual mode and then selects all of the characters contained by the {}
braces. Where the cursor is positioned to begin with doesn't matter so long
as it's located somewhere inside a block of curly braces when the i} text
object is invoked.

We can expand the selection again using another text object. For example,
a" selects a range of characters deliited by double quotes. i> selects
everything inside a pair of angle brackets.

Vim's text objects consist of two characters, the first of which is always
either i or a. In general, we can say that the text objects prefixed with i
select inside the delimiters, whereas those that are prefixed with a select
everything including the delimiters. As a mnemonic, think of i as inside and
a as around (or all).

In the previous example, check whether the text object leads with i or a.
In particular, note the difference between it and at. Note, too, that in
this example a] expands the selection to span multiple lines.

A paprtial list of Vim's built-in text objects is summarized in the following
table. In the interests if neatness, some duplicates have been omitted. For
example, i( and i) are equivalent to each other, and so too are a[ and a].
Use which ever style you find most comfortable.

TextObject  Selection               TextObject  Selection
a) or ab    A pair of (parantheses) i) or ib    Inside of (parentheses)
a} or aB    A pair of {braces}      i} or iB    Inside of {braces}
a]          A pair of [brackets]    i]          Inside of [brackets]
a>          A pair of <angle        i>          Inside of <angle 
                brackets>                           brackets>
a'          A pair of 'single       i'          Inside of 'single
                quotes'                             quotes'
a"          A pair of "double       i"          Inside of "double
                quotes"                             quotes"
a`          A pair of `backticks`   i`          Inside of `backticks`
at          A pair of <xml>tags     it          Inside of <xml>tags
                </xml>                              </xml>


Performing Operations with Text Objects

Visual mode makes for a nice introduction to text objects because it's easy
to see what's happning. But text objects reveal their true power when we use
them in Operator-Pending mode.

Text objects are motions themselves: we can't use them to navigate around the
document. But we can use text objects in Visual mode and in Operator-Pending
mode. Remember this: whenever you see {motion} as part of the syntax for a
command, you can also use a text object. Common examples include d{motion},
c{motion}, and y{motion} (see Table 2, Vim's Operator Commands, on page 25, 
for more).

Let's demonstrate using the c{motion} command, which deletes the specified
text and then switches to Insert mode (:h c). We'll use it to replace {url}
with a # symbol, and then again to replace {title} with a placeholder:

Keystrokes		BufferContents
----------------------------------------------------------------------------
{start}			'<a href="{url}">{title}</a>'
ci"#<Esc>		'<a href="#">{title}</a>'
citclick here<Esc>	'<a href="#">click here</a>'

We can read the ci" command as "change inside the double quotes". The cit
command can be read as "change inside the tag". We could just as easily use
the yit command to yank the text from inside the tag, or dit to delete it.


Discussion

Each of these commands requires only three keystrokes, and yet they're 
elegant in spite of this terseness. I would almost go so far as to say that
they are self-documenting. That's because these commands follow the rules of
Vim's simple grammer, which is covered in Tip 12, Combine and Conquer, on 
page 24.

In Tip 50, Find by Character, on page 120, and Tip 51, Search to Navigate, on
page 124, we learned a couple of tricks that allow us to move the cursor with
precision. Whether we're using f{char} to search for a single character or
/target<CR> to search for several characters, the pattern of usage is the
same: we look for a suitable target, take aim, and then fire. If we're good,
we'll hit our target with a single move. These power moves allow us to cover
a lot of ground with little effort.

Text objects are the next level up. If the f{char} and /pattern<CR> commands
are like a flying kick to the head, then text objects are like a scissors
kick that strikes two targets with a single move:


					Tip 53
Delete Around, or Change Inside

Text objects usually come in pairs: one that acts inside the object and
another that acts around the object. In this tip, we'll examine a typical use
case for each kind of text object.

Vim's text objects fall into two categories: those that interact with pairs
of delimiters, such as i), i", and it, and those that interact with chunks of
text, such as words, sentences, and paragraphs. Here's a summary of the 
latter.

Keystrokes	Current...	Keystrokes	Current...
iw		word		aw		word plus space(s)
iW		WORD		aW		WORD plus space(s)
is		sentence	as		sentence plus space(s)
ip		paragraph	ap		paragraph plus blank line(s)


I've labeled the first category as delimited text objects because they begin
and end with matching symbols. Words, sentences, and paragraphs are defined
by boundaries, so I've labeled this category as bounded text objects (Vim's
documentation calls them "block" and "non-block" objects, but I find that to
be an unhelpful distinction).

Let's compare the iw and aw text objects. Using our mnemonic, we can think of
these as acting inside th word or around the word, respectively. But what
does that mean?

The iw text object interacts with everything form the first to the last
character of the current word. The aw text object does the same, but it 
extends the range to include any whitespace characters after or before the
word, if whitespace is present. To see how Vim defines the boundaries of a
word, refer to Tip 49, Move Word-Wise, on page 118.

The distinction between iw and aw is subtle, and it's not immediately obvious
why we need them both, so let's look at a typical us case for each of them.

Suppose that we want to delete the word "excellent" from the followings
sentence. We can do it using the daw command:

Keystrokes	BufferContents
{start}		Improbe your writing by deleting excellent adjectives.
daw		Improbe your writing by deleting adjectives.

This deletes the word plus one space, giving a clean result. If we used diw
instead, them we'd end up with two adjacent spaces, which is probably not
what we want.

Now let's suppose that we want to change the word to something else. This 
time we'll use the ciw command:

Keystrokes	BufferContents
{start}		Improbe your writing by deleting excellent adjectives.
ciwmost<Esc>	Improbe your writing by deleting most adjectives.

The ciw command deletes the word without trimming any whitespace and then
puts us into Insertmode. That's just what we want. If we had used caw 
instead, then we'd end up running words together to read "mostadjectives".
That would be easy enough to mend, but it's better still if we can avoid
the problem altogether.

As a general rule, we could say that the d{motion} command tends to work well
with aw, as, and ap, whereas the c{motion} command works better with iw and
similar.


					Tip 54
Mark Your Place and Snap Back to It

Vim's marks allow us to jump quickly to locations of interest within a 
document. We can set marks manually, but Vim also keeps track of certain
points of interest for us automatically.

The m{a-zA-Z} command marks the current cursor location with the designated
letter (:h m). Lowercase marks are local to each indivisual buffer, whereas
uppercase marks are globally accessible. We'll learn more about them in Tip
59, Snap Between Files Using Global Marks, on Page 141. Vim does nothing to
indicate that a mark has been set, but if you've done in right, then you
should be able to jump directly to your mark with only two keystrokes from
anywhere in the file.

Vim provides two Normal mode commands for jumping to a mark. (Pay attention
--they look similar!) '{mark} moves to the line where a mark was set, 
positioning the cursor on the first non-whitespace character. The `{mark}
command moves the cursor to the exact position where a mark was set, 
restoring the line and the column at once (see :h mark-motions).

If you commit only one of these commands to memory, go with `{mark}. Whether
you care about restoring the exact position or just getting to the right
line, this command will get you there. The only time you have to use the
'{mark} form is in the context of an Ex command (see Tip 28, Execute a
Command on One or More Consecuitive Lines, on page 56).

The mm and `m commands make a handy pair. Respectively, they set the mark
m and jump to it. Swap Two Words, on page 154, shows one example of how they
can be used for a quick mark-then-snap-back maneuver.


Automatic Marks

We can set up to twenty-six lowercase marks per buffer. That's one mark for
each letter of the alphabet, and it's way more than you're ever likely to
need! In Vim's predecessor, vi, there was no such things as Visual mode.
Back then, marks would have been a much more important feature than they are
now. Many of the tasks that would have required a mark in vi can be done in
Vim using Visual mode.

But marks have not become obsolete in Vim; they still have their uses. In 
particular, the marks that Vim sets for us automaticlally can be really 
handy. They include the marks shown in Table 10, Vim's Automatic Marks, on
page 132.

Keystrokes	BufferContents
--------------------------------------------------------------------------
``		Position before the last jump within current file
`.		Location of last change
`^		Location of last insertion
`[		Start of last change or yank
`]		End of last change or yank
`<		Start of last visual selection
`>		End of last visual selection
--------------------------------------------------------------------------
Table 10 --Vim's Automatic Marks

The `` mark complements the jump list (Tip 56, Traverse the Jump List, on
page 135), and we'll see a use for it in the next tip. The `. complements the
change list, which is covered by Tip 57, Traverse the Change List, on page
137.

The start and end of the last visual selection are both recorded
automatically as a marks, so we might even consider Visual mode to be a fancy
interface to the underlying marks feature.


					Tip 55
Jump Between Matching Parentheses

Vim provides a motion that lets us move between opening and closing pairs of
parentheses. By enabling the matchit.vim plugin, we can extend this behavior
to work on pairs of XML tags as well as on keywords in some programming
languages.

The % command lets us jump between opening and closing sets of parentheses
(see :h %). It works with (), {}, and [], as this example demonstrates:

Keystrokes	BufferContents
----------------------------------------------------------------
{start}		console.log([{'a':1},{'b':2}])
%		console.log([{'a':1},{'b':2}])
h		console.log([{'a':1},{'b':2}])
%		console.log([{'a':1},{'b':2}])
l		console.log([{'a':1},{'b':2}])
%		console.log([{'a':1},{'b':2}])

To see how we might use % in practice, let's use this short extract of Ruby:

motion/parentheses.rb
cities = %w{London Berlin New\ York}

Suppose that we want to switch from the %w{London Berlin New\ York} syntax 
to a regular list definition: ["London", "Berlin", "New York"]. We'll have
to switch opening and closing curly braces to square brackets. You might
think that this would be a perfect occasion to use the % motion. You'd be
right, but there's a gotcha!

Let's say that we start off by positioning our cursor on the openign curly
brace and then we press r[ to change it to an opening square bracket. Now 
we've got this strange-looking construct: [London Berlin New\ York}. The
% command only works on well-formed matching parentheses, so we can't use
it to jump to the closing } character.

The trick here is to use the % command before making any changes. When we
use the % command, Vim automatically sets a mark for the location from which
we jumpd. We can snap back to it by pressing ``. Here's a partial solution 
for our example refactoring:

Keystrokes  BufferContents
--------------------------------------------------------------------------
{start}     cities = %w{London Berlin New\ York}
dt{         cities = {London Berlin New\ York}
%           cities = {London Berlin New\ York}
r]          cities = {London Berlin New\ York]
``          cities = {London Berlin New\ York]
r[          cities = [London Berlin New\ York]

Note that in this case, the <C-o> command would work just as well as
the `` motion (see Tip 56, Traverse the Jump List, on page 135). The
surround.vim plugin provides commands that would make this task even
easier. Find out more in Surround.vim, on page 134.


Jump Between Matching Keywords

Vim ships with a plugin called matchit, which enhances the functionality of
the % command. When this plugin is enabled, the % command can jump between
matching pairs of keywords. For example, in an HTML file, the % command would
jump between opening and closing tags. In a Ruby file, it would jump between
class/end, def/end, and if/end pairs.

Even though matchit ships with the Vim distribution, it's not enabled by
default. This minimal vimrc would make Vim autoload the matchit plugin on
startup:

set nocompatible
filetype plugin on
runtime macros/matchit.vim

The enhancements provided by this plugin are very useful, so I'd recommend
enabling it. Consult :h matchit-install for more details.


Surround.vim

One of my favorite plugins is surround.vim by Tim Pope, which makes wrapping
a selection with a pair of delimiters easy. For example, we could put the
words New York in quote marks:

keystrokes      BufferContents
--------------------------------------------------------------------------
{start}     cities = ["London" "Berlin" New\ York]
vee         cities = ["London" "Berlin" New\ York]
S"          cities = ["London" "Berlin" "New\ York"]

The S" command is provided by surround.vim, and it can be read as 
"Surround the seleciton with a pair of double quote marks." We could just
as easily use S) or S} if we wanted to wrap the selection with opening and
closing parentheses or braces.

We can also use surround.vim to change existing delimiters. For example, we
could change {London} to [London] with the sd}] command, which can be read as
"Change surrounding {} braces to [] brackets." Or we could go the other way
with the cs ]} command. It's a powerful plugin --check it out.


                                                        CHAPTER 9
Navigate Between Files with Jumps

As we learned in the previous chapter, motions allow us to move around
withing a file. Jumps are similar, except that they can also move us 
between different files. Vim provides a couple of commands that turn keywords
in the document into a wormhole, allowing us to jump quickly from one part 
of our codebase to another. That might seem disorienting at first, but Vim
always traces our path by leaving a trail that we can easily follow to get
back to where we came from.


                                                    Tip 56
Traverse the Jump List

Vim records our location before and after making a jump and provides a
couple of commands for retracing our steps.

In web browsers, we're used to using the back button to return to pages that
we visited earlier. Vim provides a similar feature by way of the jump list: 
the <C-o> command is like the back button, while the complementary <C-i>
command if lile the forward button. These commands allow us to traverse Vim's
jump list, but what exactly is a jump?

Let's start by making this distinction: motions move around within a file, 
whereas jumps can move between files (although we'll soon see that some 
motion are also classified as jumps). We can inspect the contents of the jump
list by running this command:

:jumps
jump line col file/text
4      12   2 <recipe id="sec.jump.list">
3     114   2 <recipe id="sec.change.list">
2     169   2 <recipe id="sec.gf">
1     290   2 <recipe id="sec.global.marks">
>
Press Enter or type command to continue

Any command that changes the active file for the currentwindow can be 
described as a jump. In the jump list, Vim records the cursor location
before and after running such a command. For example, if we run the :edit
command to open a new file (see Tip 42, Open a File by Its Filepath Using
':edit', on page 99), then we can use the <C-o> and <C-i> commands to jump
back and forth between the two files.

Moving directly to a line number with [count]G counts as a jump, but moving
up or down one line at a time does not. The sentence-wise and paragraph-wise
motions are jumps, but the character-wise and word-wise motions are not. As a
rule of thumb, we could say that long-range motions may be classified as a 
jump, but short-range motions are just motions.

This table summarizes a selection of jumps:

Command                         Effect
--------------------------------------------------------------------------
[count]G                        Jump to line number
/pattern<CR>/?pattern<CR>/n/N   Jump to next/previous occurrence of pattern
%                               Jump to matching parenthesis
(/)                             Jump to start of previous/next sentence
{/}                             Jump to start of previous/next paragraph
H/M/L                           Jump to top/middle/bottom of screen
gf                              Jump to file name under the cursor
<C-]>                           Jump to definition of keyword under the cursor
'{mark}/`{mark}                 Jump to a mark

The <C-o> and <C-i> commands themselves are never treated as a motion. 
This means that we can't use them to expand the reach of a Visual mode 
selection, nor can we use them in Operator-Pending mode. I tend to think of
the jump list as a breadcrumb trail that makes it easy to retrace my steps
through the files that I've visited during the course of an editing session.

Vim can maintain multiple jump lists at the same time. In fact, each separate
window has its own jump list. If we're using split windows or multiple tab
pages, then the <C-o> and <C-i> commands will always be scoped to the jump
list of the active window.


Beware of Mapping the Tab Key

Try pressing <C-i> in Insert mode, and you should find that it has the same
effect as pressing the <Tab> key. That's because Vim sees <C-i> and <Tab> as
the same thing.

Beware that if you attempt to create a mapping for the <Tab> key, it will
also be triggered when you press <C-i> (and vice versa). That may not seem
like a problem, but consider this: if you map the <Tab> key to something 
else, it will overwrite the default behavior of the <C-i> command. Think
carefully about whether that's a worthwhile trade-off. The jump list is much
less useful if you can only traverse it in one direction.

    
                                                    Tip 57
Traverse the Change List

Vim records the location of our cursor after each change we make to a
document. Traversing this change list is simple and can be the quickest
way to get where we want to go.

Have you ever used the undo command followed immediately be redo? The two
commands cancel each other out, but they have the side effect of placing
the cursor on the most recent change. That could be useful if we wanted to
jump back to the part of the document that we edited most recently. It's a
hack, but u<C-r> gets us there.

It turns out that Vim maintains a list of the modifications we make to each
buffer during the course of an editing session. It's called the change list
(see :h changelist), and we can inspect its contents by running the 
following:

:changes
change  line  col  text
     3     1    8  Line one
     2     2    7  Line two
     1     3    9  Line three
>
Press ENTER or type command to continue

This example output show that Vim records the line and column number for
each change. Using the g; and g, commands, we can traverse backward and 
forward through the change list. As a memory aid for g; and g, it may help
remember that the ; and , commands can be used to repeat or reverse the 
f{char} command (see Tip 50, Find by Character, on page 120).


To jump back to the most recent modification in the document, we press g;.
That places the cursor back on the line and column where it ended up after
the previous edit. The result is the same as if we had pressed u<C-r>, 
except that we don't make any transitory changes to the document.


Marks for the Last Change

Vim automatically creates a couple of marks that complement the change list.
The `. mark always references the position of the last change (:h `.), while
the `^ mark tracks The position of the cursor the last time that Insert mode
was stopped (:h `^).

In most scenarios, jumping to the `. mark has the same effect as the g;
command. Whereas the mark can only refer to the position of the most recent
change, the change list stores multiple locations. We can press g; again and
again, and each time it takes us to a location that was recorded eariler in 
the change list.

The `^ mark references the last insertion, which is slightly more specific
than the last change. If we leave Insert mode and then scroll around the
document, we can quickly carry on where we left off by pressing gi (:h gi).
In a single move, that uses the `^ mark to restore the cursor position and
then switches back into Insert mode. It's a great little time saver!

Vim maintains a change list for each individual buffer in an editing session.
By contrast, a separate jump list is created for each window.


                                            Tip 58
Jump to the Filename Under the Cursor

Vim treats filenames in our document as a kind of hyperlink. When configured
properly, we can use the gf command to go to the filename under the cursor.

Let's demonstrate with the jumps directory, from the source file distributed
with this book. It contains the following directory tree:

practical_vim.rb
practical_vim/
    core.rb
    jumps.rb
    more.rb
    motions.rb

In the shell, we'll start by changing to the jumps directory and then 
launching Vim. For this demonstration, I recommend using the -u NONE -N
flags to ensure that Vim starts up without loading any plugins:

$ cd code/jumps
$ vim -u NONE -N practical_vim.rb

The practical_vim.rb file does nothing more than load the contents of the
core.rb and more.rb files:

jumps/practical_vim.rb
require 'practical_vim/core'
require 'practical_vim/more'

Wouldn't it be useful if we could quickly inspect the contents of the file
specified by the require directive? That's what Vim's gf command is for.
Think of it as go to file (:h gf).

Let's try it out. We'll start by placing our cursor somewhere indide the
'practical_vim/core' string (for example, pressing fp would get us there
quickly). If we try using the gf command now, we get this error: "E447:
Can't find file 'practical_vim/core' in path".

Vim tries to open a file called practical_vim/core and reports that it 
doesn't exist, but there is a file called practical_vim/core.rb (note the
file extension). Somehow we need to instruct Vim to modify the filepath 
under the cursor by appending the .rb file extension before attempting to
open it.


Specify a File Extension

The 'suffixesadd' option allows us to specify one or more file extensions, 
which Vim will attempt to use when looking up a filename with the gf command
(:h 'suffixesadd'). We can set it up by running this command:

:set suffixesadd+=.rb

Now when we use the gf command, Vim jumps directly to the filepath under the
cursor. Try using it to open more.rb. In that file, you'll find a couple of
other require declarations. Pick one, and open it up using the gf command.

***************************** skip ****************************** 


                            Part IV

                            Registers

                Vim's registers are simply containers that hold text.
                They can be used in the manner of a clipboard for
                cutting, copying, and pasting text, or they can be
                used to record a macro by saving a sequence of 
                keystrokes. In this part of the book, we'll master
                this core feature.



***************************** skip ******************************


copy_and_paste/collection.js
collection = getCollection();
process(somethingInTheWay, target);
