The Pragmatic Programmers
Practical Vim
    Second Edition
Edit Text at the Speed of Thought

What readers are saying about 
    Practical Vim

I've learned more about Vim by reading this book
than I have from any other resource.
>> Robert Evans
    Software Engineer, Code Wranglers

After reading a couple of chapters of Practical 
Vim, I realized how little I knew.
From intermediate to beginner in thirty minutes!
>> Henrik Nyh
    Software Engineer

Practical Vim continues to change what I believe
a text can do.
>> John P.Daigle
    Developer, ThoughtWorks,Inc.

Drew has continued the wonderful work he has done 
with Vimcasts in this book, a must-read for anyone
serious about Vim.
>> Anders Janmyr
    Developer, Jayway

Practical Vim bridges the gap between the official
documentation and how to really use Vim. After 
reading a few chapters, I switched to using Vim
as my default editor. I've never looked back.
>> Janvier Collado
    QA Automation Engineer, Canonical Ltd.

Drew Neil does more than show the right tool for
the job. He paces the narrative, laying out the 
philosophy behind each decision. Instead of 
expecting you to memorize everything, Practical
Vim teaches you to think with Vim under your
fingertips.
>> Mislav Marohnic
    Consultant

I've been using Vim for server maintenance for 
more than fifteen years now. but I've only 
recently started using it for software development.
I thought I knew Vim, but Practical Vim has 
massively improved my code-wrangling productivity.
>> Graeme Mathieson
    Software Engineer, Rubaidh Ltd.

Practical Vim made me realize how much there is
still to learn about Vim. Every single tip cap be
easily and immediately applied to your workflow
and improve your productivity manifold.
>> Mathias Meyer
    Author, Riak Handbook

Practical Vim is the ultimate treasure chest when
it comes to Vim knowledge. I've used Vim daily for
over two years now, and this book has been nothing
short of a revelation for me.
>> Felix Geisendorfer
    Cofounder, Transloadit

Practical Vim, Second Edition
    Edit Text at the speed of Thought
                                    Drew Neil

                            The Pragmatic Bookshelf
             Dallas, Texas Raleigh, North Carolina 

Pragmatic Bookshelf

Many of the designations used by manufacturers and
sellers to distinguish their products are claimed
as trademarks. Where those designations appear in
this book, and The Pragmatic Programmers, LLC was
aware of a trademark claim, the designations have
been printed in initial capital letters or in all
capitals. The Pragmatic Starter Kit, The Pragmatic
Programmer, Pragmatic Programming, Pragmetic 
Bookshelf, PragProg and the linking g device are
trademarks of The Pragmatic Programmers, LLC.

Every precaution was taken in the preparation of
this book. However, the publisher assumes no 
responsibility for errors or omissions, or for
damages that may result from the use of information
(including program listings) contained herein.

Our Pragmatic courses, workshops, and other 
products can help you and your team create better
software and have more fun. For more information,
as well as the latest Pragmatic titles, pleas
visit us at https://pragprog.com.

The team that produced this book includes:

Katharine Dvorak (editor)
Potomac Indexing, LLC (index)
Cathleen Small (copyedit)
Dave Thomas (layout)
Janet Furlow (producer)
Ellie Callahan (support)

For international rights, please contact 
rights@pragprog.com.

Copyright (C) 2015 The Pragmatic Programmers, LLC.
All rights reserved.

No part of this publication may be reproduced,
stored in a retrieval system, or transmitted,
in any form, or by any means, electronic, 
mechanical, photocopying, recording, or otherwise,
without the prior consent of the publisher.

Printed in the United States of America.
ISBN-13:978-1-60850-127-8
Encoded using the finest acid-free high-entropy
binary digits.
Book version:P1.1__January2016

                                        
                                        Contents
    Acknowledgments                             xi
    Foreword to the First Edition               xv
    Read Me                                   xvii
    Read the Forgotten Manual                  xix
1.  The Vim Way                                  1
    Tip 1.  Meet the Dot Command                 1
    Tip 2.  Don't Repeat Yourself                4
    Tip 3.  Take One Step Back, 
                Then Three Forward               6
    Tip 4.  Act, Repeat, Reverse                 8
    Tip 5.  Find and Replace by Hand             9
    Tip 6.  Meet the Dot Formula                11

//TODO




                                
                                 Acknowledgments

Thanks to Bram Moolenaar for creating Vim and to 
all those who have contributed to its development.
It's a timeless piece of software, and I look 
forward to growing with it.

Thanks to everyone at the Pragmatic Bookshelf for 
working together to make this book the best that
it could be. Special thanks to Kay Keppler, my 
developmental editor, for coaching me as a writer
and for helping to shape this book, despite its 
growing pains and my occasional tantrums. Thanks
also to Katharine Dvorak, my development editor 
for this revised edition. I'd also like to thank
David Kelly for his adept handling of my unusual
formatting requests.

Practical Vim didn't start out as a recipe book,
but Susannah Pfalzer recognized that it would 
work best in this format. It was painful to have
to rewrite so much, but in doing so I produced a
draft that I was happy with for the first time.
Susannah knows what's best, and I thank her for 
sharing that insight.

Thanks to Dave Thomas and Andy Hunt for creating
the Pragmatic Bookshelf. I wouldn't want to be
represented by any other publisher, and I'm 
honored to be listed alongside the other titles
in thier catalog.

Practical Vim wouldn't have been possible without
my technical reviewers. Each of you contributed
something and helped to shape the book.
I'd like to thank Adam McCrea, Alan Gardner, 
Alex Kahn, Ali Alwasity, Anders Janmyr, Andrew
Donaldson, Angus Neil, Charlie Tanksley, Ches
Martin, Daniel Bretoi, Dvid Morris, Denis Gorin, 
Elyezer Mendes Rezende, Erik St. Martin, Federico
Galassi, Felix Geisendorfer, Florian Vallen, 
Graeme Mathieson, Hans Hasselberg, Henrik Nyh, 
Javier Collado, Jeff Holland, Josh Sullivan, 
Joshua Flanagan, Kana Natsuno, Kent Frazier, 
Luis Merino, Mathias Meyer, Matt Southerdenm 
Mislav Marohnic, Mitch Guthrie, Morgan Prior,
Paul Barry. Peter Aronoff, Peter Rihn, Phillip
Roberts, Robert Evans, Ryan Stenhouse, Steven Ragnarok, Tibor Simic, Tim Chase, Tim Pope, Tim
Tyrrell, and Tobias Sailer.

Even with all of the feedback from my technical 
reviewers, some mistakes managed to stay hidden.
I'd like to thank everyone who has reported errors
in the book, helping me to locate and fix them.

Vim's built-in documentation is a terrific 
resource, and I make many references to it 
throughout Practical Vim. I'd like to thank Carlo
Teubner for publishing Vim's documentation online
at vimhelp.appspot.com and for keeping it up to 
date.

Some of the tips in the first edition of Practical
Vim were awkward, but I included them anyway 
because I felt that they were important. For this
revised edition, I'm pleased to have been able to
rewrite those awkward tips. Thanks to Christian
Brabandt for implementing the game-changing gn 
command, which allowed me to rewrite Tips 84, 
Operate in a Complete Search Match, in page 208.
Thanks to Yegappan Lakshmanan for implementing
the cfdo command (and family), which allowed me
to rewrite Tips 97, Find and Replace Across 
Multiple Files, on page 236. I'd also like to thank
David Burgin for patch 7.3.850, which fixed my pet
bug with the vimgrep command.

As a whole, I'd like to thank the Vim community
for sharing their insights across the Internet.
I learned many of the tips in this book by reading
the Vim tag on StackOverflow and by following
the vim_user mailing list.

Tim Pope's rails.vim plugin was instrumental in
convincing me to take Vim seriously, and many of
his other plugin have become essential parts of my
setup. I've also gained insight by using the 
plugins of Kana Natsuno, whose custome text objects
are some of the best extensions to Vim's core 
functioanlity that I've come across. Thank you both
for sharpening the saw so that the rest of us can
benefit.

Thanks to Joe Rozner for providing the wakeup
source code that I used to introduce the :make
command. Thanks to Oleg Efimov for his quick 
response to nodelint issues. Thanks to Ben Cormack
for illustrating the robots and ninjas.

In January 2012, we moved to Berlin, where the 
tech community inspired me to complete this book.
I'd like to thank Gregor Schmidt for founding the
Vim Berlin user group and Jan Schulz-Hofen for
hosting our meetups. The opportunity to speak to 
fellow Vim users really helped me to get my 
thoughts in order, so I'm grateful to everyone
who attended the Vim Berlin meetings. Thank you
to Daniel and Nina Holle for subletting your home
to us. It was wonderful place to live and a 
productive environment in which to work.

In March 2011, when I was living in Egypt, I need
surgery to clear adhesions that were obstructing
my bowel. Unlucky for me, I was a long way from
home. Luckily, my wife was by my side. Hannah
had me admitted to the South Sinai Hospital, where
I received excellent care. I want to thank all the
staff there for their kind help, and Dr.Shawket
Gerges for successfully operating on me.

When my mum learned that I required surgery, she 
dropped everything and was on the next flight to 
Egypt. Considering that the country was in 
revolution, it took enormous courage to do so.
I can't imagine how Hannah and I would have got 
through that diffcult time without the support
and experience that my mum brought. I consider 
myself blessed to have two such wonderful women in
my life.


                      Foreword to the First Edition

Conventional wisdom dictates that Vim has a steep
learning curve. I think most Vim users would 
disagree. Sure, threre's an initial hump, but once
you run through vimtutor and learn the basics of
what to put in your vimrc, you reach a point where
you can actually get work done --a sort of hobbled
productivity.

What comes next? The Internet's answer to this is
the "tip" --a recipe for solving a specific 
problem. You might search for specific tips when
your current solution to a problem feels 
suboptimal, or you might proactivly read some of
the more popular tips. This strategy works --it's
how I learned , after all --but it's slow. 
Learning that * searches for the word under the
cursor is helpful, but it hardly helps you think
like a Vim master.

You can understand my skepticism, then, when I 
found out Practical Vim was using a tips format.
How could a couple of hundred tips accomplish what
took me thousands? A few pages in I realized my
definition of "tip" was narrow-minded. In contrast
to the problem / solution pattern I had expected,
Practical Vim tips reach lessons in thinking like
a proficient Vim user. In a sense, they are more
like parables than recipes. The first few tips are
lessons about the eide applivability of the . 
command. This is a staple of any proficient Vim
user's repertoire, yet without guidance it was
years before I came to realize this on my own.

It is for this reason that I am excited about the
publication of Practical Vim. Because now when Vim
novices ask me what's the next step, I know what
to tell them. After all, Practical Vim even taught
me a few things.

Tim Pope
Vim core contributor
April 2012


                                        Read Me

Practical Vim is for programmers who want to raise
their game. You've heard it said that in the hands
if an expert, Vim shreds text at the speed of
thought. Reading this book is your next step 
toward that end.

Practical Vim is a fast track to Vim mastery. It
won't hold you by the hand, but beginners can find
the prerequisite knowledge by running through the
Vim tutor, an interactive lesson distributes with 
Vim. Practical Vim builds on this foundation by
highlighting core concepts and demonstrating
idiomatic usage.

Vim is highly configurable. However, customization
is a personal thing, so I've tried to avoid
recommending what should or should not got into
your vimrc file. Instead, Practical Vim focuses
on the core functionality of the editor --the stuff
that's always threre, whether you're working over
SSH on a remote server or using a local instance of
GVim, with plugins installed to add extra 
functionality. Master Vim's core, and you'll gain
portable access to a text editing power tool.

How This Book Is Structured

Practical Vim is a recipe book. It's not designed
to be read from start to finish. (I mean it! At the
start of the next chapter, I'll advise you to skip
it and jump straight to the action.) Each chapter
is a collection of tips that are related by a 
theme, and each tip demonstrates a particular 
feature in action. Some tips are self-contained.
Others depend upon material elsewhere in the book.
Those tips are cross-referenced so you can find
everything easily.

Practical Vim doesn't progress from novice to
advanced level, but each individual chapter does.
A less-experienced Vim user might prefer to make a
first pass through the book, reading just the 
early tips in each chapter. A more advanced user
might choose to focus on the later tips or move
around the books as needed.

A Note on the Examples

In Vim, there's always more than one way to 
complete any given task. For example, in Chapter 1,
The Vim Way, on page 1, all of the problems are
designed to illustrate an application of the dot
command, but every one of them could also be solved
using the  :substitute command.

On seeing my solution, you might think to yourself,
"Wouldn't it be quicker to do it this way?" And
you may well be right! My solutions illustrate a 
particular technique. Look beyond their simplicity,
and try to find a resemblance to the problems that
you face daily. That's where these techniques will
save your time.

Learn to Touch Type, Then Learn Vim

If you have to look down to find the keys on the
keyboard, the benefits of learning Vim won't come
fast. Learning to touch type is imperative.

Vim traces its ancestry back to the classic Unix
editors, vi and ed (see On the Etymology of Vim (
and Family), on page 55). These predate the mouse
and all of the point-and-click interfaces that 
came with it. In Vim, everything can be done with
the keyboard. For the touch typist, that means Vim
does everything faster.


                        Read the Forgotten Manual

In Practical Vim, I demonstrate by showing examples
rathar than by describing them. That's not easy to
do with the written word. To show the steps taken
during an interactive editing session, I've adopted
a simple notation that illustrates the keystrokes
and the contents of a Vim buffer side by side.

If you're keen to jump to the action, you can
safely skip this chapter for now. It describes
each of the conventions used throughout Practical
Vim, many of which you'll find to be 
self-explanatory. At some point, you'll probably
come across a symbol and wonder what it stands for.
When that happens, turn back and consult this 
chapter for the answer.

Get to Know Vim's Built-in Documentation

The best way to get to know Vim's documentation
is by spending time in it. To help out, I've 
included "hyperlink" for entries in Vim's 
docmentation. For example, here's the "hyperlink"
for the Vim tutor. :h vimtutor

The icon has a dual function. First, it serves
as a signpost, drawing the eye to these helpful
references. Second, if you're reading this on an
electronic device that's connected to the Internet,
you can click the icon and it will take you to the
relevant entry in Vim's online documentaion.
In this sense, it truly is a hyperlink.

But what if you're reading the paper edition of the
book? Not to worry. If you have an installation of
Vim within reach, simply enter the command as it
appears in front of the icon.

For example, type :h vimtutor (:h is an
abbreviation for the :help command). Consider this
is a unique address for the documentation on 
vimtutor. a URL of sorts. In this sense, the help
reference is a kind of hyperlink to Vim's built-in
documentation.

Notation for Simulating Vim on the Page

Vim's modal interface sets it apart from most other
text editors. To make a musical analogy, let's 
compare the Qwerty and piano keyboards. A pianist
can pick out melody by playing one note at a time
or he or she can hold down several keys at once
to sound a chord. In most text editors, keyboard
shortcuts are triggerd by pressing a key while
holding down one or more modifier buttons, such as
the control and command keys. This is the Qwerty
equivalent of playing a chord on the piano 
keyboard.

Some of Vim's commands are also triggered by 
playing chords, but Normal mode commands are 
designed to be typed as a sequence of keystrokes.
It's the Qwerty equivalent of playing a melogy
on the piano keyboard.

Ctrl-s is a common convention for representing 
chordal key commands. It means "Press the Control
key and the s key at the same time." But this
convention isn't well suited to describing Vim's
modal command set. In this section, we'll meet the
notation the used throghout Practical Vim to 
illustrate Vim usage.

Playing Melodies

In Normal mode, we compose commands by typing one
or more keystrokes in sequence. These command
appear as follows:

Notation    Meaning
x           Press x once
dw          In sequence, press d, then w
dap         In sequence, press d, a, then p

Most of these sequences involve two or three 
keystrokes, but some are longer. Deciphering the
meaning of Vim's Normal mode command sequences
can be challenging, but you'll get better at it
with practice.

Playing Chords

When you see a keystroke such as <C-p>, it doesn't
mean "Press <, then C, then -, and so on." The
<C-p> notation is equivalent to Ctrl-p, which means
"Press the <Ctrl> and p keys at the same time."

I didn't choose this notation without good reason.
Vim's documentation uses it (:h key-notation), and
we can also use it in defining custom kye mappings.
Some of Vim's commands are formed by combining
chords and keystrokes in sequence, and this 
notation handles them well. Consider these 
examples:

Notation    Meaning
<C-n>       Press <Ctrl> and n at the same time
g<C-]>      Press g, followed by <Ctrl> and ] at
                the same time
<C-r>0      Press <Ctrl> and r at the same time,
                then 0
<C-w><C-=>  Press <Ctrl> and w at the same time,
                then <Ctrl> and = at the same time

Placeholders

Many of Vim's commands require two or more 
keystrokes to be entered in sequence. Some commands
must be followed by a particular kind of keystroke,
while other commands can be followed by any key on
the keyboard. I use curly braces to denote the set
of valid keystrokes that can follow a command.
Here are some examples:

Notation        Meaning
f{char}         Press f, followed by any other 
                    characters
`{a-z}          Press `, followed by any lowercase
                    characters
m{a-zA-Z}       Press m, followed by lowercase or
                    uppercase letter
d{motion}       Press d, followed by motion command
<C-r>{register} Press <Ctrl> and r at the same 
                    time, followed by the address
                    of a register

Showing Special Keys

Some keys are called by name. This table shows a
selection of them:

Notation    Meaning
<ESC>       Press the Escape key
<CR>        Press the carriage return key (also
                known as <Enter>
<Ctrl>      Press the Control key
<Tab>       Press the Tab key
<Shift>     Press the Shift key
<S-Tab>     Press the <Shift> and <Tab> keys at 
                the same time
<Up>        Press the up arrow key
<Down>      Press the down arrow key
_           Press the space bar

Note that space bar is represented as _. This 
could be combined with the f{char} command to 
form f_.


Switching Modes Midcommand

When operating Vim, it's common to switch from
Normal to Insert mode and back again. Each 
keystroke could mean something different, depending
on which mode is active. I've used an alternative
style to represent keystrokes entered in Insert
mode, which makes it easy to differentiate them
from Normal mode keystrokes.

Consider this example: cwreplacement<Esc>. The
Normal mode cw command deletes to the end of the
current word and switches to Insert mode. Then we
type the word "replacement" in Insert mode and
press <Esc> to switch back to Normal mode again.

The Normal mode styling is also used for Visual
mode keystrokes, while the Insert mode styling
can indicate keystrokes entered in Command-Line
mode and Replace mode. Which mode is active should
be clear from context.


Interacting with the Command Line

In some tips we'll execute a command line, either
in the shell or from inside Vim. This is what it
looks like when we execute the grep command in the
shell:

$ grep -n Waldo *

And this is how it looks when we execute Vim's
built-in :grep command:

:grep Waldo *

In Practical Vim, the $ symbol that a command line
is to be executed in an external shell, whereas the
: prompt indicates that the command line is to be
excecuted internally from Command-Line mode. 
Occasionally we'll see other prompts, including
these:

Prompt  Meaning
$       Enter the command line in an external shell:       Use Command-Line mode to execute an Ex
            command
/       Use Command-Line mode to perform a forward
            search
?       Use Command-Line mode to perform a backward
            search
=       Use command-Line mode to evaluate a Vim
            script expression
            
Anytime you see an Ex command listed inline, such
as :write, you can assume that <CR> key is pressed
to execute the command. Nothing happend otherwise,
so you can consider <CR> to be implicit.

By contrast, Vim's search command allows us to
preview the first match befor pressing <CR> (see
Tip 82, Preview the First Match Before Execution,
on page 205). When you see a search command listed
inline, such as /pattern<CR>, the <CR> keystroke is
listed explicitly. If the <CR> is ommited, that's
intentional, and it means you shouldn't press the
Enter key just yet.


Showing the Cursor Position in a Buffer

When showing the contents of a buffer, it's useful
to be able to indicate where the cursor is 
positioned. In this example, you should see that
the cursor is placed on the first letter of the
word "One":

|One two three 

When we make a change that involves several steps,
the contents of the buffer pass throgh 
intermediate states. To illustrate the process, I
use a table showing the commands executed in the
left column and the contents of the buffer in the
right column. Here's simple example:

Keystrokes  BufferContents
{start}     |One two three
dw          |two three

In row 2 we run the dw command to delete the word
under the cursor. We can see how the buffer looks
immediately after running this command by looking
at the contents of the buffer in the same row.


Highlighting Search Matches

When demonstrating Vim's search command, it's
helpful to be able to highlight any matches that
occur in the buffer. In this example, searching
for the string "the" causes for occurrences of the
pattern to be highlighted:

Keystrokes  BufferContents
{start}     |the problem with these new recruits
                is that they don't keep their
                boots clean.
/the<CR>    _the_ problem with |the_se new recruits
                is that _the_y don't keep _the_ir
                boots clean.

Skip ahead to Tip 81, Highlight Search Matches, on
page 204, to find out how to enable search 
highlighting in Vim.


Selecting Text in Visual Mode

Visual mode lets us select text in the buffer and
then operate on the selection. Here, we use the it
text object to select the contentes of the <a> tag:

Keystrokes  BufferContents
{start}     <a |href="http://pragprog.com/dnvim/">
                Practical Vim</a>
vit         <a href="http://pragprog.com/dnvim/">
               _Practical Vi|m</a>

Note that the styling for a Visual selection is
the same for highlighted search matches. When you
see this style, it should be clear from context
whether it represents a serch match or a Visual
selection.


Downloading the Examples

The examples in Practical Vim usually begin by
showing the contents of a file before we change it.
These code listings include the file path:

macros/incremental.txt
partridge in a pear tree
turtle doves
French hens
calling birds
golden rings

Each time you see a file listed with its file path
in this manner, it means that you can download the
example. I recommend that you open the file in Vim
and try out the exercises for yourself. It's best
way to learn!

To follow along, download all the examples and
source code from the Pragmatic Bookshelf. If you're
reading on an electronic device that's connected
to the Internet, you can also fetch each file one
by one by clicking on the filename. Try it with 
the example above.


Use Vim's Factory Settings

Vim is highly configurable. If you don't like the
defaults, then you can change them. That's good
thing, but it could cause confusion if you follow
the examples in this book using a customized 
version of Vim. You may find that some things don't
work for you the way that they are described in 
text. If you suspect that your customizations are
causing interference, here's a quick test. Try 
quitting Vim and then launching it with these 
options:

$ vim -u NONE -N

The -u NONE flag tells Vim not to source your
vimrc on startup. That way, your customizations
won't be applied and plugins will be disabled.
When Vim starts up without loading a vimrc file,
it reverts to vi compatible mode, which causes
many useful features to be disabled. The -N flag
prevents this by setting the 'nocompatible'
option.

For most examples in Practical Vim, the vim -u
NONE -N trick should guarantee that you get the
same experience as described, but there are a
couple of exceptions. Some of Vim's built-in 
features are implemented with Vim script. Which
means that they will only work when plugins are
enabled. This file contains the absolute minimum 
configuration that is required to activate Vim's
built-in plugins:

essential.vim
set nocompatible
filetype plugin on

When launching Vim, you can use this file instead
of your vimrc by running the following

$ vim -u code/essential.vim

You'll have to adjust the code/essential.vim path
accordingly. With Vim's built-in plugins enabled,
you'll be able to use features such as netrw (Tip
44, Explore the File System with netrw, on page 104
) and omni-completion (Tip 119, Auto-complete with
Context Awareness, on page 293), as well as many
others. I consider Vim's factory settings to mean
built-in plugins enabled and vi compatibility
disabled.

Look out for subsections titled "Preparation" at
the top of a tip. To follow along with the material
in these tips, you'll need to configure Vim 
accordingly. If you start up with Vim's factory
settings and then apply the customizations on the
fly, you should be able to reproduce the steps
from these tips without any problems.

If you're still having problems, see On Vim 
Versions, on page xxvi.


On the Role of Vim Script

Vim script enables us to add new functionality to
Vim or to change existing functionality. It's a
complete scripting language in itself and a
subject worthy of a book of its own. Practical Vim
is not that book.

But we won't steer clear of the subject entirely.
Vim script is always just below the surface, ready
to do our bidding. We'll see a few examples of how
it can be used for everyday task in Tip 16, Do 
Back-of-the-Envelope Calculations in Place, on page
33; Tip 71, Evaluate an Iterator to Number Item in
a List, on page 177; Tip 95, Perform Arithmetic on
the Replacement, on page 233; and Tip 96, Swap Two
or More Words, on page 234.

Practical Vim show you how to get by with Vim's 
core functionality. In other words, no third-party
plugins assumed. I've made an exception for Tip 87,
Search for the Current Visual Selection, on page 
216. The visual-star.vim plugin adds a feature that
I find indispensable, and it requires very little
code --less than ten lines of Vim script. It 
demonstrates how easily Vim's funcionality can be
extended. The implementation of visual-star.vim is
presented inline without explanation. This should
give you an idea of what Vim script looks like and
what you can accomplish with it. If it piques your
interest, then so much better.


On Vim Versions

All examples in Practical Vim were tested on the
latest version of Vim, which was 7.4 at the time 
of writing. That said, most examples should work
fine on any 7.x release, and many of the features
discussed are also available in 6.x.

Some of Vim's functionality can be disables during
compilation. For example, when configuring the
build, we could provide the --with-features=tiny
option, which would disable all but the most
fundamental features (there are also feature sets
labeled small, nomal, big, and huge). You can
browse the feature list by looking up :h +feature-
list.

If you find that you're missing a feature discussed
in this book, you might be using a minimal Vim
build. Check whether or not the feature is 
available to you with the :version command:

:version
VIM - Vi IMproved 7.4 (2013 Aug 10, compiled Oct
14 2015 18:41:08)
Huge version without GUI. Features included (+) or
not (-):
+arabic +autocmd +baloon_eval +browse 
+builtin_terms +byte_offset +cindent +clientserver
+clipboard +cmdline_compl +cmdline_hist
+cmdline_info +comments
...

On a modern computer, there's no reason to use 
anything less than Vim's huge feature set!


Vim in the Terminal or Vim with a GUI? You Choose!

Traditionally, Vim runs inside of the terminal,
with no graphical user interface (GUI). We could
say instead that Vim has a TUI: a textual user
interface. If you spend most of your day at the
command linem this will feel natural.

If you're accustomed to using a GUI-based text 
editor, then GVim (or MacVim on OS X) will provide
a helpful bridge into the world of Vim 
(see :h gui). GVim supports more fonts and colors
for syntax highlighting. Also, you can use the
mouse. And some of the conventions of the 
operating system are honored. For example, in 
MacVim you can interact with the system clipboard
Cmd-X and Cmd-V, save a document with Cmd-S, or
close a window with Cmd-W. Use these while you find
your bearings, but be aware that there's always a
better way.

For the purpose of this book, it doesn't matter
whether you run Vim in the terminal or as GVim.
We'll focus on core commands that work just as well
in either. We'll learn how to do things the Vim
way.


                                        CHAPTER 1
                                    The Vim Way

Our worlk is repetitive by nature. Whether we're
making the same small change in several places or
moving around between similar regions of a 
document, we repeat many actions. Anything that 
can streamline a repetitive workflow will save our
time multifold.

Vim is optimized for repetition. Its efficiency
stems from the way it tracks our most recent 
actions. We can always replay the last change with
a single keystroke. Powerful as this sounds, it's
useless unless we learn to craft our actions so
that they perform a useful unit of work when 
replayed. Mastering this concept is the key to 
becoming effective with Vim.

The dot command is our starting point. This 
seemingly simple command is the most versatile 
tool in the box, and understanding it is the first
step toward Vim mastery. We'll work through a
handful of simple editing tasks that can be rapidly
completed with the dot command. Although each tasks
looks quite different from the next, their 
solutions almost converge. We'll identify an ideal
editing formula, which requires only one keystroke
to move and another to execute.


                                Tip 1
Meet the Dot Command

The dot command lets us repeat the last change.
It is the most powerful and versatile command in
Vim.

Vim's documentation simply states that the dot 
command "repeats the last change" (see :h .). It
doesn't sound like much, but in that simple 
definition we'll find the kernel of what makes
Vim's mordal editing model so effective. First we
have to ask, "What is a change?"

To understand the power of the dot command, we 
have to realize that the "last change" could be 
one of many things. A change could act at the 
level of individual characters, entire lines, or
even the whole file.

To demonstrate, we'll use this snippet of text:

the_vim_way/0_mechanics.txt
Line one
Line two
Line three
Line four

The x command deletes the character under the 
cursor. When we use the dot command in this 
context, "repeat last change" tells Vim to delete
the character under the cursor:

Keystrokes  BufferContents
--------------------------
{start}     |Line one
             Line two
             Line three
             Line four
--------------------------
x           |ine one
             Line two
             Line three
             Line four
--------------------------
.           |ne one
             Line two
             Line three
             Line four
--------------------------
..          | one
             Line two
             Line three
             Line four

We can restore the file to its original state by 
pressing the u key a few times to undo the changes.

The dd command also performs a deletion, but this
one acts on the current line as a whole. If we use
the dot command after dd, then "repeat last change"
instructs Vim to delete the current line:


Keystrokes  BufferContents
--------------------------
{start}     |Line one
             Line two
             Line three
             Line four
--------------------------
dd          |Line two
             Line three
             Line four
--------------------------
.           |Line three
             Line four

Finally, the >G command increases the indentation
from the current line until the end of the file. 
If we follow this command with the dot command, 
then "repeat last change" tells Vim to increase 
the indentation level from the current position to
the end of the file. In this example, we'll start
with the cursor on the second line to highlight 
the difference

Keystrokes  BufferContents
--------------------------
{start}      Line one
            |Line two
             Line three
             Line four
--------------------------
>G           Line one
                |Line two
             Line three
             Line four
--------------------------
j            Line one
                Line two
                |Line three
                Line four
--------------------------
.            Line one
                 Line two
                   |Line three
                    Line four
--------------------------
j.           Line one
                Line two
                    Line three
                       |Line four

The x, dd, > commands are all executed from Normal
mode, but we also create a change each time we dip
into Insert mode. From the moment we enter Insert
mode (by pressing i, for example) until we return
to Normal mode (by pressing <ESC>), Vim records
every keystroke. After making a change such as 
this, the dot command will replay our keystrokes
(see Moving Around in Insert Mode Resets the 
Change, on page 17, for a caveat).

The Dot Command Is a Micro Macro

Later, in Chapter 11, Macros, on page 161, we'll
see that Vim can record any arbitrary number of
keystrokes to be played back later. This allows us
to capture our most repetitive workflows and
replay them at a key stroke. We can think of the
dot command as being a miniature macro, or a 
"micro" if you prefer.

We'll see a few applications of the dot command
throughout this chapter. We'll also learn a couple
of best practices for working with the dot command
in Tip 9, Compose Repeatable Changes, on page 18,
and Tip 23, Prefer Operators to Visual Commands
Where Possible, on page 45.


                            Tip 2
Don't Repeat Yourself

For such a common use case as appending a semicolon
at the end of a series of lines, Vim provides a
dedicated command that combines two steps into one.

Suppose that we have a snippet of JavaScript code
like this:

the_vim_way/2_foo_bar.js
var foo = 1
var bar = 'a'
var foobar = foo + bar

We need to append a semicolon at the end of each
line. Doing so involves moving our cursor to the
end of the line and then switching to Insert mode
to make the change. The $ command will handle the
motion for us, and then we can run a;<ESC> to make
the change.

To finish the job, we could run the exact same 
sequence of keystrokes on the next two lines, but
that would be missing a trick. The dot command will
repeat that last change, so instead of duplicating
our efforts, we could just run j$. twice. One
keystroke (.) buys us three (a;<ESC>). It's a
small saving, but these efficiencies accumulate
when repeated.

But let's take a closer look at this pattern:
j$.. The j command moves the cursor down one line,
and then the $ command moves it to the end of the
line. We've used two keystrokes just to maneuver
our cursor into position so that we can use the
dot command. Do you sense that there's room for
improvement here?

Reduce Extraneous Movement

While the a command appends after the current 
cursor position, the A command appends at the end
of the current line. It doesn't matter where our
cursor is at the time, pressing A will switch to
Insert mode and move the cursor to the end of the
line. In other words, it squashes $a into a single
keystroke. In Two for the Price of One, on page 6,
we see that Vim has a handful of compound commands.

Here is a refinement of our previous example:

Keystrokes     BufferContents
-----------------------------
{start}       |var foo = 1
               var bar = 'a'
               var foobar = foo + bar
-----------------------------
A;<ESC>        var foo = 1|;
               var bar = 'a'
               var foobar = foo + bar
-----------------------------
j              var foo = 1;
               var bar = '|a'
               var foobar = foo + bar
-----------------------------
.              var foo = 1;
               var bar = 'a'|;
               var foobar = foo + bar
-----------------------------
j.             var foo = 1;
               var bar = 'a';
               var foobar = foo + bar|;

By using A instead of $a, we give the dot command
a boost. Instead of having to position the cursor
at the end of the line we want to change, we just
having to make sure it is somewhere (anywhere!) on
that line. Now we can repeat the change on 
consecutive lines just by typing j. as many times
as it takes.

One keystroke to move, another to execute. That's
about as good as it gets! Watch for this pattern
of usage, because we'll see it popping up in a
couple more examples.

Although this formula looks terrific for our short
example, it's not a universal solution. Imagine if
we had to append a semicolon to fifty consecuitive
lines. Pressing j. for each change starts to look
like a lot of work. For an alternative approach,
skip ahead to Tip 30, Run Normal Mode Commands
Across a Range, on page 63.


Two for the Price of One
We could say that the A command compounds two 
actions ($a) into a single keystroke. It's not 
alone in doing this. Many of Vim's single-key 
commands can be seen as a condensed version of two
or more other commands. The table below shows an
approximation of some examples. Can you identify
anything else that they all have in common?

Compound Command    Equivalent in Longhand
------------------------------------------
C                   c$
s                   cl
S                   ^C
I                   ^i
A                   $a
o                   A<CR>
O                   ko

If you catch yourself running ko (or worse, k$a<CR>
), stop! Think about what you're doing. Then 
recognize that you could have used the 0 command
instead.

Did you identify the other property that these 
command share? They all switch from Normal to 
Insert mode. Think about that and how it might 
affect the dot command.


                            Tip 3
Take One Step Back, Then Three Forward

We can pad a single character with two spaces (one
in front, the other behind) by using an idiomatic
Vim solution. At first it might look slightly odd,
but solution has the benefit of being repeatable,
which allows us to complete the task effortlessly.

Suppose that we have a line of code that looks like
this:

the_vim_way/3_concat.js
var foo = "method("+argument1+","+argument2")";

Concatenationg strings in JavaScript never looks
pretty, but we could make this a little easier on
the eye by padding each + sign with spaces to make
it look like this:

var foo = "method(" + argument1 + "," + argument2
            + ")";

Make the Change Repeatable

This idiomatic approach solves the problem:

Keystrokes  BufferContents
{start}    |var foo = "method("+arg
                ument1+","+argument2+")";
f+          var foo = "method("|+arg
                ument1+","+argument2+")";
s_+_<Esc>   var foo = "method(" +| arg
                ument1+","+argument2+")";
;           var foo = "method(" + arg
                ument1|+","+argument2+")";
.           var foo = "method(" + arg
                ument1 +| ","+argument2+")";
;.          var foo = "method(" + arg
                ument1 + "," + argument2+")";
;.          var foo = "method(" + arg
                ument1 + "," + argument2 + ")";

The s command compounds two steps into one: it
deletes the charactar under the cursor and then
enters Insert mode. Having deleted the + sign, we
then type _+_ and leave Insert mode.

One step back and then three steps forward. It's
a strange little dance that might seem unintuitive,
but we get a big win by doing it this way: we can
repeat the change with the dot command; all we
need to do is position our cursor on the next +
symbolm, and the dot command will repeat that 
little dance.


Make the Motion Repeatable

There's another trick in this example. The f{char}
command tells Vim to look ahead for next occurrence
of the specified character and then move the 
cursor directly ti it if a match is found (see :h
f). So when we type f+, our cursor goes straight
to the next + symbol. We'll learn more about the
f{char} command in Tip 50, Find by Character, on
page 120.

Having made our first change, we could jump to the
next occurrence by repeating the f+ command, but
there's a better way. The ; command will repeat
the last search that the f command performed. So
instead of typing f+ four times, we can use that
command once and then follow up by using ; command
three times.


All Together Now

The ; command takes us to our next target, and the
. command repeats the last change, so we can 
complete the changes by typing ;. three times.
Does that look familiar?

Instead of fighting Vim's modal input model, we're
working with it and look how much easier it makes
this particular task.


                        Tip 4
Act, Repeat, Reverse

When facing a repetitive task, we can achive an
optimal editing strategy by making both the motion
and the change repeatable. Vim has a knack for 
this. It remenbers our actions and keeps the most
common ones within close reach so that we can 
easily replay them. In this tip, we'll introduce
each of the actions that Vim can repeat and learn
how to reverse them.

We've seen that the dot command repeats the last
change. Since lots of operations count as a change,
the dot command proves to be versatile. But some
commands can be repeated by other means, For
example, @: can be used to repeat any Ex commands
(as discussed in Tip 31, Repeat the Last Ex 
Command, on page 65). Or we can repeat the last 
:substitute command (which itself happens to be
an Ex command as well) by pressing & (see Tip 93,
Repeat the Previous Substitute Command, on page 229
).

If we know how to repeat our actions without having
to spell them out single time, then we can be more
efficient. First we act; then we repeat.

But when so much can be achieved with so few
keystrokes, we have to watch our step. It's easy
to get trigger-happy. Rapping out j.j.j. again
and again feels a bit like doing a drum roll. What
happens if we accidentally hit the j key twice in
a row? Or worse, the . key?

Whenever Vim makes it easy to repeat an action or
motion, it always provides some way of backing out
in case we accidentally go too far. In the case of
the dot command, we can always hit the u key to 
undo the last change. If we hit the ; key too many
times afrer using the f{char} command, we'll miss
our mark. But we can back up again by pressing ,
key, which repeats the last f{char} search in the
reverse direction (see Tip 50, Find by Character,
on page 120).

It always helps to know where the reverse gear is
in case you accidentally go a step too far. 
Table 1, Repeatable Actions and How to Reverse 
Them, on page 9, summarizes Vim's repeatable 
commands along with their corresponding reverse 
action. In most cases, the undo command is the one
that we reach for. No wonder the u key on my 
keyboard is so worn out!

Intent          Act         Repeat      Reverse
Make a change   {edit}      .           u
Scan line for next character
                f{char}/t{char}
                            ;           ,
Scan line for previous character
                F{char}/T{char}
                            ;           ,
Scan document for next match
                /pattern<CR>
                            n           N
Scan document for previous match
                ?pattern<CR>
                            n           N
Perform substitution
                :s/target/replacement
                            &           u
Execute a sequence of changes
                qx{changes}q
                            @x          u
--------------------
Table 1 --Repeatable Actions and How to Reverse
            Them


                        Tip 5
Find and Replace by Hand

Vim has a :substitute command for find-and-replace
tasks, but with this alternative technique, we'll
change the first occurrence by hand and then find
and replace every other match one by one. The dot
command will save us from labor, but we'll meet
another nifty one-key command that makes jumping
between matches a snap.

In this excerpt, the word "content" appears on
every line:

the_vim_way/1_copy_content.txt
...We're waiting for content befor the site can go
live...
...If you are content with this, let's got ahead
with it...
...We'll launch as soon as we have the content...

Suppose that we want to use the word "copy" (as in
"copywriting") instead of "content." Easy enough,
you might think; we can just use the substitute
command, like this:

:%s/content/copy/g

But wait a minute! If we run this command, then
we're going to create the phrase "If you are 'copy'
with this," which is nonsense!

We've run into this problem because the word 
"content" has two meanings. One is synonymous with
"copy" (and pronounced ^content), the other with
"happy" (pronounced con^tent). Technically, we're
dealing with heteronyms (words that are spelled 
the same but differ in both meaning and 
pronunciation), but that doesn't really matter.
The point is, we have to watch our step.

We can't just blindly replace every occurence of
"content" with "copy". We have to eyeball each one
and answer "yay" or "nay" to the question, should
this occurrence be changed? The substitute command
is up to the task, and we'll find out how in Tip 
90, Eyeball Each Substitution, on page 223. But
right now, we'll explore an alternative solution
that fits with the theme of this chapter.

Be Lazy: Search Without Typing

You might have guessed by now that the dot command
is my favorite single-key Vim trigger. In second
place is the * command. This executes a search for
the word under the cursor at that moment (see :h *)
.

We could search for the word "content" by pulling
up the search prompt and spelling out the word in
full:

/content

Or we could simply place our cursor on the word 
and hit the * key. Consider the following workflow:

KeyStrokes      BufferContents
--------------------------------------------------
{start}         ...We're waiting for content
                    before the site can go live...
                ...If you are |content with this, 
                    let's got ahead with it...
                ...We'll launch as soon as we have
                    the content...
--------------------------------------------------
*               ...We're waiting for _content_
                    before the site can go live...
                ...If you are _content_ with this, 
                    let's got ahead with it...
                ...We'll launch as soon as we have
                    the |_content_...
--------------------------------------------------
cwcopy<Esc>     ...We're waiting for _content_
                    before the site can go live...
                ...If you are _content_ with this, 
                    let's got ahead with it...
                ...We'll launch as soon as we have
                    the cop|y...
--------------------------------------------------
n               ...We're waiting for |_content_
                    before the site can go live...
                ...If you are _content_ with this, 
                    let's got ahead with it...
                ...We'll launch as soon as we have
                    the copy...
--------------------------------------------------
.               ...We're waiting for cop|y
                    before the site can go live...
                ...If you are _content_ with this, 
                    let's got ahead with it...
                ...We'll launch as soon as we have
                    the copy...

We begin with our cursor positioned on the word
"content" and then use the * command to search for
it. Try it for yourself. Two things should happen:
the cursor will jump forward to the next match, 
and all occurrence will be highlighted. If you
don't see any highlighting, try running :set hls
and then refer to Tip 81, Hightlight Search 
Matches, on page 204, for more detailes.

Having executed a search for the word "content",
we can now advance to the next occurrence just by
hitting the n key. In this case, pressing *nn 
would cycle through all matches, taking us back to
where we started.


Make the Change Repeatable

With our cursor positioned at the start of the
word "content", we are poised to change it. This
involves two steps: delete the word "content" and
then typing its replacement. The cw command deletes
to the end of the word and then drops us into 
Insert mode, where we can spell out the word 
"copy". Vim records our keystrokes until we leave
Insert mode, so the full sequence cwcopy<Esc> is
considered to be a single change. Pressing the .
command deletes to the end of the current word and
changes it to "copy".


All Together Now

We're all set! Each time we press the n key, our
cursor advances to the next occurrence of the word
"content". And when we press the . key, it changes
the word under the cursor to "copy".

If we wanted to replace all occurrence, we could
blindly hammer out n.n.n. as many times as it took
to complete all the changes (although in that case,
we might as well have used the :%s/content/copy/g
command). But we need to watch out for false 
matches. So after pressing n, we can examine the
current match and decide if it should be changed
to "copy". If so, we trigger the . command. If not,
we don't. Whatever our decision, we can then move
on to the next occurrence by pressing n again.
Rinse and repeat until done.


                        Tip 6
Meet the Dot Formula

We've considered three simple editing tasks so far.
Even though each problem was different, we found
a solution using the dot command for each one. In
this tip, we'll compare each solution and identify
a common pattern --an optimal editing strategy
that I call the Dot Formula.

Reviewing Three Dot-Command Editing Tasks

In Tip 2, Don't Repeat Yourself, on page4, we 
wanted to append a semicolon at the end of a 
sequence of lines. We changed the first line by
invoking A;<Esc>, which set us up so that we could
use the dot command to repeat the change on each
subsequent line. We could move between lines using
the j command, and the remaining changes could be
completed simply by pressing j. as many times as 
necessary.

In Tip 3, Take One Step Back, Then Three Forward,
on page 6, we wanted to pad each occurrence of the
+ symbol with a space both in front and behind. We
used the f+ command to jump to our target and then
the s command to substitute one character with
three. That set us up so that we could complete the
task by pressing ;. a few times.

In Tip 5, Find and Replace by Hand, on page 9, we
wanted to substitute every occurrence of the word
"content" with the word "copy". We used the * 
command to initiate a search for the target wor
and then ran the cw command to change the first
occurrence. This set us up so that the n key would
take us to the next match and the . key would apply
the same change. We could complete the task simply 
by pressing n. as many times as it took.

The Ideal: One Keystroke to Move, One Keystroke
            to Execute

In all of these examples, using the dot command
repeats the last change. But that's not the only
thing they share. A single keystroke is all that's
required to move the cursor to its next target.

We're using one keystroke to move and one keystroke
to execute. It can't really get any better than
that, can it? It's an ideal solution. We'll see
this editing strategy coming up again and again,
so for the sake of convenience, we'll refer to this
pattern as the Dot Formula.



                    Part I

                    Modes


        Vim provides a modal user interface.
        This means that the result of pressing
        any key on the keyboard may differ
        depending on which mode is active
        and how to switch between Vim's mode.
        In this part of the book, we'll learn
        how each mode works and what it can
        be used for.



                                        CHAPTER 2
                                        Normal Mode

Normal mode is Vim's natural resting state. If this
chapter seems surprisingly short, then that's
because most of this book is about how to use
Normal mode! Here, however, is where cover some
core concepts and general tips.

Other text editors spend most of their time in
something that resembles Insert mode. So to the
Vim newcomer, it can seem strange that Normal mode
is the default. In Tip 7, Pause with Your Brush
Off the Page, on page 16, we'll begin explaining
why this is by drawing an analogy with the 
workpace of a painter.

Many Normal mode commands can be executed with a
count, which causes them to be run multiple times.
In Tip 10, Use Counts to Do Simple Arithmetic, on
page 20, we'll meet a pair of commands that 
increment and decrement numerical values and see
how these commands can be combined with a count to
do simple arithmetic.

Just because you can save keystroke by using a 
count doesn't mean that you should. We'll look at
some examples where it's better simply to repeat
a command than take the time to count how many 
times you want to run it.

Much of the power of Normal mode stems form the
way that operator commands can be combined with
motions. We'll finish by looking at the 
consequeces of this.


                        Tip 7
Pause with Your Brush Off the Page

For those unused to Vim, Normal mode can seem like
an odd default. But experienced Vim users have
difficulty imaging it any other way. This tip uses
an analogy to illustrate the Vim way.

How much time do you reckon artists spend with 
their paint brushes in contact with the canvas?
No doubt it would vary from artist to artist, but
I'd be surprised if it counted for as much as half
of the time painters spend at worl.

Think of all of the things that painters do besides
paint. They study their subject, adjust the 
lighting, and mix paints into new hues. And when it
comes to applying paint to the canvas, who says 
they have to use brushes? A painter might switch
to a palette knife to achieve a different texture
or use a cotton swab to touch up the paint that's
already been applied.

The painter does not rest with a brush on the 
canvas. And so it is with Vim. Normal mode is the
natural resting state. The clue is in the name,
really.

Just as painters spend a fraction of their time
applying paint, programmers spend a fraction of
their time composing code. More time is spent 
thinking, reading, and navigating from one part of
a codebase to another. And when we do want to make
change, who says we have to switch to Insert mode?
We can reformat existing code, duplicate it, move
it around, or delete it. From Normal mode, we have
many tools at our disposal.


                            Tip 8
Chunk Your Undos

In other text editors, invoking the undo command
after typing a few words might revert the last
typed word or character. However, in Vim we can
control the granularity of the undo command.

The u key triggers the undo command, which reverts
the most recent change. A change could be anything
that modifies the text in the docment. That 
includes commands triggered from Normal, Visual,
and Command-Line modes, but a change could also
encompass any text entered (or deleted) in Insert
mode. So we could also say that i{insert some text}
<Esc> constitutes a change.

In nonmodal text editors, triggering the undo 
command after typing a few words could do one of
two things. It could undo the last character that
was typed. Or, more helpfully, it could chunk a
set of characters together so that each undo 
operation removed a word insterad of a character.

In Vim, we can control the granularity of the undo
command. From the moment we enter Insert mode until
we return to Normal mode, everything we typed (or
deleted) counts as a single change. So we can make
the undo command operate on words, sentences, or
paragraphs just by moderating our use of the <Esc>
key.

So how often should you leave Insert mode? It's a
matter of preference, but I like to make each
"undoable chunk" correspond to a thought. As I
write this text (In Vim, of course!), I often 
pause at the end of a sentence to consider what
I'll write next. No matter how brief its duration,
each pause forms a natural break point, giving me
a cue to leave Insert mode. When I'm ready to 
continue writing, I press A and carry on where I
left off.

If I decided that I've taken a wrong turn, I'll
switch to Normal mode and press u. Each time I 
undo, my text decomposes in coherent chunks that
correspond to my thought process as I was writing
the original text. It means that I can easily try
out a sentence or two and then throw them away 
with a couple of keystrokes.

If I'm in Insert mode with my cursor at the end of
a line, the quickest way to open a new line is to
press <CR>. And yet I sometimes prefer to <Esc>o
just because I anticipate that I might want that
extra granularity from the undo command. If this
sounds hard core, don't worry. As you become adept
with Vim, switching modes feels more and more
lightweight.

As a general rule, if you've paused for long enough
to ask the question, "Should I leave Insert mode?"
then do it.

Moving Around in Insert Mode Resets the Change

When I said that the undo command would revert all
characters entered (or deleted) during a trip into
Insert mode and back, I was glossing over a smal
detail. If we use the <Up>, <Down>, <Left>, or
<Right> cursor keys while in Insert mode, a new
undo chunk is created. It's just as though we had
switched back to Normal mode to move around with
the h, j, k, or l commands, except that we don't
have to leave Insert mode. This also has 
implications on the operation of the dot command.


                            Tip 9
Compose Repeatable Changes

Vim is optimized for repetition. In order to
exploit this, we have to be mindful of how we
compose our changes.

In Vim, we always have more than one way of doing
something. In evaluating which way is best, the
most obvious metric is efficiency: which technique
requires the fewest keystrokes (a.k.a VimGolf).
But how should we pick a winner in the event of
a tie?

Suppose that our cursor is positioned on the "h"
at the end of this line of text, and we want to 
delete the word "nigh".

normal_mode/the_end.txt
The end id nigh

Delete Backward

Since our curdor is already at the end of the word,
we might begin by deleting backward.

KeyStrokes      BufferContents
-------------------------------------------------
{start}         The end is nig|h
db              The end is |h
x               The end is|

Pressing db deletes from the cursor's starting
position to the beginning of the word, but it 
leaves the final "h" intact. We can delete this
rogue character by pressing x. That gives us a Vim
golf score of 3.

Delete Forward

This time, let's try deleting forward instead.

Keystrokes      BufferContents
-------------------------------------------------
{start}         The end is nig|h
b               The end is |nigh
dw              The end is|

We have to start by maneuvering our cursor into 
position with the b motion. Once it's in place, we
can excise the word with a single dw command.
once again, our Vim golf score is 3.

Delete an Entire Word

Both of our solutions so far have involved some
kind of preparation or clean-up. We can be more
surgical by using the aw text object instead of a
motion (see :h aw):

Keystrokes      BufferContents
-------------------------------------------------
{start}         The end is nig|h
daw             The end is|

The daw command is easily remembered by the 
mnemonic delete a word. We'll go into more detail
on text object in Tip 52, Trace Your Selection with
Precision Text Objects, on page 126, and Tip 53,
Delete Around, or Change Inside, on page 129.


Tie-Breaker: Which is Most Repeatable?

We've tried three techniques for deleting a word:
dbx, bdw, and daw. In each case, our Vim golf score
is 3. So how can we settle the question of which is
best?

Remember, Vim is optimized for repetition. Let's go
through these techniques again. This time, we'll 
finish by invoking the dot command and see what
happens. I urge you to try these out for yourself.

The backward deletion technique involves two 
operations: db deletes to the start of the word
and then x deletes a single character. If we 
invoke the dot command, it repeats the single
character deletion (. == x). That's not what I
would call a big win.

The forward deletion technique also involves two
steps. This time, b is just a plain motion, while
dw makes a change. The dot command repeats dw, 
deleting from the cursor position to the beginning
to the next word. It so happens that we're already
at the end of the line. There is no "next word", 
so in this context the dot command isn't useful.
But at least it's shorthand for something longer
(. == dw).

The final solution only invokes a single operation:
daw. This technique doesn't just remove the word,
it also deletes a whitespace character. As a 
result, our cursor ends up on the last character
of the word "is". If we invoke the dot command, it
will repeat the instruction to delete a word. This
time, the dot command does something truly useful
(. == daw).


Discussion

The daw technique invests the most power into the
dot command, so I declare it the winner of this
round.

Making effective use of the dot command often 
requires some forethought. If you notice that you
have to make the same small change in a handful of
places, you can attempt to compose your changes in
such a way that they can be repeated with the dot
command. Recognizing those opportunities takes 
practice. But if you develop a habit of making 
your changes repeatale whenever possible, then Vim
will reward you for it.

Sometimes, I won't see an opportunity to use the 
dot command. After making a change --and finding
that I need to perform an identical edit --I 
realize that the dot command is primed and ready
to do the work for me. It makes me grin every time.


                            Tip 10
Use Counts to Do Simple Arithmetic

Most Normal mode commands can be executed with a
count. We can exploit this feature to do simple
arithmetic.

Many of the commands that are available in Normal
mode can be prefixed with a count. Instead of 
executing the command just once, Vim will attempt
to execute the command the specified number of 
times (see :h count).

The <C-a> and <C-x> commands perform addtion and
subtraction on numbers. When run without a count
they increment by one, but if we prefix a number,
then we can add or subtract by any whole number.
For example, if we positioned our cursor on a 5
character, runnning 10<C-a> would modify it to read
15.

But what happens if the cursor is not positioned
on a numeric digit? The documentation says that the
<C-a> command will "add [count] to the number at
or after the cursor" (see :h ctrl-a). So if the
cursor is not already positioned on a number, then
the <C-a> command will look ahead for a digit on
the current line. If it finds one, it jumps 
straight to it. We can use this to our advantage.

Here's a snippet of CSS:

normal_mode/sprite.css
.blog, .news { background-image: url(/sprite.png);}
.blog { background-position: 0px 0px }

We are going to duplicate the last line and make
two small modifications to it: replace the word
"blog" with "news", and change "0px" to "-180px".
We can duplicate the line by running yyp and then
using cW to change the first word. But how should
we deal with number?

One approach would be to jump to the digit with
f0 and then dip into Insert mode to change the
value by hand: i-18<Esc>. But it's quicker just to
run 180<C-x>. Since our cursor isn't on a digit to
begin with, it jumps forward to the first one that
it finds. That saves us the step of moving the
cursor by hand. Let's see this work flow in action:

keystrokes      BufferContent
----------------------------------------------
{start}         .blog, .news { background-image:
                    url(/sprite.png);}
               |.blog { background-position: 
                    0px 0px }
----------------------------------------------
yyp             .blog, .news { background-image:
                    url(/sprite.png);}
                .blog { background-position: 
                    0px 0px }
               |.blog { background-position: 
                    0px 0px }
----------------------------------------------
cW.news<Esc>    .blog, .news { background-image:
                    url(/sprite.png);}
                .blog { background-position: 
                    0px 0px }
                .new|s { background-position: 
                    0px 0px }
----------------------------------------------
180<C-x>        .blog, .news { background-image:
                    url(/sprite.png);}
                .blog { background-position: 
                    0px 0px }
                .new|s { background-position: 
                    -18|0px 0px }

In this example, we've only duplicated the line 
once and made changes. But suppose we had to make
ten copies, subtracting 180 from the number in each
successive copy. If we were to switch to Insert
mode to amend each number, we'd have to type 
something different each time (-180, then -360, and
so on). But by using the 180<C-x> command, our 
work flow is identical for each successive line.
We could even record our key strokes as a macro
(see Chapter 11, Macros, on page 161) and then
play it back as many times as needed.

Number Formats

What follows 007? No, this isn't a James Bond gag:
I'm asking what result would you expect if you 
added one to 007.

If you answered 008, then you might be in for a
surprise when you try using Vim's <C-a> command
on any number with a leading zero. As is the
convention in some programming languages, Vim
interprets numerals with a leading zero to be in
octal notation rather than in decimal. In the octal
numeric system, 007 + 001 = 010, which looks like
the decimal ten but actually an octal eight.
Confused?

If you work with octal numbers frequently, Vim's
default behavior might suit you. If you don't, you
probably want to add the following line to your 
vimrc:

set nrformats=

This will cause Vim to treat all numerals as 
decimal, regardless of whether they are padded with
zeros.


                        Tip 11
Don't Count If You Can Repeat

We can minimize the keystrokes required to perform
certain tasls by providing a count, but that 
doesn't mean that we should. Consoder the pros and
cons of counting versus repeating.

Suppose that we had the following text in our 
buffer:

Delete |more than one word

We want to do as the text says, changing it to 
read "Delete one word" instead. That is to say, 
we're going to delete two words.

We can approach this in a handful of ways. Both 
d2w and 2dw will work. With d2w, we invoke the
delete command and then give 2w as the motion. We
could read that as "delete two words". However, 
2dw turns things around. This time the count 
applies to the delete command. but the motion acts
over a single word. We could read this as "delete
a word two times". Putting semantics aside, we get
the same result either way.

Now let's consider an alternative: dw. . This we
can read as "Delete a word and then repeat."

To recap, our options are as follows: d2w, 2dw, or
dw. --three keystrokes each. But which is best?

For our discussion, d2w and 2dw are identical.
After running either of these, we can press the u
key to undo, and the two words that were deleted
will appear again. Or, instead of undoing our
change, we could repeat it with the dot command, 
which would delete the next two words.

In the case of dw., the result of pressing u or .
is subtly different. Here, the change was dw --
"delete word". So if we wanted to restore the two
words that were deleted, we'd have to undo twice:
pressing uu (or 2u if you prefer). Pressing the
dot command would just delete the next word rather
than the next two.

Now suppose that instead of deleting two words, our
original intent was to delete three words. By a
small error in judgment, we run d2w instead of d3w.

What next? We can't use the dot command, because
that would cause a total of four words to be 
deleted. So we could either back up and revise our
count (ud3w) or continue by deleting the next word
(dw).

If, on the other hand, we had used the command dw.
in the first place, we would have to repeat the
dot command only one more time. Because our 
original change was simply dw, the u and . 
commands have more granularity. Each acts upon one
word at a time.

Now suppose that we want to delete seven word. We
could either run d7w, or dw..... (that is, dw 
followed by the dot command six times). Counting
keystrokes, we have a clear winner. But would you
trust yourself to make the right count?

Counting is tedious. I'd rather hit the dot command
six times than spend the same time looking ahead
in order to reduce the number of keys that I have
to press. What if I hit the dot command one too
many times? No matter, I just back up by hitting
the u key once.

Remember our mantra (from Tip 4 Act, Repeat,
Reverse, on page 8): act, repeat, reverse. Here it
is in action.


Use a Count When It Matters

Suppose that we wanted to change the text "I have
a couple of questions" to instead read "I have some
more questions." We could do so as follows:

Keystrokes        BufferContents
------------------------------------------
{start}           I have |a couple of questions.
c3wsome more<Esc> I have some mor|e questions.

In this scenario, it doesn't make much sense to use
the dot command. We could delete one word and then
another (with the dot command), but then we'd have
to switch gears and change to Insert mode (using
i or cw, for example). To me, that feels awkward
enough that I'd rather go ahead and use a count.

There's another advantage to using a count: it 
gives us a clean and coherent undo history. Having
made this change, we could undo it with a single
press of the u key, which ties in with the 
discussion in Tip 8, Chunk Your Undos, on page 16.

That same argument also goes in favor of counting
(d5w) over repeating (dw....), so my preferences
may seem inconsisent here. You'll develop your own
opinion on this, depending on how much you value 
keeping your undo history clean and whether or not
you find it tiresome to use counts.


			Tip 12
Conbine and Conquer

Much of Vim's power stems from the way that 
operators and motions can be combined. In this tip,
we'll look at how this works and consider the
implications.


Operator + Motion = Action

The d{motion} command can operate on a single
character (dl), a complete word (daw), or an entire
pragraph (dap). Its reach is defined by the motion.
The same goes for c{motion}, y{motion}, and a handful
fo others. Collectively, these commands are called
operators. You can find the complete list by looking
up :h operator, while Table 2, Vim's Operator Commands,
on page 25, summarizes some of the more common ones.

The g~, gu, and gU commands are invoked by two 
keystrokes. In each case, we can consider the g to be
a prefix that modifies the behavior of the subsequent
keystroke. See Meet Operator-Pending Mode, on page 26,
for further discussion.

The combination of operators with motions forms a kind
of grammer. The first rule is simple: an action is
composed  from an operator followed by a motion. 
Learning new motions and operators is like learning
the vocabulary of Vim. If we follow the simple grammer
rules, we can express more ideas as our vocabulary
grows.

Suppose that we already know how to delete a word using
daw, and then we learn about the gU command (see :h gU).
It's an operator too, so we can invoke gUaw to convert
the current word to SHOUTY case. If we then expand our
vocabulary to include the ap motion, which act upon a
paragraph, then we find two new operations at our 
disposal: dap to delete, or gUap to make the whole
paragraph shout.

Vim's grammer has just one more rule: when an operator
command is invoked in duplicate, it acts upon the
current line. So dd deletes the current line, while >>
indents it. The gU command is a special case. We can
make it act upon the current line by running either
gUgU or the shorthand gUU.

Trigger		Effect
------------------------------------------------------
c		Change
d		Delete
y		Yank into register
g~		Swap case
gu		Make lowercase
gU		Make uppercase
>		Shift right
<		Shift left
=		Autoindent
!		Filter {motion} lines through an 
			external program
------------------------------------------------------
Table 2 --Vim's Operator Commands


Extending Vim's Combinatorial Powers

The number of actions that we can perform using Vim's
default set of operators and motions is vast. But we 
can expand these even further by rolling our own custom
motions and operators. Let's consider the implications.


Custom Operators Work with Existing Motions

The standard set of operators that ships with Vim is 
relatively small, but it is possible to define new ones.
Tim Pope's commentary.vim plugin provides a good example.
This adds a command for commenting and uncommenting lines
of code in all languages supported by Vim.

The commentary command is triggered by \\{motion}, which
toggles commenting for the specified lines. It's an
operator command, so we can combine it with all of usual
motions. \\ap will toggle commenting for the current
paragraph. \\G comments from the current line to the end
of the file. \\\ comments the current line.

If you're curious about how to create your own custom
operators, start by reading :h :map-operator.


Custom Motions Work with Existing Operators

Vim's standard set of motions is fairly comprehensive,
but we can augment it further by defining new motions
and text objects.

Kana Natsuno's textobj-entire plugin is a good example.
It adds two new text objects to Vim: ie and ae, which
act upon the entire file.

If we wanted to autoindent the entire file using the
= command, we could run gg=G (that is, gg to jump to 
the top of the file and then =G to autoindent 
everything from the cursor position to the end of the
file). But if we had the textobj-entire plugin installed,
we could simply run =ae. It wouldn't matter where our
cursor was when we ran this command; it would always
act upon the entire file.

Note that if we had both the commentary and textobj-
entire plugings installed, we could use them together.
Running \\ae would toggle commenting throughout the
current file.

If you're curious about how to create your own custom
motions, start by reading :h omap-info.


Meet Operator-Pendign Mode

Normal, Insert, and Visual modes are readily identified,
but Vim has other modes that are easy to overlook.
Operator-Pending mode is a case in point. We use it 
dozens of times daily, but it usually lasts for just a
fraction of a second. For example, we invoke it when we
run the command dw. It lasts during the brief interval
between pressing d and w keys. Blink and you'll miss it!

If we think of Vim as a finite-state machine, then 
Operator-Pending mode is a state that accepts only 
motion commands. It is activated when we invoke an 
operator command, and then nothing happens until we 
provide a motion, which completes the operation. While
Operator-Pending mode is active, we can return to Normal
mode in the usual manner by pressing escape, which 
aborts the operation.

Many commands are invoked by two or more keystrokes
(for examples, look up :h g, :h z, :h ctrl-w, or :h [),
but in most cases, the first keystroke merely acts as a
prefix for the second. These commands don't initiate
Operator-Pending mode. Instead, we can think of them as
namespaces that expand the number of available command
mappings. Only the operator commands initiate Operator-
Pending mode.

Why, you might be wondering, is an entire mode dedicated
to those brief moments between invoking operator and 
motion commands, whereas the namespaced commands are
merely an extension of Normal mode? Good question! 
Because we can create custom mappings that initiate or
target Operator-Pending mode. In other words, it allows
us to create custom operators and motions, which in turn
allows us to expand Vim's vocabulary.


					CHAPTER 3
					Insert Mode

Most of Vim's commands are triggered from other modes,
but some functionality is within easy reach from Insert
mode. In this capter, we'll explore these commands.
Although delete, yank, and put commands are all triggered
from Normal mode, we'll see that there is a convenient
shortcut for pasting text from a register without leaving
Insert mode. We'll learn that Vim provides two easy ways
for inserting unusual characters that are not represented
on the keyboard.

Replace mode is a special case of Insert mode, which 
overwrites existing characters in the document. We'll 
learn how to invoke this and consider some scenarios where
it proves useful. We'll also meet Insert Normal mode, a
submode that lets us fire a single Normal mode command 
before dropping us back into Insert mode.

Autocompletion is the most advanced functionality 
available to us from Insert mode. We'll cover it in depth
in Chapter 19, Dial X for Autocompletion, on page 275.


				Tip 13
Make Corrections Instantly from Insert Mode

If we make a mistake while composing text in Insert mode,
we can fix it immediately. There's no need to change
modes. Besides the backspace key, we can use a couple of
other Insert mode commands to make quick corrections.

Touch typing is more than just not looking at the 
keyboard; it means doing it by feel. When touch typists 
make an error, they know it even before their eyes 
process the information on the screen in front of them.
They feel it in their fingers, like a misplaced step.

When we make a typing error, we can use the backspace
key to erase the mistake and then make a correction.
As long as the error appears near the end of the word,
this may be the quickest strategy for making amends. 
But what if the mistake was at the start of the word?

Expert typists recommend drastic measures: delete the
entire word; then type it out again. If you can type
at a rate above sixty words per minute, retyping a word
from scratch will only take a second. If you can't type 
that fast, consider this to be good practice! There are
particular words that I consistently mistype. Since I
started following this advice, I've become more aware of
which words trip me up. As a result, I now make fewer
mistakes.

Alternatively, you could switch to Normal mode, navigate
to the start of the word, fix the error, then hit A to
return to where you left off in Insert mode. That little
dance could take longer than a second, and it would do
nothing to improve your touch-typing skills. Just because
we can switch modes doesn't mean that we should.

In Insert mode, the backspace key works just as you could
expect: it deletes the character in front of the cursor.
The following chords are also available to us:

Keystrokes	Effect
------------------------------------------------------
<C-h>		Delete back one character (backspace)
<C-w>		Delete back one word
<C-u>		Delete back to start of line

These commands are not unique to Insert mode or even to
Vim. We can also use them in Vim's command line as well
as in the bash shell.


				Tip 14
Get Back to Normal Mode

Insert mode is specialized for one task --entering text
--whereas Normal mode is where we spend most of our time
(as the name suggests). So it's important to be able to
switch quickly between them. This tip demonstrates a
couple of tricks that reduce the friction of mode 
switching.

The classic way of getting back to Normal mode is with
the <Esc> key, but in many keyboards that can seem like
a long reach. Alternatively, we can press <C-[>, which
has exactly the same effect (see :h i_CTRL-[).

Keystrokes	Effect
------------------------------------------------------
<Esc>		Switch to Normal mode
<C-[>		Switch to Normal mode
<C-o>		Switch to Insert Normal mode

Vim novices frequently become fatigued by the constant
need to switch modes, but with practice it starts to
feel more natural. Vim's modal nature can feel awkward
in one particular scenario: when we're in Insert mode
and we want to run only one Normal command and the 
continue where we left off in Insert mode. Vim has a
neat solution to ease the friction caused by switching
modes: Insert Normal mode.


Meet Insert Normal Mode

Insert Normal mode is a special version of Normal mode,
which gives us one bullet. We can fire off a single 
command, after which we'll be returned to Insert mode
immediately. From Insert mode, we can switch to Insert
Normal mode by pressing <C-o> (:h i_CTRL-O).

When the current line is right at the top or bottom of 
the window, I sometimes want to scroll the screen to
see a bit more context. The zz command redraws the
screen with the current line in the middle of the window,
which allows us to read half a screen above and below the
line we're working on. I'll often trigger this from 
Insert Normal mode by tapping out <C-o>zz. That puts me
straight back into Insert mode so that I can continue
typing uninterrupted.


				Tip 15
Paste from a Register Without Leaving Insert Mode

Vim's yank and put operations are usually executed from
Normal mode, but sometimes we might want to paste text
into the document without leaving Insert mode.

Here's and unfinished excerpt of text:

insert_mode/practical-vim.txt
Practical Vim, by Drew Neil
Read Drew Neil's


Remap the Caps Lock Key

For Vim users, the Caps Lock key is a menace. If Caps
Lock is engaged and you try using the k and j keys to
move the cursor around, you'll instead trigger the K
and J commands. Briefly: K looks up the man page for
the word under the cursor (:h K), and J joins the 
current and next lines together (:h J). It's surprising
how quickly you can mangle the text in your buffer by
accidentally enabling the Caps Lock key!

Many Vim users remap the Caps Lock button to make it act
like another key, such as <Esc> or <Ctrl>. On modern
keyboards, the <Esc> key is difficult to reach, whereas
the Caps Lock key is handy. Mapping Caps Lock to behave
as an <Esc> key can save a lot of effort, especially 
since the <Esc> key is so heavily used in Vim. I prefer
to map the Caps Lock button to behave instead as a <Ctrl>
key. The <C-[> mapping is synonymous with <Esc>, and it's
easier to type when the <Ctrl> key is withing easy reach.
Additionally, the <Ctrl> key can be used for many other
mappings, both in Vim and in other programs too.

The simplest way to remap the Caps Lock is to do it at
the system level. The methods differ on OS X, Linux, and
Windows, so rather than reproducing instructions here for
each system, I suggest that you consult Google. Note
that this customization won't just affect Vim: it applies
system-wide. If you take my advice, you'll throw away the
Caps Lock key forever. You won't miss it, I promise.


We want to complete the last line by inserting the title
of this book. Since that text is already present at the
start of the first line, we'll yank it into a register
and then append the text at the end of the next line in
Inesrt mode:

Keystrokes	BufferContents
------------------------------------------------------
yt,	       |Practical Vim, by Drew Neil
		Read Drew Neil's
------------------------------------------------------
jA_		Practical Vim, by Drew Neil
		Read Drew Neil's |
------------------------------------------------------
<C-r>0		Practical Vim, by Drew Neil
		Read Drew Neil's Practical Vim.
------------------------------------------------------
.<Esc>		Practical Vim, by Drew Neil
		Read Drew Neil's Practical Vim.

The command yt, yanks the word Practical Vim into the
yank register (we'll meet the t{char} motion in Tip 49,
on page 114). In Insert mode, we can press <C-r>0 to 
paste the text that we just yanked at the current cursor
position. We'll discuss registers and the yank operation
at greater length in Chaprer 10, Copy and Paste, on page
141.

The general format of the command is <C-r>{register}, 
where {register} is the address of the register we want
to insert (see :h i_CTRL-R).


Use <C-r>{register} for Character-wise Registers

The <C-r>{register} command is convenient for pasting a
few words from Insert mode. If the register contains a lot
of text, you might notice a slight delay before the screen
updates. That's because Vim inserts the text from the 
register as if it were being typed one character at a time.
If the 'textwidth' or 'autoindent' options are enabled, you
might end up with unwanted line breaks or extra 
indentation.

The <C-r><C-p>{register} command is smarter. It inserts
text literally and fixes any unintended indentaion (see 
:h i_CTRL-R_CTRL-P). But it's a bit of a handful! If I 
want to paste a register containing multiple lines of
text, I prefer to switch to Normal mode and use one of
the put command (see Tip 62, on page 151).


				Tip 16
Do Back-of-the-Envelope Calculations in Place

The expression register allows us to perform calculations
and then insert the result directly into our document.
In this tip, we'll see one application for this powerful
feature.

Most of Vim's registers contain text either as a string
of characters or as entire lines of text. The delete and
yank command allows us to set the contents of a resigter,
while the put command allows us to get the contents of a
register by inserting it into the document.

The expression register is different. It can evaluate a
piece of Vim script code and return the result. Here, we
can use it like a calculator. Passing it a simple 
arithmetic expression, such as 1+1, gives a result of 2.
We can use the return value from the expression register
just as though it were a piece of text saved in a plain
old register.

The expression register is addressed by the = symbol.
From Insert mode we can access it by typing <C-r>=. This
opens a prompt at the bottom of the screen where we can
type the expression that we want to evaluate. When done,
we hit <CR>, and Vim inserts the result at our current
position in the document.

Suppose that we've just typed the following:

insert_mode/back-of-envelope.txt
6 chairs, each costing $35, totals $

There's no need to scribble on the back side of an
envelope. Vim can do the math for us, and we don't
have to leave Insert mode. Here's how:

Keystrokes	BufferContents
------------------------------------------------------
A		6 chairs, each costing $35, totals $|
<C-r>=6*35<CR>  6 chairs, each costing $35, totals $210|

The expression register is capable of much more than 
simple arithmetic. We'll meet a slightly more advenced
example in Tip 70, on page 174.


				Tip 17
Insert Unusual Characters by Character Code

Vim can insert any character by its numeric code. This
can be handy for entering symbols that are not found on
the keyboard.

We can tell Vim to insert any arbitrary character if we
know its numeric code. From Insert mode, we just have to
type <C-v>{code}, where {code} is the address of the 
character that we want to insert.

Vim expects the numeric code to consists of three digits.
Suppose, for example, that we wanted to insert an 
uppercase "A" character. The character code is 65, so we
would have to enter is as <C-v>065.

But what if we wanted to insert a character whose numeric
code is longer than three digits? For example, the Unicode
Basic Multilingual Plane has an address space for up to
65,535 characters. It turns out that we can enter all of
these using a four-digit hexadecimal code if we type 
<C-v>u{1234} (note the u pressing the digit this time).
Let's say we wanted to insert an inverted question mark 
symbol ("¿"), which is represented by the character code
00bf. From Insert mode, we would just have to type 
<C-v>u00bf . See :h i_CTRL-V_digit for more details.

If you want to find out the numeric code for any character
in your document, just place the cursor on it and trigger
the ga command. This outputs a message at the bottom of the
screen, revealing the character code in decimal and 
hexadecimal notations (see :h ga). Of course, this is of 
little help if you want to know the code for a character
that is not already present in your document. In that case, 
you might want to look up the unicode tables.

In another scenario, if the <C-v> command is followed by 
any nondigit key, it will insert the character represented
by that key literally. For example, if the 'expandtab' 
option is enabled, then pressing the <Tab> key will insert
space characters instead of a tab character. However, 
pressing <C-v><Tab> will always insert a tab character
literally, regardless of whether 'expandtab' is enabled or 
not.

Table 3, Inserting Unusual Characters, on page 33, 
summarizes the commands for entering unusual characters.

Keystrokes		BufferContents
------------------------------------------------------
<C-v>{123}		Insert character by decimal code
<C-v>u{1234}		Insert character by hexadecimal 
				code
<C-v>{nondigit}		Insert nondigit literally
<C-k>{char1}{char2}	Insert character represented by
				{char1}{char2} digraph
------------------------------------------------------
Table 3 --Inserting Unusual Characters


				Tip 18
Insert Unusual Characters by Digraph

While Vim allows us to insert any character by its
numeric code, these can be hard to remember and awkward
to type. We can also insert unusual characters as 
digraphs: pairs of characters that are easy to remember.

Digraphs are easy to use. From Insert mode, we just type
<C-k>{char1}{char2} . So if we wanted to insert the "¿"
character, which is represented by the digraph ?I, we 
would simply type <C-k>?I . 

The character pairs that make up a digraph are chosen to
be descriptive, making them easier to remember or even
guess. For example, the double-angle quotation marks
« and » are represented by the digraphs << and >>; the
vulgar (or common) fractions ½, ¼, and ¾are
represented by the digraphs 12, 14, and 34, respectively.
The default set of digraphs that ship with Vim follows
certain conventions, which are summarized under 
:h digraph-deault.

We can view a list of the available digraphs by running
:digraphs, but the output of this command is difficult
to digest. A more usable list can be found by looking 
up :h digraph-table .

				
				Tip 19
Overwrite Existing Text with Replace Mode

Replace mode is identical to Insert mode, except that
it overwrites existing text in the document.

Suppose that we had an excerpt of text such as this:

insert_mode/replace.txt
Typing in Insert mode extends the line. But in Replace
mode the line length doesn't change.

Instead of using two separate sentences, we're going to
run this together into single sentence by changing the
period to a comma. We also have to downcase the "B" in 
the word "But". This example shows how we could do this
using Replace mode.

Keystrokes	BufferContents
-----------------------------------------------------
{start}	       |Typing in Insert mode extends the line.
		 But in Replace mode the line length
		 doesn't change.
-----------------------------------------------------
f.		Typing in Insert mode extends the line|.
		 But in Replace mode the line length
		 doesn't change.
-----------------------------------------------------
R,b<Esc>	Typing in Insert mode extends the line,
		 but in Replace mode the line length
		 doesn't change.

From Normal mode, we can engage Replace mode with the
R command. As the example demonstrates, typing ",b"
overwrites the existing ".B" characters. And when we're
finished with Replace mode, we can hit the <Esc> key to
return to Normal mode. Not all keyboards have an <Insert>
key, but if yours does, then you can use it to toggle
between Insert and Replace modes.


Overwrite Tab Characters with Virtual Replace Mode

Some characters can complicate matters for Replace mode.
Consider the tab character. This is represented by a 
single character in the file, but onscreen it expands to
fill several columns, as defined by the 'tabstop' setting
(see :h 'tabstop'). If we placed our cursor on a tab stop
and initiated Replace mode, then the next character we 
typed would overwrite the tab character. Supposing that
the 'tabstop' option was set to 8 (the default), this
would appear to replace eight characters with one, 
causing a drastic reduction in the length of the current
line.

Vim has a second variant of Replace mode. Virtual Replace
mode is triggered with gR and treats the tab character
as though it consisted of spaces. Suppose that we position
the cursor on a tab stop spanning eight columns of screen
real estate. If we switch to Virtual Replace mode, we 
could type up to seven characters, each of which would be
inserted in front of the tab character. Finally, if we
typed an eighth character, it would replace the tab stop.

In Virtual Replace mode, we overwrite characters of 
screen real estate rather than dealing with the actual
characters that would eventually be saved in a file. This
tends to produce fewer surprises, so I would recommend
using Virtual Replace mode whenever possible.

Vim also provides a single-shot version of Replace mode
and Virtual Replace mode. The r{char} and gr{char} 
commands allow us to overwrite a single character before
switching straight back to Normal mode (:h r).


					CHAPTER 4
					Visual Mode

Vim's Visual mode allow us to define a selection of text
and then operate upon it. This should feel pretty 
intuitive, since it is the model that most editing
software follows. But Vim's take is characteristically
different, so we'll start by making sure we grok Visual
mode (Tip 20, on page37).

Vim has three variants of Visual mode involving working
with characters, lines, or rectangular blocks of text.
We'll explore ways of switching between these mode as
well as some useful tricks for modifying the bounds of 
a selection (Tip 21, on page 39).

We'll see that the dot command can be used to repeat
Visual mode commands, but that it's especially effective
when operating on line-wise regions. When working with
character-wise selections, the dot command can sometimes
fall short of our expectations. We'll see that in these
scenarios, operator commands may be preferable.

Visual-Block mode is rather special in that it allows us
to operate on rectangular columns of text. You'll find
many uses for this feature, but we'll focus on three tips
that demonstrate some of its capabilities.


				Tip 20
Grok Visual Mode

Visual mode allows us to select a range of text and then
operate upon it. However intuitive this might seem, Vim's
perspective on selecting text is different from other 
text editors.

Suppose for a minute that we're not working with Vim but
instead filling out a text area on a web page. We've 
written the word "March", but it should read "April", so
using the mouse, we double-click the word to select it.
Having highlighted the word, we could hit the backspace
key to delete it and then type out the correct month as
a replacement.

You probably already know that there's no need to hit the
backspace key in this example. With the word "March" 
selected, we would only have to type the letter "A" and
it would replace the selection, preparing the way so that
we could type out the rest of the word "April". It's not
much, but a keystrokes saved is a keystroke earned.

If you expect this behavior to carry over to Vim's 
Visual mode, you're in for a surprise. The clue is right
there in the name: Visual mode is just another mode, which
means that each key performs a different function.

Many of the commands that you are familiar with from
Normal mode work just the same in Visual mode. We can 
still use h, j, k, and l as cursor keys. We can use
f{char} to jump to a character on the current line and
then repeat or reverse the jump with the ; and , commands,
respectively. We can even use the search command (and n/N
) to jump to pattern matches. Each time we move our 
cursor in Visual mode, we change the bounds of the 
selection.

Some Visual mode commands perform the same basic function
as in Normal mode but with a slight twist. For example, 
the c commands is consistent in both modes in that it
deletes the specified text and then switches to Insert
mode. The difference is in how we specify the range on
which to act. From Normal mode, we trigger the change
command first and then specify the range as a motion.
This, if you'll remember from Tip 12, on page 24, is
called an operator command. Whereas in Visual mode, we
start off by making the selection and then trigger the
change command. This inversion of control can be 
generalized for all operator commands (see Table 2, Vim's
Operator Commands, on page 25). For most people, the 
Visual mode approach feels more intuitive.

Let's revisit the simple example where we wanted to 
change the word "March" to "April". This time, suppose
that we have left the confines of the text area on a web
page and we're comfortably back inside Vim. We place 
our cursor somewhere on the word "March" and run viw to
visually select the word. Now, we can't just type the
word "April" because that would trigger the A command
and append the text "pril"! Instead, we'll use the c
command to change the selection, deleting the word and
dropping us into Insert mode, where we can type out the
word "April" in full. This pattern of usage is similar
to our original example that we use the c key instead
of backspace.


Meet Select Mode

In a typical text editing environment, selected text is
deleted when we type any printable character. Vim's 
Visual mode doesn't follow this convention --but Select
mode does. According to Vim's built-in documentation, 
it "resembles the selection mode in Microsoft Widows"
(see :h Select-mode). Printable characters cause the
selection to be deleted, Vim enters Insert mode, and the
typed character is inserted.

We can toggle between Visual and Select modes by pressing
<C-g>. The only visible difference is the message at the
bottom of screen, which switches between -- VISUAL -- and
-- SELECT --. But if we type any printable character in
Select mode, it will replace the selection and switch to
Insert mode. Of course, from Visual mode you could just
as well use the c key to change the selection.

If you are happy to embrace the modal nature of Vim, then
you should find little use for Select mode, which holds
the hand of users who want to make Vim behave more like
other text editors. I can think of only one place where
I consistently use Select mode: when using a plugin that
emulates TextMate's snippet functionality, Select mode
highlights the active placeholder.


				Tip 21
Difine a Visual Selection

Visual mode's three submodes deal with different kinds
of text. In this tip, we'll look at the ways of enabling
each visual submode, as wekk as how to switch between
them.

Vim has three kinds of Visual mode. In character-wise
Visual mode, we can select anything from a single 
charecter up to a range of characters withing a line or
spanning multiple lines. This is suitable for working
at the level of individual words or phrases. If we want
to operate on entire lines, we can use line-wise Visual
mode instead, Finally, block-wise Visual mode allows us
to work with columnar regions of the document. Block-wise
Visual mode is quite special, so we'll discuss it at
greater length in Tip 24, on page 45, Tip 25, on page 47,
and Tip 26, on page 48.


Enabling Visual Modes

The v key is our gateway into Visual mode. From Visual
mode, we can press v by itself to enable character-wise
Visual mode. Line-wise Visual mode is enabled by pressing
V (with the Shift key), and block-wise Visual mode by 
pressing <C-v> (with the Control key). These commands are
summarized in the following table:

Command	Effect
v	Enable character-wise Visual mode
V	Enable line-wise Visual mode
<C-v>	Enable block-wise Visual mode
gv	Reselect the last visual selection

The gv command is a useful littele shortcut. It reselects
the range of text that was last selected in Visual mode.
No matter whether the previous selection was 
character-wise, line-wise, or block-wise, the gv command
should do the right thing. The only case where it might
get confused is if the last selection has since been
deleted.


Switching Between Visual Modes

We can switch between the different flavors of Visual 
mode in the same way that we enable them form Normal
mode. If we're in character-wise Visual mode, we can
switch to the line-wise variant by pressing V, or to
block-wise Visual mode with <C-v>. But if we were to
press v from character-wise Visual mode, it would
switch us back into Normal mode. So you can think of
the v key as a toggle between Normal mode and 
character-wise Visulal mode. The V and <C-v> keys also
toggle between Normal mode and their respective flavors
of Visual mode. Of course, you can always switch back
to Normal mode by pressing <Esc> or <C-[> (just like
getting out of Insert mode). This table summarizes the
commands for switching between Visual modes:

Command	Effect
---------------------------------------------------------
<Esc> / Switch to Normal mode
<C-[>
---------------------------------------------------------
v / V / Switch to Normal mode (when used form character-,
<C-v>	 line-, or block-wise Visual mode, respectively)
---------------------------------------------------------
v	Switch to character-wise Visual mode
---------------------------------------------------------
V	Switch to line-wise Visual mode
---------------------------------------------------------
<C-v>	Switch to block-wise Visual mode
---------------------------------------------------------
o	Go to other end of highlighted text


Toggling the Free End of a Selection

The range of a  Visual mode selection is marked by two
ends: one end is fixed and the other moves freely with
our cursor. We can use the o key to toggle the free 
end. This is really handy if halfway through defining
a section we realize that we started the wrong place.
Rather than leaving Visual mode and starting afresh, 
we can just hit o and redefine the bounds of the 
selection. The following demonstrates how we can use
this technique:

Keystrokes	BufferContents
---------------------------------------------------------
{start}		Select from here to |here.
---------------------------------------------------------
vbb		Select from |_here to h_ere.
---------------------------------------------------------
o 		Select from  _here to |_here.
---------------------------------------------------------
e		Select from _here to her|e_.


				Tip 22
Repeat Line-Wise Visual Commands

When we use the dot command to repeat a change made to a
visual selection, it repeats the change on the same range
of text. In this tip, we'll make a change to a line-wise 
selection and then repeat it with the dot command.

When we execute a command from Visual mode, we are dropped
back into Normal mode and the range of text that was 
marked out in Visual mode is unselected. So what should 
we do if we want to perform another Visual mode command
on the same range of text?

Suppose that we had the following excerpt of malformatted
Python:

visual_mode/fibonacci-malformed.py
def fib(n):
    a, b = 0, 1
    while a < n:
print a,
a, b = b, a + b
fib(42)

This code sample uses four spaces per indentation. First,
we'll have to configure Vim to match this style.


Preparation

To make the < and > commands work properly, we should set
the 'shiftwidth' and 'softtabstop' settings to 4 and 
enable 'expandtab'. If you want to understand how these
settings work together, check out the "Tabs and Spaces"
episode on Vimcasts.org This one-liner does the trick:

:set shiftwidth=4 softtabstop=4 expandtab


Indent Once, Then Repeat

In our malformed Python excerpt, the two lines below the
while keyword should be indented further by two levels.
We could fix it by visually selecting the text and 
triggering the > command to indent it. But that would
only increase the indentation by one level before 
dropping us back into Normal mode.

One solution would be to reselect the same text using
the gv command and then invoke the indentation command
again. But if you're getting a feel for the Vim way, 
then this should raise alarm bells for you.

When we need to repeat ourselves, the dot command is
our friend. Rather than reselecting the same range of
the text and repeating the same command manually, we
can just hit the . key form Normal mode. Here it is in
action:

Keystrokes  BufferContents
------------------------------------------------------
{start}     def fib(n):
                a, b = 0, 1
                while a < n:
           |print a,
            a, b = b, a+b
            fib(42)
------------------------------------------------------
Vj          def fib(n):
                a, b = 0, 1
                while a < n:
           _print a,
           |a, b = b, a+b_
            fib(42)
------------------------------------------------------
>.          def fib(n):
                a, b = 0, 1
                while a < n:
                   |print a,
                    a, b = b, a+b


If you're good at counting, you might prefer to hit the
target in a single blow by running 2> from Visual mode.
I prefer using the dot command because it gives me 
instant visual feedback. If I need to trigger the 
indentation command again, I just hit . another time. Or
if I get trigger-happy and overshoot my mark, I press the
u key to bring it back in line. Tip 11, on page 22, 
discusses the difference in a little more detail.

When we use the dot command to repeat a Visual mode 
command, it acts on the same amount of text as was marked
by the most recent visual selection. This behavior tends
to work in our favor when we make line-wise visual 
selections, but it can have surprising results with
character-wise selections. Next, we'll look at an example
that illustrates this.


                            Tip 23
Prefer Operators to Visual Commands Where Possible

Visual mode may be more intuitive than Vim's Normal mode
of operation, but it has a weakness: it doesn't always
play well with the dot command. We can route around this
weakness by using Normal mode operators when appropriate.

Suppose that we want to transform the following list of
links to make them shout:

visula_mode/list-of-links.html
<a href="#">one</a>
<a href="#">two</a>
<a href="#">three</a>

We can select the inner contents of a tag by running vit,
which can be read as visually select inside the tag. The
it command is a special kind of motion called a text
object, which we'll cover in detail in Tip 51, on page
120.


Using a Visual Operator

In Visual mode, we make a selection and then act on it.
In this case, we could use the U command which converts
the selected charecters to uppercase (:h v_U). See 
Table 4, Uppercasing in Visual Mode, on page 44.

Having transformed the first line, we now want to 
perform the same change on the next two lines. How about
we try using the Dot Formula?

Keystrokes  BufferContents  
------------------------------------------------------
{start}    |<a href="#">one</a>
            <a href="#">two</a>
            <a href="#">three</a>
------------------------------------------------------
vit         <a href="#">_on|e_</a>
            <a href="#">two</a>
            <a href="#">three</a>
------------------------------------------------------
U           <a href="#">|ONE</a>
            <a href="#">two</a>
            <a href="#">three</a>
------------------------------------------------------
Table 4 --Uppercasing in Visual Mode

Running j. advances our cursor to the next line and then
repeats the last change. It works fine on line two, but
if we try it again we end up with this strange-looking
result:

<a href="#">ONE</a>
<a href="#">TWO</a>
<a href="#">THRee</a>

Do you see what's happened? When a Visual mode command
is repeated, it affects the same range of text (see :h
visual-repeat). In this case, the original command 
affected a word consisting of three letters. This works
fine for line two, which happens to also contain a 
three-letter word, but it falls short when we try to 
repeat the command on a word containing five letters.


Using a Normal Operator

The Visual mode U command has a Normal mode equivalent:
gU{motion} (:h gU). If we use this to make the first
change, we can complete the subsequent edits using the 
Dot Formula as shown in Table 5, Normal Operator in 
Visual Mode, on page 45.


Discussion

Both of these techniques require only four keystrokes:
vitU versus gUit, but the underlying semantics are
quite different. In the Visual mode approach, the four
keystrokes can be considered as two separate commands:
vit to make a selection and U to transform the selection.
In contrast, gUit can be considered as a single command
comprised of an operator (gU) and a motion (it).

If we want to set up the dot command so that it repeats
something useful, then we're better off staying out of
Visual mode. As a general rule, we should

Keystrokes  BufferContents
------------------------------------------------------
{start}    |<a href="#">one</a>
            <a href="#">two</a>
            <a href="#">three</a>
------------------------------------------------------
gUit        <a href="#">|ONE</a>
            <a href="#">two</a>
            <a href="#">three</a>
------------------------------------------------------
j.          <a href="#">ONE</a>
            <a href="#">|TWO</a>
            <a href="#">three</a>
------------------------------------------------------
j.          <a href="#">ONE</a>
            <a href="#">TWO</a>
            <a href="#">THREE</a>
------------------------------------------------------
Table 5 --Normal Operator in Visual Mode


prefer operator commands over their Visual mode 
equivalents when working through a repetitive set of
changes.

That's not to say that Visual mode is out of bounds.
It still has a place. Not every editing task needs to 
be repeated, so Visual mode is perfectly adequate for
one-off changes. And even though Vim's motions allow 
for surgical precision, sometimes we need to modify a
range of text whose structure is difficult to trace.
In these cases, Visual mode is the right tool for the
job.


                        Tip 24
Edit Tabular Data with Visual-Block Mode

We can work with rows of text in any editor, but 
manipulating columns of text requires a more specialized
tool. Vim provides this capability in the form of its
Visual-Block mode, which we'll use to transform a 
plain-text table.

Suppose that we have a plain-text table such as this one:

visual_mode/chapter-table.txt
Chapter         Page
Normal mode       15
Insert mode       31
Visual mode       44

We want to draw a vertical line out of pipe characters to
separate the two columns of text and make it look more
like a table. But first, we'll reduce the spacing between
the two columns, which are farther apart than they need
to be. We can make both these changes using Visual-Block
mode. See how in Table 6, Adding vertical pipes between
columns, on page 46.

Keystrokes  BufferContents  
------------------------------------------------------
{start}     Chapter       | Page
            Normal mode       15
            Insert mode       31
            Visual mode       44
------------------------------------------------------
<C-v>3j     Chapter      _  Page
            Normal mode  _    15
            Insert mode  _    31
            Visual mode  |    44
------------------------------------------------------
x...        Chapter      |  Page
            Normal mode       15
            Insert mode       31
            Visual mode       44
------------------------------------------------------
gv          Chapter      _  Page 
            Normal mode  _    15 
            Insert mode  _    31 
            Visual mode  |    44 
------------------------------------------------------
r|          Chapter     ||  Page
            Normal mode  |    15
            Insert mode  |    31
            Visual mode  |    44
------------------------------------------------------
yyp         Chapter      |  Page
           |Chapter      |  Page
            Normal mode  |    15
            Insert mode  |    31
            Visual mode  |    44
------------------------------------------------------
Vr-         Chapter      |  Page
            ---------------------
            Normal mode  |    15
            Insert mode  |    31
            Visual mode  |    44
------------------------------------------------------
Table 6 --Adding vertical pipes between columns


To begin, we use <C-v> to engage Visual-Block mode;
then we define the column selection by moving our 
cursor down several lines. Pressing the x key deletes
that column, and the dot command repeats the deletion
for the same range of text. We repeat until the two
columns are about the right distance apart.

Instead of using the dot command, we could have 
expanded our column selection into a box by moving
the cursor two or three steps to the right. Then we
would have to make only a single deletion. I prefer
the instant visual feedback that we get when we delete
a single column and repeat it.

Now that we've lined up the two columns of text where
we want them, we're ready to draw a line between them.
We can reselect our last visual selection using the gv
command and then press r| to replace each character in
the selection with a pipe character.

While we're at it, we may as well draw a horizontal line
to separate the table headers from the rows beneath. We
do a quick line-wise yank-and-put to duplicate the top
line (yyp) and then replace every character in that line
with a dash character (Vr-).


                            Tip 25
Change Columns of Text

We can use Visual-Block mode to insert text into 
several lines of text simultaneously. Visual-Block mode
is not just useful to us when working with tabular data.
Oftentimes, we can benefit from this feature when 
working with code. For example, take this snippet of 
(suboptimal) CSS:

visual_mode/sprite.css
li.one      a{ background-image: url('/images/sprite.png'); }
li.two      a{ background-image: url('/images/sprite.png'); }
li.three    a{ background-image: url('/images/sprite.png'); }

Suppose that the sprite.png file has been moved from images/
into a components/ directory. We'll need to change each of
these lines to reference the file's new location. We could
do this using Visual-Block mode as shown in Table 7, 
Inserting into Multiple Lines, on page 48.

The procedure should look pretty familiar. We begin by
defining the selection that we want to operate on, 
which happens to be a rectangular Visual-Block. When we
hit the c key, all of the selected text disappears and
we are dropped into Insert mode.

As we type the word "components" in Insert mode, it 
appears on the topmost line only. Nothing happens to 
the two lines below. We see the text that we typed in
those lines only when we press <Esc> to return to 
Normal mode.

The behavior of Vim's Visual-Block change command may
be a little surprising. It seems inconsistent that
the deletion shoud affect all marked lines 
simultaneously, but the insertion affects only the
topmost line (at least for the duration of Insert mode
). Some text editors provide similar functionality,
but they update all selected lines at the same time.
If you're used to that kind of behavior (as I was),
then you might find Vim's implementation less polished.

Keystrokes      BufferContents
------------------------------------------------------
{start}         li.one   a{ background-image:
                    url('/|images/sprite.png'); }
                li.two   a{ background-image: 
                    url('/images/sprite.png'); }
Normal mode     li.three a{ background-image: 
                    url('/images/sprite.png'); }
------------------------------------------------------
<C-v>jje        li.one   a{ background-image:
                    url('/_images_/sprite.png'); }
                li.two   a{ background-image: 
                    url('/_images_/sprite.png'); }
Visual mode     li.three a{ background-image: 
                    url('/_image|s_/sprite.png'); }
------------------------------------------------------
c               li.one   a{ background-image:
                    url('/|/sprite.png'); }
                li.two   a{ background-image: 
                    url('//sprite.png'); }
Insert mode     li.three a{ background-image: 
                    url('//sprite.png'); }
------------------------------------------------------
components      li.one   a{ background-image:
                    url('/components|/sprite.png'); }
                li.two   a{ background-image: 
                    url('//sprite.png'); }
Insert mode     li.three a{ background-image: 
                    url('//sprite.png'); }
------------------------------------------------------
<Esc>           li.one   a{ background-image:
                    url('/component|s/sprite.png'); }
                li.two   a{ background-image: 
                    url('/components/sprite.png'); }
Normal mode     li.three a{ background-image: 
                    url('/components/sprite.png'); }
------------------------------------------------------
Table 7 --Inserting into Multiple Lines


But in practice, it makes no difference in the final
outcome. So long as you dip into Insert mode only for
short bursts, you shouldn't have any surprises.


                            Tip 26
Append After a Ragged Visual Block

Visual-Block mode is great for operating on 
rectangular chunk of code such as lines and columns,
but it's not confined to rectangular regions of text.

We've already met this snippet of JavaScript:

the_vim_way/2_foo_bar.js
var foo = 1
var bar = 'a'
var foobar = foo + bar

Three consecuitive lines, each of different length.
We want to append a semicolon at the end of each.
In Tip 2, on page 4, we solved this problem using the
dot command, but we could just as well use Visual-
Block mode. Table8, Appending a Semicolon to Multiple
Lines in Visual-Block Mode, on page 49 shows how.

After engaging Visual-Block mode, we extend our
selection to the end of each line by pressing $. At
first glance, one might expect this to cause difficulty
because each line is a different length. But in this
context, Vim understands

Keystrokes    BufferContents
------------------------------------------------------
{start}       var foo = |1
              var bar = 'a'
Normal mode   var foobar = foo + bar
------------------------------------------------------
<C-v>jj$      var foo = _1_
              var bar = _'a'_
Visual-Block  var foobar_ = foo + ba|r_
------------------------------------------------------
A;            var foo = 1;|
              var bar = 'a'
Insert mode   var foobar = foo + bar
------------------------------------------------------
<Esc>         var foo = |1;
              var bar = 'a';
Normal mode   var foobar = foo + bar;
------------------------------------------------------
Table 8 --Appending a Semicolon to Multiple Lines in
            Visual-Block Mode

that we want to extend our selection to the end of all
selected lines. This lets us break free from our 
rectangular constraints, creating a selection that
traces the ragged right edge of our text.

Having defined our selection, we can append at the end
of each line using the A command (see Vim's Conventions
for "i" and "a" Keys, on page 49). This drops us into
Insert mode on the topmost line of our selection.
Anything that we type will appear on this line only
for the duration of Insert mode, but as soon as we 
revert to Normal mode, our changes are propagated 
across the rest of the lines that we selected.


Vim's Conventions for "i" and "a" Keys

Vim has a couple of conventions for switching from
Normal to Insert mode. The i and a commands both do it,
positioning the cursor in front of or after the current
character, respectively. The I and A commands behave
similarly, except that they position the cursor at the
start or end of the current line.

Vim follows similar conventions for switching from
Visual-Block to Insert mode. The I and A commands both
do it, placing the cursor at the start or end of the
selection, respectively. So what about the i and a
commands; what do they do in Visual mode?

In Visual and Operator-Pending modes the i and a keys
follows a different convention: they form the first
half of a text object. These are covered in greater
depth in Tip 51, on page 120. If you've made a selection
with Visual-Block mode and you wonder why you're not 
Insert mode after pressing i, try using I instead.


In the beginning, there was ed. ed begat ex, and
ex begat vi, and vi begat Vim.
	The Old Testament of Unix

					CHAPTER 5
				Command-Line Mode

Vim traces its ancestry back to vi, which is where
the modal editing paradigm was cnceived. In turn, 
vi traces its ancestry back to a line editor called
ex, which is why we have Ex commands. The DNA of 
these early Unix text editors is preserved in modern
Vim. For some line-oriented tasks, Ex commands are
still the best tool for the job. In this chapter, 
we'll learn how to use Command-Line mode, which 
exposes us to the vestiges of ex.


				Tip 27
Meet Vim's Command Line

Command-Line mode prompts us to enter an Ex command,
a search pattern, or an expression. In this tip, we'll
meet a selection of Ex commands that operate on the
text in a buffer, and we'll learn about some of the
specilal key mappings that can be used in this mode.

We can press the : key, Vim switches into Command-Line
mode. This mode has some resemblance to the command 
line that we use in the shell. We can type the name
of a command and then execute it by pressing <CR>.
At any time, we can switch from Command-Line mode
back to Normal mode by pressing <Esc>.

For historical reasons, the commands that we execute
from Command-Line mode are called Ex command (see
On the Etymology of Vim (and Family), on page 53).
Command-Line mode is also enabled when we press /
to bring up a search prompt or <C-r>= to access the
expression register (see Tip 16, on page 31). Some
of the tricks in this chapter are applicable with
each of these different prompts, but for the most
part we'll focus on Ex commands.

Command			Effect
------------------------------------------------------
:[range]delete[x]	Delete specified lines [into
			  register x]
------------------------------------------------------
:[range]yank[x]		Yank specified lines [into 
			  register x]
------------------------------------------------------
:[line]put[x]		Put the text from register x
			  after the specified line
------------------------------------------------------
:[range]copy{address}	Copy the specified lines to
			  below the line specified
			    by {address}
------------------------------------------------------
:[range]move{address}	Move the specified lines to
			  below the line specified
			    by {address}
------------------------------------------------------
:[range]join		Join the specified lines
------------------------------------------------------
:[range]normal		Execute Normal mode {commands}
  {commands}		  on each specified line
------------------------------------------------------
:[range]substitute/	Replace occurrence of {pattern}
  {pattern}/{string}	  with {string} on each specified
    /[flags]		    line
------------------------------------------------------
:[range]global/		Execute the Ex command [cmd]
  {pattern}/[cmd]	  on all specified lines where
			    the {pattern} matches
------------------------------------------------------
Table 9 --Ex Commands That Operate on the Text 
		in a Buffer

We can use Ex commands to read and write files (:edit
and :write), to create tabs (:tabnew) or split windows
(:split), or to interact with the argument list (:prev
/ :next) or the buffer list (:bprev / :bnext). In fact,
Vim has an Ex command for just about everything (see
:h ex-cmd-index for the full list).

In this chapter, we'll focus mainly on the handful of
Ex commands we can use to edit text. Table 9, Ex 
Commands That Operate on the Text in a Buffer, on page
52, shows a selection of some of the most useful ones.

Most of these commands can accept a range. We'll find
out what this means in Tip 28, on page 54. The :copy
command is great for quickly duplicating a line, as
we'll see in Duplicate Lines with the :t Command, on
page 59. The :normal command provides a convenient way
to make the same change on a range of lines, as we'll
see in Tip 30, on page 61.

We'll learn more about :delete, :yank, and :put commands
in Chapter 10, Copy and Paste, on page 141. The 
:substitute and :global commands are very powerful, so
they each get a chapter of their own. See Chapter 14, 
Substitution, on page 215, and Chapter 15, Global
Commands, on page 237.


Special Keys in Vim's Command-Line Mode

Command-Line mode is similar to Insert mode in that
most of the buttons on the keyboard simply enter a
character. In Insert mode, the text goes into

On the Etymology of Vim (and Family)

ed was the original Unix text editor. It was written
at a time when video displays were uncommon. Source
code was usually printed on to a roll of paper and
edited on a teletype terminal. Commands entered at the
terminal would be sent to a mainframe computer for
processing, and the output from each command would be
printed. In those days, the connection between a 
terminal and a mainframe was slow, so much so that a
quick typist could outpace the network, entering
commands faster than they could be sent for processing.
In this context, it was vital that ed provide a terse
syntax. Consider how p prints the current line, while
%p ptints the entire file.

ed went through several generations of improvements,
including em (dubbed the "editor for mortals"), en,
and eventually ex. By this time, video displays were
more common. ex added a feature that turned the
terminal screen into an interactive window that showed
the contents of a file. Now it was possible to see
change as they were made in real time. The screen-
editing mode was activated by entering the :visual
command, or just :vi for short. And that is where the
name vi comes form.

Vim stands for vi improved. That's an understatement
--I can't stand to use regular vi! Look up :h vi-
differences for a list of Vim features that are 
unavailable in vi. Vim's enhancements are essential,
but it still owes much to its heritage. The constraints
that guided the design of Vim's ancestors have endowed
us with a highly efficient command set that's still
valuable today.


a buffer, whereas in Command-Line mode the text
appears at the prompt. In both of these modes, we can
use control key chords to trigger commands.

Some of these commands are shared between Insert mode
and Command-Line mode. For example, <C-w> and <C-u>
delete backward to the start of the previous word or
to the start of the line, respectively. We can use
<C-v> or <C-k> to insert characters that are not found
on the keyboard. And we can insert the contents of any
register at the command line using the <C-r>{register}
command, just as we saw in Tip 15, on page 29. Some
Command-Line mode mappings are not found in Insert 
mode. We'll meet a few of these in Tip 33, on page 66.

At the command-line prompt, we are limited in the renge
of motions that we can use. The <left> and <right> arrow
keys move our cursor one character at a time in either
direction. Compared to the rich set if motions that 
we're used to using in Normal mode, this can feel quite
limiting. But as we'll see in Tip 34, on page 68, Vim's
command-line window provides all of the editing power
that we could want for composing complex commands at 
the prompt.


Ex Commands Strike Far and Wide

It can sometimes be quicker to use an Ex command than
to get the same job done with Vim's Normal commands.
For example, Normal commands tend to act on the current
character or the current line, whereas an Ex command
can be executed anywhere. This means that we can use
Ex commands to make change without having to move our
cursor. But the greatest feature that distinguishes
Ex commands is their ability to be executed across
many lines at the same time.

As a general rule, we could say that Ex commands are 
long range and have the capacity to modify many lines
in a single move. Or to condense that even further:
Ex commands strike far and wide.


				Tip 28
Execute a Command on One or More Consective Lines

Many Ex commands can be given a [range] of lines to
act upon. We can specify the start and end of a range
with either a line number, a mark, or a pattern.

One of the strengths of Ex commands is that they can 
be executed across a range of lines. We'll use this
short excerpt of HTML as an example:

ex_mode/practical-vim.html
<!DOCTYPE html>
<html>
  <head><title>Practical Vim</title></head>
  <body><h1>Practical Vim</h1></body>
</html>

To demonstrare, we'll use the :print command, which
simply echoes the specified lines below Vim's command
line. This command doesn't perform any useful work, 
but it helps to illustrate which lines make up a range.
Try replacing :print in each of the following examples
with a command such as :delete, :join, :substitute, or
:nomal, and you should get a feel for how useful Ex
commands can be.


Use Line Number as an Address

If we enter an Ex command consisting only of a number,
then Vim will interpret that as an address and move
our cursor to the specified line. We can jump to the
top of the file by running the following:

> :1
> :p
< 1 <!DOCTYPE html>

This file contains only five lines. If we wanted to
jump to the end of the file, we could enter :5 or we
could use the special $ symbol:

> :$
> :p
< 5 </html>

Here we've used :p, which is the abbreviated form of
:print. Instead of splitting up the two commands, we
could roll them into a single incantation:

> :3p
< 3 <head><title>Practical Vim</title></head>

That moves the cursor to line 3 and then echoes the
contents of that line. Remember, we're just using the
:p command for illustrative purpose here. If we had 
issued the command :3d, then we would have jumped to
line 3 and deleted it in a single move. The equivalent
Normal mode commands would be 3G followed by dd. So 
this is one example where an Ex command can be quicker
than a Normal mode command.


Specify a Range of Lines by Address

So far, we've specified adresses as a single line 
number. But we can also specify a range of lines.
Here's an example:

> :2,5p
< 2 <html>
  3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>
  5 </html>

That prints each line from 2 to 5, inclusive. Note
that after running this command, the cursor would
be left positioned on line 5. In general, we could
say that a range takes this form:

:{start},{end}

Note that both the {start} and {end} are addresses.
So far, we've looked at using line numbers for 
addresses, but we'll soon see that using a pattern
or a mark is also possible.

We can use the . symbol as an address to represent
the current line. So, we can easily compose a range
representing everything from here to the end of the
file:

> :2
> :.,$p
< 2 <html>
  3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>
  5 </html>

The % symbol also has a special meaning --it stands
for all the lines in the current file:

> :%p
< 1 <!DOCTYPE html>
  2 <html>
  3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>
  5 </html>

This is equivalent to running :1,$p . Using this
shorthand in combination with the :substitute command
is very common:

> :%s/Practical/Pragmatic/

This command tells Vim to replace the first occurrence
of "Practical" with "Pragmatic" on each line. We'll
learn more about this command in Chapter 14, 
Substitution, on page 215.


Specify a Range of Lines by Visual Selection

Instead of addressing a range of lines by number, we
could just make a visual selection. If we ran the
command 2G followed by VG, we would make a visual
selection that looks like this:

<!DOCTYPE html>
_<html>_
 _ <head><title>Practical Vim</title></head>_
 _ <body><h1>Practical Vim</h1></body>_
_</html>_

If we press the : key now, the command-line prompt
will be prepopulated with the range :'<,'>. It looks
cryptic, but you can think of it simply as a range
standing for the visual selection. Then we can 
specify our Ex command, and it will execute on every
selected line:

> :'<,'>p
< 2 <html>
  3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>
  5 </html>

This range can be really handy if we want to run a
:substitute command on a subset of the file.

The '< symbol is a mark standing for the first line
of the visual selection, while '> stands for the last
line of the visual selection (see Tip 53, on page 126,
for more about marks). These markes persist even we
leave Visual mode. If you try running :'<,'>p straight
from Normal mode, it will always act on the lines that
most recently formed a Visual mode selection.


Specify a Range of Lines by Patterns

Vim also accepts a pattern as an address for an Ex
command, such as the one shown here:

> :/<html>/,/<\/html>/p
< 2 <html>
  3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>
  5 </html>

This looks quite complex, but it follows the usual
form for a range: :{start},{end}. The {start} address
in this case is the pattern /<html>/, while the {end}
address is /<\/html>/. In other words, the range begins
on the line containing an opening <html> tag and ends
on the line containing the corresponding closing tag.

In this particular case, we could achieve the same
result using the address :2,5, which is shorter but
more brittle. If we use patterns to specify the range,
then our command will always operate on the entire
<html></html> element, no matter how many lines it
comprises.


Modify an Address Using an Offset

Suppose that we wanted to run an Ex command on every
line inside the <html></html> block but not on the
lines that contain the <html> and </html> tags 
themselves. We could do so using an offset:

> :/<html>/+1,/<\/html>/-1p
< 3   <head><title>Practical Vim</title></head>
  4   <body><h1>Practical Vim</h1></body>

The general form for an offset goes like this:

:{address}+n

If n is omitted, it defaults to 1. The {address}
could be a line number, a mark, or a pattern.

Suppose that we wanted to execute a command on a
particular number of lines, starting with the current
line. We could use an offset relative to the current
line:

> :2
> :.,.+3p

The . symbol stands for the current line, so :.,.+3 
is equivalent to :2,5 in this case.


Discussion

The syntax for defining a range is very flexible.
We can mix and match line numbers, marks, and patterns,
and we can apply an offset to any of them. This table
summarizes a few of the symbols that can be used to
create addresses and ranges for Ex commands:

Symbol	Address
------------------------------------------------------
1	First line of the file
$	Last line of the file
0 	Virtual line above first line of the file
.	Line where the cursor is placed
'm	Line containing mark m
'<	Start of visual selection
'>	End of visual selection
%	The entire file (shorthand for :1,$)

Line 0 doesn't really exist, but it can be useful as
an address in certain contexts. In particular, it can
be used as the final argument in the :copy{address}
and :move{address} commands when we want to copy or
move a range of lines to the top of a file. We'll see
examples of these commands in the next two tips.

When we specify a [range], it always represents a set
of contiguous lines. It's also possible to execute an
Ex command on a set of noncontiguous line using the
:global command. We'll learn more about that in Chapter
15, Global Commands, on page 237.

		
				Tip 29
Duplicate or Move Lines Using ':t' and ':m' Commands

The :copy commands (and its shorthand :t) lets us 
duplicate one or more lines from one part of the 
document to another, while the :move command lets us
place them somewhere else in the document.

For demonstration purposes, we'll use this shopping
list:

ex_mode/shopping-list.todo
Shopping list
	Hardware Store
	    Buy new hammer
	Beauty Parlor
	    Buy nail polish remover
	    Buy nails


Duplicate Lines with the 't' Command

Our shopping list is incomplete: we also need to buy
nails at the hardware store. To fix the list, we'll
reuse the last line of the file, creating a copy of
it below "Hardware Store". We can easily do so using
the :copy Ex command:

Keystrokes	BufferContents
------------------------------------------------------
{start}		Shopping list
                       |Hardware Store
                	    Buy new hammer
                	Beauty Parlor
                	    Buy nail polish remover
                	    Buy nails
------------------------------------------------------
:6copy.		Shopping list
                        Hardware Store
                	   |Buy nails
                	    Buy new hammer
                	Beauty Parlor
                	    Buy nail polish remover
                	    Buy nails


The format of the copy command goes like this (see
:h :copy):

:[range]copy {address}

In our example, the [range] was line 6. For our 
{address}, we use the . symbol, which stands for the
current line. So we can read the :6copy. command as
"Make a copy of line 6 and put it below the current
line".

We could shorten the :copy command to only two letters,
as :co. Or we can be even more succinct by using the 
:t command, which is a synonym for :copy . As a
mnemonic, you can think of it as copy TO. This table
shows a few examples of the :t command in action:

Command	  Effect
------------------------------------------------------
:6t.	  Copy line 6 to just below the current line
:t6	  Copy the current line to just below line 6
:t.	  Duplicate the current line (similar to 
	   Normal mode yyp)
:t$	  Copy the current line to the end of the file
:'<,'>t0  Copy the visually selected lines to the 
	   start of the file

Note that :t. duplicates the current line. Alternatively,
we could achieve the same effect using Normal mode yank
and put commands (yyp). The one notable difference
between these two techniques for duplicating the current
line is that yyp uses a register, whereas :t. doesn't.
I'll sometimes use :t. to duplicate a line when I don't
want to overwrite the current value int the default
register.

In this example, we could have used a variant yyp to
duplicate the line we wanted, but it would require
some extra moving around. We would have to jump to
the line we wanted to copy (6G), yank it (yy), snap
back to where we started (<C-o>), and use the put
command (p) to duplicate the line. When duplicating
a distant line, the :t command is usually more
efficient.

In Ex Commands Strile Far and Wide, on page 54, we
observed the general rule that Normal commands act
locally, whereas, Ex commands are long range. This
example demonstrates this principle in action.


Move Lines with the ':m' Command

The :move command looks similar to the :copy command
(see :h :move):

:[range]move{address}

We can shorten it to a single letter: :m . Suppose
that we want to move the Hardware Store section after
the Beauty Parlor section. We could do so using the
:move command as shown in Table 10, Moving a Set of
Lines with the ':m' Command, on page 61.

Having make our visual selection, we simply have to 
run the command :'<,'>m$ . Alternatively, we could
run dGp. This breaks down like this: d to delete the
visual selection, G to jump to the end of the file,
and p to paste the text that was deleted.

Keystrokes	BufferContents
------------------------------------------------------
{start}		Shopping list
                       |Hardware Store
                	    Buy nails
                	    Buy new hammer
                	Beauty Parlor
                	    Buy nail polish remover
                	    Buy nails
------------------------------------------------------
Vjj		Shopping list
               _        Hardware Store_
               _	    Buy nails_
               _       |    Buy new hammer_
                	Beauty Parlor
                	    Buy nail polish remover
                	    Buy nails
------------------------------------------------------
:'<,'>m$	Shopping list
                	Beauty Parlor
                	    Buy nail polish remover
                	    Buy nails
                        Hardware Store 
                	    Buy nails 
                           |Buy new hammer 
------------------------------------------------------
Table 10 --Moving a Set of Lines with the ':m' Command


Remember that the '<,'> range stands for the visual
selection. We could easily make another visual selection
and then repeat the :'<,'>m$ command to move the 
selected text to the end of the file. Repeating the last
Ex command is as easy as pressing @: (see Tip 31, on 
page 63, for another example), so this method is more
easily reproducible than using Normal mode commands.


				Tip 30
Run Normal Mode Commands Across a Range

If we want to run a Normal mode command on a series
of consecutive lines, we can do so using the :normal
command, When used in combination with the dot command
or a mocro, we can perform repetitive task with very
little effort.

Consider the example we met in Tip 2, Don't Repeat
Yourself, on page 4. We wanted to append a 
semicolon at the end of a series of lines. Using
the Dot Formula allowed us to complete the task
rapidly, but in that example we need to make the
change only on three consecutive lines. What if we
had to make the same change fifty times? Using the
Dot Formula, we would have to press j. fifty times.
That makes a total of one hundred keystrokes!

There is a better way. To demonstrate, we'll append
a semicolon at the end of each line in this file.
To save space, I've only included five lines, but
if you can imagine instead that there are fifty
lines, then this technique will seem more potent:

cmdline_mode/foobar.js
var foo = 1
var bar = 'a'
var baz = 'z'
var foobar = foo + bar
var foobarbaz = foo + bar + baz

We'll start off as we did before, by changing the
first line:

Keystrokes  BufferContents
---------------------------------------------------
{start}    |var foo = 1
            var bar = 'a'
            var baz = 'z'
            var foobar = foo + bar
            var foobarbaz = foo + bar + baz
--------------------------------------------------
A;<Esc>     var foo = 1|;
            var bar = 'a'
            var baz = 'z'
            var foobar = foo + bar
            var foobarbaz = foo + bar + baz

We want to avoid executing the . command on each
line one by one. Instead, we can use the :normal
Ex command to execute the dot command across a 
range of lines:

Keystrokes  BufferContents
---------------------------------------------------
jVG         var foo = 1;
           _var bar = 'a'_
           _var baz = 'z'_
           _var foobar = foo + bar_
          _|var foobarbaz = foo + bar + baz_
--------------------------------------------------
:'<,'>      var foo = 1;
  normal.   var bar = 'a';
            var baz = 'z';
            var foobar = foo + bar;
            var foobarbaz = foo + bar + baz|;
            
The :'<,'>normal. command can be read as follows:
"For each line in the visual selection, execute
the Normal mode . command. "This technique works
just as well whether we're operating on five lines
or fifty lines. The real beauty of it is that we
don't even have to count the lines --we can get
away with selecting them in Visual mode.

In this case, we've used :normal to execute the
dot command, but we can execute any Normal mode
commands in the same way. For example, we could
have solved the problem above with this single
command:

:%normal A;

The % symbol is used as a range representing the
entire file. So :%normal A; instructs Vim to append
a semicolon at the end of every line of the file.
Making this change involves switching into Insert
mode, but Vim automatically reverts to Normal mode
afterward.

Before executing the specified Normal mode command
on each line, Vim moves the cursor to the beginning
of the line. So we don't have to worry about where
the cursor is positioned when we execute the
command. This single command could be used to 
comment out entire JavaScript file:

:%normal i//

While it's possible to use :normal with any normal
command, I found it most powerful when used in
combination with one of Vim's repeat commands:
either :normal . for simple repeats or :normal @q
for more complex tasks. Skip ahead to Tip 68, 
Repeat a Change on Contiguous Lines, on page 168,
and Tip 70, Act Upon a Collection of Files, on
page 173, for a couple of examples.

In Ex Commands Strike Far and Wide, on page 56, we
noted that Ex commands can change multiple lines
at once. The :normal command allows us to combine
the expressive nature of Vim's Normal mode 
commands with the range of Ex commands. It's a
powerful combination!

For yet another alternative solution to the problem
covered in this tip, refer to Tip 26, Append After
a Ragged Visual Block, on page 50.


                            Tip 31
Repeat the Last Ex Command

While the . command can be used to repeat our most
recent Normal mode command. we have to use @:
instead if we want to repeat the last Ex command.
Knowing how to reverse the last command is always
useful, so we'll consider that, too, in our
discussion.

In Chapter 1, The Vim Way, on page 1, we saw how
the . command can be used to repeat the last 
change. But the dot command won't replay changes 
make from Vim's command line. Instead, we can
repeat the last Ex command by pressing @: (see
:h @:).

For example, this command can be useful when 
iterating through items in the buffer list. We can
step forward through the list with the :bn[ext]
command and backward with the :bp[revious] 
command (Tip 37, Track Open Files with the Buffer
List, on page 83, discusses the buffer list in more
detail). Suppose that we had a dozen or so items 
in the buffer list, and we wanted to take a look
at each one of them. We could type this command
once:

:bnext

Then we use @: to repeat the command. Note the
similarity between this and the method for 
executing a macro (Play Back a Sequence of Commands
by Executing a Macro, on page 163). Also note that
the :register always holds the most recently
executed command line (see :h quote_:). After
running @: for the first time, we can subsequently
repeat it with the @@ command.

Suppose that we got trigger-happy and fired the
@: command too many times, overshooting our mark.
How would we change direction then? We could
execute :bprevious command. But think about what
would happen if we were to use the @: command 
again. It would go backward through the buffer 
list, which is the exact opposite of what it did
before. That could be confusing.

In this case, a better option would be to use the
<C-o> command (see Tip 56, Traverse the Jump List,
on page 135). Each time we run :bnext (or repeat
it with the @: command), it adds a record to the
jump list. The <C-o> command goes back to the 
previous record in the jump list.

We could run :bnext once and then repeat it as
often as we like using the @: command. If we needed
to back up, we could do so using the <C-o> command.
Then, if we wanted to continue going forward 
through the buffer list, we could go back to using
the @: command. Remember our mantra from Tip 4, 
Act, Repeat, Reverse, on page 8: act, repeat, 
reverse.

Vim provides an Ex command for just about 
everything. While it's always possible to repeat
the last Ex command by pressing @:, it's not always
straightforward to reverse the effects. The <C-o>
trick covered in this tip also works for reversing
the effects of :next, :cnext, and :tnext commands
(and so on). Whereas, for each of the items in 
Table 7, Ex Commands That Operate on the Text in
a Buffer, on page 54, we could undo their effects
by pressing u.


                            Tip 32
Tab-Complete Your Ex Commands

Just like in the shell, we can use the <Tab> key
to autocomplete commands at the prompt.

Vim is smart about picking suggestions for 
tab-completion. It looks at the context of what has
already been typed at the command line and builds
a list of suitable suggestions. For example, we
could type this:

:col<C-d>
colder  colorscheme

The <C-d> command asks Vim to reveal a list of 
possible completions (see :h c_CTRL-D). If we hit
the <Tab> key, the prompt will cycle through 
colder, colorscheme, and then the original col
again. We can scroll backward through the 
suggestions by pressing <S-Tab>.

Suppose we want to change the color scheme, but
we can't remember the name of the theme we want.
We could use the <C-d> command to show all the
options:

:colorscheme <C-d>
blackboard desert      morning     shine
blue       elflord     murphy      slate
darkblue   evening     pablo       solarized
default    koehler     peachpuff   torte
delek      mac_classic ron         zellner

This time, <C-d> shows a list of suggestions
based on the color schemes that are available.
If we wanted to enable the solarized theme, we
could just type the letters "so" and then hit the
Tab key to complete our command.

In many scenarios, Vim's tab-completion does the
right thing. If we type a command that expects a
filepath as an argument (such as :edit or :write),
then <Tab> will complete directories and filenames
relative to the current working directory. With
the :tag command we can autocomplete tag names.
The :set and :help commands know about every
configuration option in Vim.

We can even define the tab-completion behavior
when creating our own custom Ex commands. To see
what's possible, check out :h :command-complete.


Choosing form Multiple Matches

When Vim finds only a single suggestion for 
tab-completion, it uses the entire match. But if
Vim finds multiple suggestions, then one of 
several things could happen. By default, Vim 
expands the first suggestion when the Tab key is
pressed for the first time. With each subsequent
press of the Tab key, we can scroll through the
remaining suggestions.

We can customize this behavior by tweaking the
'wildmode' option (see :h 'wildmode'). If you're
used to working with the bash shell, then this
setting will match your expectations:

set wildmode=longest, list

If you're used to the autocomplete menu provided
by zsh, you might want to try this instead:

set wildmenu
set wildmode=full

With the 'wildmenu' option enabled, Vim provides
a navigable list of suggestions. We can scroll
forward through the items by pressing <Tab>, <C-n>
, or <Right>, and we can scroll backward through
them with <S-Tab>, <C-p>, or <Left>.


                            Tip 33
Insert the Current Word at the Command Prompt

Even in Command-Line mode, Vim always knows where
the cursor is positioned and which split window
is active. To save time, we can insert the current
word (or WORD) from the active document onto our
command prompt.

At Vim's command line, the <C-r><C-w> mapping 
copies the word under the coursor and inserts it
at the command-line prompt. We can use this to
save ourselves a bit of typing.

Suppose that we want to rename the tally variable
in this excerpt to counter:

cmdline_mode/loop.js
var tally;
for (tally=1; tally <= 10; tally++ ) {
    // do something with tally
};

With our cursor positioned on the word tally, we
could use the * command to search for each 
occurrence. (The * command is equivalent to typing
the sequence /\<C-r><C-w\><CR>. See Tip 77, Stake
the Boundaries of a Word, on page 193, for a
discussion of how \< and \> items work in a 
pattern.)

Keystrokes  BufferContents
---------------------------------------------------
{start}     var |tally;
            for (tally=1; tally <= 10; tally++ ) {
                // do something with tally
            };
---------------------------------------------------
*           var _tally_;
            for ( |_tally_=1;  _tally_<= 10;
                                 _tally_++ ) {
                // do something with _tally_
            };
---------------------------------------------------
cwcounter   var _tally_;
 <Esc>      for ( counte|r=1;  _tally_<= 10;
                                 _tally_++ ) {
                // do something with _tally_
            };

When we press the * key, our cursor jumps forward
to the next match, but the cursor ends up on the
same word anyway. Typing cwcounter<Esc> makes the
change.

We'll carry out the remaining changes using a 
:substitute command. Since our cursor is on the
word "counter", we dont need to type it out again.
We can just use the <C-r><C-w> mapping to populate
the replacement field:

:%s//<C-r><C-w>/g

That command doesn't look very succinct when 
written down, but two keystrokes to insert a word
ain't bad. We didn't have to type the search
pattern either, thanks to the * command. Refer to
Tip 91, Reuse the Last Search Pattern, on page 225,
to see why we can leave the search field blank
like that.

While <C-r><C-w> gets the word under the cursor,
we can instead use <C-r><C-a> if we want to get
the WORD (for an explanation, see Tip 49, Move
Word-Wise, on page 118). See :h c_CTRL-R_CTRL-W 
for more details. We've used the :substitute 
command in this example, but these mapping can be
used with any Ex command.

For another application, try opening your vimrc
file, place your cursor on a setting, and then
type :help <C-r><C-w> to look up the documentation
for that setting.


                            Tip 34
Recall Commands from History

Vim records the commands that we enter in 
Command-Line mode and provides two ways of 
recalling them: scrolling through past command-
lines with the cursor keys or dialing up the 
command-line window.

Vim keeps a history of our activity in Command-Line
mode. We can easily recall previous commands, so
there's no need to type out a long Ex command
at the prompt more than once.

To begin with, let's switch to Command-Line mode
by pressing the : key. Leave the prompt empty;
then press the <Up> arrow key. The command line
should be populated with the most recent Ex
command that we executed. We can use the <Up> key
again to go further back through our Ex command
history or use the <Down> key to go in the opposite
direction.

Now try typing :help, followed by the <Up> key.
Again, this should scroll through previous Ex 
commands, but instead of showing everything, the
list will be filtered to only include Ex commands
that started with the word "help".

By default, Vim records the last twenty commands.
With memory becoming ever cheaper in today's 
computers, we can probably afford to up this limit
by changing the 'history' option. Try adding this
line to your vimrc:

set history=200

Note that history is not recorded just for the
current editing session. It persists even when we
quit and relaunch Vim (see :h viminfo). Increasing
the number of items recorded in history can be
really useful.

As well as recording a history of Ex commands, Vim
keeps a separate record of our search history. If
we press / to bring up the search prompt, we can
also scroll backward and forward through previous
searches with the <Up> and <Down> keys. The search
prompt is, after all, just another form of Command-
Line mode.


Meet the Command-Line Window

Like Insert mode, Command-Line mode is fine for
composing something from scratch, but it's not a
comfortable place to edit text.

Suppose we're working on a simple Ruby script.
Each time we make a change, we find ourselves
running the following two commands:

:write
:!ruby %

After running these two commands in quick 
succession a couple of times, we realize that we
could streamline our workflow by folding them into
a single command line. This way we can dial up one
complete command from our history and replay it:

:write | !ruby %

Each of these commands is already in our history,
so we shouldn't have to type the entire command
line from scratch. But how can we merge two records
from our history into one? Press q: and meet the
command-line window (see :h cmdwin).

The command-line window is like a regular Vim
buffer, where each line contains an item from our
history. With the k and j keys, we can move 
backward and forward through our history. Or we can
use Vim's search feature to find the line that 
we're looking for. When we press the <CR> key, the
contents of the current line are executes as an
Ex command.

The beauty of the command-line window is that is
allows us to change historical commands using the
full modal editing power of Vim. We can navigate
with any of the motion we're accustomed to using
in Normal mode. We can operate on visual selection
or switch to Insert mode. We can even run Ex 
commands on the contents of the command-line
window!

Having summoned the command-line window by pressing
q:, we could solve our problem as follows:

keystrokes      BufferContents
---------------------------------------------------
{start}        |write
                !ruby %
---------------------------------------------------
A_|<Esc>        write ||
                !ruby %
---------------------------------------------------
J               write ||!ruby%
---------------------------------------------------
:s/write/update |update | !ruby %

Pressing <CR> would then execute the :update | 
!ruby % commands as though we had typed it into 
the command line.

When the command-line window is open, it always
gets the focus. That means we can't switch to
other windows except by dismissing the command-line
window. We can close the command-line window by
running the :q command (just like any ordinary
Vim window) or by pressing <CR>.

Note that when we press <CR> in the command-line
window, the command is executed in the context of
active window: that is, the window that was active
before the command-line window was summoned. Vim
doesn't indicate which is the active window when
the command-line window is open, so pay attention
if you're using split windows!

What if halfway through composing an Ex command at
the prompt, we realize that we need more editing
power? In Command-Line mode, we can use the <C-f>
mapping to switch to the command-line window, 
preserving a copy of the command that was typed
at the prompt. This table summarizes a few of the
methods for summoning the command-line window:

Command Action
---------------------------------------------------
q/      Open the command-line window with history
            of searches
---------------------------------------------------
q:      Open the command-line window with history
            of Ex commands
---------------------------------------------------
ctrl-f  Switch from Command-Line mode to the
            command-line window

It's easy to mix up the q: and :q commands. I'm
sure that we've all opened the command-line window
by accident when we actually meant to quit Vim!
It's a shame, because this feature is really
useful, but many people are frustrated by their
first (accidental) encounter with it. Skip ahead
to Tip 85, Create Complex Patterns by Iterating
upon Search History, on page 211, for another
example of the command-line window in action.


                            Tip 35
Run Commands in the Shell

We can easily invoke external programs without
leaving Vim. Best of all, we can send the contents
of a buffer as standard input to a command or use
the standard output from an external command to 
populate our buffer.

The commands discussed in this tip work best when
used from Vim inside a terminal. If you're using
GVim (or MacVim), then things may not work quite
as smoothly. That shouldn't come as a great
surprise. It's much easier for Vim to delegate
work to the shell if Vim itself is already running
inside a shell. GVim does some things better, but
this is one area where terminal Vim has the edge.


Executing Programs in the Shell

From Vim's Command-Line mode, we can invoke
external programs in the shell by prefixing them
with a bang symbol (see :h :!). For example, if we
want to examine the contents of the current 
directory, we could run the following:

:!ls
duplicate.todo          loop.js
emails.csv              practical-vim.html
foobar.js               shopping-list.todo
history-scrollers.vim

Press ENTER or type command to continue


Note the difference between :!ls and :ls --the 
former calls the ls command in the shell, whereas,
:ls calls Vim's built-in command, which shows the
contents of the buffer list.

On Vim's command line, the % symbol is shorthand
for the current file name (see :h cmdline-special).
We can exploit this to run external commands that 
do something with the current file. For example,
if we're working on a Ruby file, we could execute
it  by running this:

:!ruby %

Vim also provides a set of filename modifiers, 
which allow us to extract information from the
current filename, such as its path or extension
(see :h filename-modifiers). Skip ahead to Tip 45,
Save Files to Nonexistent Directories, on page 107,
for an example of how these can be used.

The :!{cmd} syntax is great for firing one-off
commands, but what if we want to run several 
commands in the shell? In that case, we can use
Vim's :shell command to start an interactive shell
session (see :h :shell).

:shell
$ pwd
/Users/drew/books/PracticalVim/code/cmdline_mode
$ ls
duplicate.todo          loop.js
emails.csv              practical-vim.html
foobar.js               shopping-list.todo
history-scrollers.vim
$ exit

The exit command kills the shell and returns us
to Vim.


Putting Vim in the Background

The :shell command is a feature provided by Vim,
which lets us switch to an interactive shell. But
if we're already running Vim in a terminal, then
we also have access to built-in shell commands.
For example, the bash shell supports job control,
which allows us to suspend a job by putting it 
into the background and then lets us resume it
later by bringing it back into the foreground.

Suppose that we're running Vim inside a bash shell
and we want to execute a series of shell commands.
Pressing Ctrl-z suspends the process that's 
running Vim and returns control to bash. The Vim
process sits idle in the background, allowing us 
to interact with our bash session as normal. We
can inspect the list of jobs by running this 
command

$ jobs
[1]+ Stopped    vim

In bash, we can use the fg command to resume a
suspended job, bring it back into the foreground.
That brings Vim back to life exactly as we left
it. The Ctrl-z and fg commands are quicker and
easier to use than Vim's equivalent :shell and
exit commands. For more information, run man bash
and read the section on job control.


Using the Contents of a Buffer for Standard
    Input or Output

While we use the :!{cmd} syntax, Vim echoes output
from the {cmd}. This works fine if the command
produves little or no output, but it's not very
helpful if the command produces many lines of
output. As an alternative, we can use the :read
!{cmd} command, which puts the output from the
{cmd} into our current buffer (see :h :read!).

The :read !{cmd} command lets us direct standard
output into a buffer. As you might expect, the 
:write !{cmd} does the inverse: it uses the 
contents of the buffer as standard input for the 
specified {cmd} (see :h :write_c). Skip ahead to
Tip 46, Save a File as the Super User, on page
108, to see an example of this feature in use.

The bang symbol can take on different meanings
depending on where it is placed withing the 
command line. Compare these commands:

:write !sh
:write ! sh
:write! sh

The first two commands pass the contents of the
buffer as standard input to the external sh
command. The last command writes the contents of
the buffer to a file called sh by calling the
:write! command. In this case, the bang tells Vim
to overwrite any existing sh file. As you can see,
the placement of the bang symbol can drastically
alter the outcome. Take care when composing this
sort of command!

The effect of the :write !sh command is that each
line of the current buffer is executed in the
shell. Refer to :h rename-files for a nice example
of this command on use.


Filtering the Contents of a Buffer Through an 
    External Command

The :!{cmd} command takes on a different meaning
when it's given a range. The lines specified by
[range] are passed as standard input for the {cmd},
and then the output from {cmd} overwrites the 
original contents of [range]. Or to put it
another way, the [range] is filtered through the
specified {cmd} (see :h :range!). Vim defines a
filter as "a program that accepts text as standard
input, changes it some way, and sends it to 
standard output".

As a demonstration, let's use the external sort
command to rearrange the records in this CSV file:

cmdline_mode/email.csv
first name,last name.email
john,smith,john@example.com
drew,neil,drew@vimcasts.org
jane,doe,jane@example.com

We'll sort the records by the second field:
last name. We can use the -t',' option to tell the
sort command that fields are separated with commas,
and we can use the -k2 flag to indicate that the
second field is to be used for the sort.

The first line of the file contains header 
information. We want to leave it at the top
of the file, so we'll execute it from the sort
operation by using a range of :2,$. This command
line does what we want:

:2,$!sort -t',' -k2

The records in our CSV file should now be sorted
by last name:

first name,last name.email
jane,doe,jane@example.com
drew,neil,drew@vimcasts.org
john,smith,john@example.com

Vim provides a convenient shortcut for setting the
range of a :[range]!{filter} command such as this.
The !{motion} operator command drops us into 
Command-Line mode and prepopulates the [range] with
the lines covered by the specified {motion} (see
:h !). For example, if we place our cursor on line
2 and then invoke !G, Vim opens a prompt with the
:.,$! range set up for us. We still have to type
out the rest of the {filter} command, but it saves
a little work.


Discussion

When operating Vim, we're never more than a couple
of keystrokes away from the shell. This table 
summarizes a selection of the most useful methods
for calling external commands:

Command         Effect
---------------------------------------------------
:shell          Start a shell (return to Vim by
                 typing exit)
---------------------------------------------------
:!{cmd}         Execute {cmd} with the shell
---------------------------------------------------
:read !{cmd}    Execute {cmd} in the shell and 
                 insert its stadard output below
                  the cursor
---------------------------------------------------
:[range]write   Execute {cmd} in the shell with
 !{cmd}          [range] lines as standard input
---------------------------------------------------
:[range]!       Filter the specified [range]
 {filter}        through external program {filter}


Vim gives special treatment to some commands. For
example, both make and grep have wrapper commands.
Not only are they easy to execute from inside Vim,
but their output is parsed and used to populate
the quickfix list. These commands are covered in
greater depth in both Chapter 17, Compile Code
and Navigate Errors, on page 263, and Chapter 18,
Search Project-Wide, on page 273.


                            Tip 36
Run Multipe Ex Commands as a Batch

If we need to execute a sequence of Ex commands,
we can save ourselves work by putting those
commands in a script. Next time we want to run
those commands, we can source the script rather
than typing the commands one by one.

This file contains links to the first couple of
episodes from the Vimcasts archive:

cmdline_mode/vimcasts/episode-1.html
<ol>
  <li>
    <a href="/episodes/show-invisibles/">
      Show invisibles
    </a>
  </li>
  <li>
    <a href="/episodes/tabs-and-spaces/">
      Tab and Spaces
    </a>
  </li>
</ol>

We need to midify this into a plain-text format
showing the title follwoed by the URL:

cmdline_mode/vimcasts/episode-1.txt
Show invisibles: http://vimcasts.org/episode
                    /show-invisibles/
Tabs and Spaces: http://vimcasts.org/episode
                    /tabs-and-spaces/

Let's suppose we anticipate having to make these
same transformations across a series of files that
follow a similar format. We'll look at a couple
of different ways we could approach this.


Run Ex Commands One by One

It might be possible to make this transformation
using a single :substitute command, but my
preference would be to break this up into several
small tasks. This sequence of Ex commands is one
possible solution:

:g/href/j
:v/href/d
8 fewer lines
:%norm A: http://vimcasts.org
:%norm yi"$p
:%s/\v^[^\>]+\s//g

You don't have to understand what each of these
commands does to follow the rest of this tip, but
if you're curious, here's a brief outline. The
:global and :vglobal commands work together to
collapse the file down into two lines that contain
the information we need, albeit in the wrong
order (Tip 99, Delete Lines Containing a Pattern,
on page 242). The :normal commands append the URL
at the end of the line (Tip 30, Run Normal Mode
Commands Accross a Range, on page 63). And the
:substitute command removes the opening <a href=
""> out for yourself.


Write Ex Commands to a Script and Source It

Instead of executing these commands one by one,
we could put them all into a file and save it to
disk. Let's call it batch.vim (Using the .vim
extension will make Vim use the correct syntax
highlighting). Each line of this file corresponds
to a command line from the workflow outlined 
earlier. In this context we don't need to prefix
each line with a : character. Personally, I
prefer to use the longhand names for Ex commands
when putting them in a script. Saving keystrokes
is less of a concern than making the script easy
to read.

cmdline_mode/batch.vim
global/href/join
vglobal/href/delete
%normal A: http://vimcasts.org
%normal yi"$p
%substitute/\v^[^\>]+\>\s//g

We can use the :source command to execute the
batch.vim script (see :h source). Each line of the
script is executed as an Ex command, just as
though we had typed it at Vim's command line. 
You've probably come across the :source command
before in another context: it's commonly used to
load configuration setting from a vimrc file at 
runtime. (See Save Your Configuration in a vimrc
File, on page 304, for more details.)

I suggest you try this out for yourself. You can
download the source code from Practical Vim's
book page on the Pragmatic Bookshelf site. Before
opening Vim, change to the cmdline_mode directory,
where you'll find both the batch.vim and 
episode-1.html files.

$ pwd 
~/dnvim2/code/cmdline_mode
$ ls *.vim
batch.vim       history-scrollers.vim
$ vim vimcasts/episodes-1.html

Now we can execute our script:

:source batch.vim

With that single command line, we've executed each
of the Ex commands from batch.vim. If you change
your mind, you can undo those changes by pressing
the u key once.


Source the Script to Change Multiple Files

There's little point in saving our Ex commands to
a file if we're only going to execute the script
one time. This trick comes into its own if we want
to run that same sequence of Ex commands several
times.

The code samples provided with this book include
a few files with the same format as the episode-1.
html file. Make sure that you're in the cmdline_
mode directory and launch Vim:

$ pwd
~/dnvim2/code/cmdline_mode
$ ls vimcasts
episodes-1.html episode-2.html  episode-3.html
$ vim vimcasts/*.html

Launching Vim with a wildcard will populate the
argument list with all of the files that match
that pattern. We could step through those files
one by one, sourcing our batch.vim for each one:

:args
[vimcasts/episode-1.html] vimcasts/episode-2.html
vimcasts/episode-3.html
:first
:source batch.vim
:next
:source batch.vim
etc.

Or better still, we could use the :argdo command
(:h :argdo):

:argdo source batch.vim

Boom! With a single command we've executed each
of the Ex commands in batch.vim across each of the
files in the argument list.

I've chosen to illustrate this technique using
a varied selection of Ex commands to demonstrate
what's possible. In practice, I most commonly use
this technique to execute one or more :substitute
commands if I find myself using them again and 
again. I'll often discard the batch.vim file
after use, but I might put it under source control
if I think it could be useful in the future.
